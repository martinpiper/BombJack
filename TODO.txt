* Video: Make a call to remove the placement of the 2114 RAMs



* The single cycle low pulse for "end of hblank" as well as "start of hblank" could be exposed via the backplane




* Sprite2: Try reducing the time needed to read the registers, by not having the memory rest periods before the latches
	Initial test didn't work so well, looks like the calculations and loads went wrong




* Sprite2: ROM needs ZIF socket space, or at least a socket with wipes (not precision)




* Done: Video layer: can have 4 register bits to enable each pixel input independently.
	Done: This activity signal for each layer can then be sent out through the pixel headers.
	TODO: This reduces the complexity of each layer.
	TODO: * kVideo_EnableDisplay_Tiles_Enable is already there in the video and tiles logic, it could be reduced in the tiles schematic




* Fix the Sprite schedule to align with the overscan expectation that the V counter only changes at the end of the hblank
	Could also allow MSBX for the sprite by using the F (full screen height) flag. MSBX is much more useful that the full screen height flag.
	CMPBLK signal might be able to be removed
	* The emulation would need to be fixed the add an optional new video board behaviour and the fixed sprite behaviour
	The sprite rendering line can be 512 bytes long, like sprites2, giving a much better horizontal clipping range





* Audio: DAC to opamp output: http://users.ece.utexas.edu/~valvano/Volume1/E-Book/C13_DACSound.htm



* Consider a "hat" board for each voice, using a common bus interfacing with the main logic board
	Each hat would have a signal to select it from the voice schedule




* Original timings from the original schematic from root sheet 3
	1H	2H	4H		_SLOAD	_SL1	_SL2
	0	0	0		1		1		1
	1	0	0		1		0		1
	0	1	0		1		1		1
	1	1	0		1		1		0
	0	0	1		1		1		1
	1	0	1		1		1		1
	1	1	1		0		1		1
	* Looking at the timings, it seems as though the original tiles layer has some timing bugs to do with colour loading, but these would not be visible in the graphics data as the edges of tiles and tile colours didn't change much




* New Tiles board mostly works with 16 colours, except certain there is a weird colour strobing effects with what looks like 8 pixel gaps that do not move with the X or Y scroll position
	Investigate further: Perhaps related to: Real hardware When Tiles X scroll & 7 = 7
		Note: This effect is visible in the 8 colour board version (videos) after the X scroll bug is fixed with the extra external board. https://youtu.be/UzVHgiNhnio?t=69
			So it's not a regression per se
	* Options:
		* No difference - Try bypassing the adders, by removing them and using the BGH values without any add, to see if that fixes the ripple
			Although, setting the plane selector to %11111111 to select the last plane, filling the remaining palette with grey scale colours, and then using the 1H debug header pin did show considerable unstable values in the "meant to be" alternate pixel colours
				Note: The same noisy effect, with 1H to pixel header, is visible in the 8 colour board stack as well. So also not a regression per se.
			* Repositioning the VGA cable and video conversion box did show some improvement.
			* Going to have to get the logic analyser out I think and try to see how clean the captured signal is with a test pattern on screen
		* Perhaps because the 6MHz clock is used to latch the H/V/signals then the counters for the original signals should be used _6MHz instead?
			* Tried: To remove the H/V/signal latch effect, the latches can be removed and the inputs and outputs can be connected to restore the previous functionality
				Remove U255 , U256 , U259
					Connect pins:
						3	2
						4	5
						7	6
						8	9
						13	12
						14	15
						17	16
						18	19
				* No effect, tiles still shows the wobbly pixels. The 1H pin header into pixel header also still shows wobbly pixels, even without any other boards plugged in.
					Starting to think it is signal reflection on these lines?
					But even sourcing the pixel signal directly from U255 pin 2 or 3 (1H or pre1H) still shows the wobble
			* Alternatively try changing 3T:B clock input to be _6MHz
				Before and after change output images are exactly the same in simulation
			* TODO: Need to try changing the input clock pin on 3T:B pin 11 from 4T pin 9 6MHz to 4T pin 13 _6MHz
				Also 3S pin 2 and 3R pin 2

		* Since the above, likely no difference - Try using a 74273 latch for the BGH values coming from the adders with a latch on 6MHz
			This will push the tile pixels one pixel behind, but can be corrected by using a 0xffff X scroll value
				As long as the full screen edges are correct
		* Remove the same RAM being used and separate out the colour and screen display RAMs. This means the screen and colour loads are in parallel
		* Remove the 16x16 tiles completely and just use the double RAM technique to increase the size of the 8x8 chars screen instead
			Basically have one chars layer design only and just build two or even three to get desired layer functionality
			Will need to test chars layer hardware scrolling capability first
	* The new chars board, with those tall columns that show the effect in the tiles board, is also visible in the charslayer
		The logic is very different in the tiles board, so perhaps this indicates the issue is in the video board after all?
			* TODO: Check if the video board timer generation needs some pull-up resistors? Or perhaps a filter capacitor?
	* Squeezing, or even touching, CSYNC1 produces noticeable visual horizontal shifting of the video signal and alters the noise observed?
		Squeezing TVSYNC1 produces a similar effect, but less noticeable.
		Perhaps related to the VIDCLK and 6MHz signals being routed through 3T:a which is quite distant from the main clock circuitry on the version of the video board fabricated
			Split out 3TT:B from 3T:B to ensure the 3T and 4T ICs are very near each other
	* TODO: Using the header and jumper VGA connector from the prototype 1 board, try switching back to the HV sync method... and also try some filtering caps




* Flux
* Power meter
* Solder sucker https://www.electronicshub.org/best-desoldering-stations/
	https://www.amazon.com/YIHUA-Desoldering-Station-Soldering-Iron/dp/B07RTXCHGV/ref=sr_1_5?dchild=1&keywords=YIHUA+948+ESD+Safe+2+in+1+80W+Desoldering+Station+and+60W+Soldering+Iron-+Desoldering+Gun+and+Soldering+Station&qid=1623224018&sr=8-5



* PCB Smoke test procedures
	Populate timer crystal, resistors, capacitor
	Populate 3T and 4T
	Connect jumper
	4T pin 1 input needs to be driven low (display enable)
	Connect power
	Measure 4T output pin 9, remember to connect GND (grey wire) on the logic analyser
	Logic analyser logic threshold 2V




* When trying to auto-route, gradually reduce the plane to signal layers until route succeeds
	Menu->Technology->Set Layer Stackup
		Gradually reduce each type "Plane" to "Signal" starting with the top most plane *with the greater number of existing layers* first.
		** Remember to check the Menu->Technology-Design Rule Manager
			Tab: Net Classes
				That Net Class: "Signal" is enabled for the required layers, adjust for layer pairs
* For PCBWay export and quote
	Menu->Output->Generate Gerber
		Choose: RS274X
	Menu->Output->Generate Pick and Place File
		Drop downs: Part ID | <<empty>> | Package | <<empty>> | Layer | Rotation | X | Y
		File format: CSV
		Export, append "- PNP" suffix
	Toolbar->Bill of Materials ($ icon)
		Use columns
			Stock Code
			Supplier
			Placed
		Choose: Full CSV
		Press CSV button ("a" document icon)
		Text Import window
			Click top left grid, to select all cells
			Drop down: Column type: Text
			Press: OK
			Menu->Data->Auto filter
			Group Layer
				Choose "Group Layer" filter (e.g. Chars)
				Choose "Placed" filter "Top Copper"
			Ctrl+A - Select all
			Ctrl+C - Copy
			Ctrl+N - New sheet
			Ctrl+V - Paste
			Menu->Data-Auto Filter
			Ctrl+A then double click column separator to resize all columns to fit the data
			For PCBWay BOM choose to merge suitable component sockets and any other intended components
				The "Supplier" column has IC sockets, for assembly. The actual ICs from the "Stock Code" column are then socketed.
				For example:
					Sort by "Supplier"
						Then copy from "Stock Code" into the empty supplied cells all those components PCBWay can order and assemble.
				Delete columns:
					Category
					Value
					Stock Code
					Unit Cost
					Description
					Group Layer
					PCB Package
				Save as XLSX file using "- BOM" suffix, where the naming matches the exported layer Gerber CADCAM file
	Order note: Your standard 1.6mm +/- 10% 1oz stackup is OK. Please assemble 1 board, leave the other boards bare. The BOM file "Supplier" column contains the component ordering links.
		
			

			
			
			


* Audio: Clarify oscillator and crystal timing rate (4MHz) and C5 capacitance for this rate.
	Need correct mouser links.

		


* For the video combination layer, for each pixel input, perhaps add a pixel XOR value that can be used to introduce fast changing palette effects?
	This would be very useful for road layer palette cycling effects: 		http://www.extentofthejam.com/pseudo/#hw
	Or an alternative would be to have the tiles layer have two roads of course. Perhaps a copy of the first road but with different palette for the second.
	https://www.spriters-resource.com/arcade/outrun/




* User port layout : Consider moving the ribbon cable header to the bus edge

* User port: For the Raspberry Pi interface it is useful to have the %v from the C64 drive the 5V side of the level shifters
	This would need an extra line for the C64 5V and call the net "C645V", be careful not to connect it to the 5V on the externally powered user port interface!




* USB logic analyser and data generator: https://www.linkinstruments.com/logana32.html



* Any way to use the connectivity report to assert for fan out limits for LS and HCT part inputs?



* Clock/video lines may need some buffering / extension with 74ls240 or similar for some of the larger boards due to the LS limit of 10 fan-out
	Design Explorer
	Main menu->View->Netlist view
		Then move up/down the netlist entries for each root sheet checking the size
		Sort the netlist table view by "Type" and monitor the number of inputs
	Potential problems:
		6MHz
		_MEWR
		EA*
		ED*




* https://www.mythtv.org/wiki/RGB_Scart
	Generating CSYNC from HSYNC+VSYNC
	https://en.wikipedia.org/wiki/Component_video_sync





* For the mode7 register latches, it might be better to only latch on the HH byte write, but this would use an additional 3*6 latches, which would be too much.
	This would allow updates at any point in the scanline, with the copper. At the moment a write to the l/h/hh registers cannot happen in one pixel clock so the added value will be partially updated and used.



* Idea for new layer, scaled rotated sprites
	Setup sprite data x/y/dx/dxy/dy/dyx like mode7, plus a screen top left x/y plus width/height bounding box to iterate.
	It spits out pixels into the screen buffer and signals when it's done
		* This signal would need the ability to read values over the user port interface
	And could optionally hop into the next item in a link list... and signal the end of the link list
		the mode7 render got me thinking, because the circuitry only really differs in the "fetch a tile index from the screen memory" side of things
		So basically rendering a rotated quad outside the edges test becomes "is the X and Y tile position = 0" instead of "fetch tile index"
		If it's outside the edges then don't plot pixels
	* Could have one pixel push pipeline, that ends up writing to two RAMs, where the address is selected as the screen display (in read mode) or the write address from the calculation (in write mode)
		So 2 input 1 output selectors for the address.




* Need a simple bottom left |_ tile, then position this in the four corners with suitable H/V flips to allow the maximum pixel extent to be validated
	Then validate the border shrinks






* Need DigitalDisplay frame recording and verification of displayed frame with recorded frame.
	Pixel by pixel tests. Can display if the current frame as it is being built up matches the recording, or not.
	Highlight areas that don't match?
	
	

* Need the DigitalData model to also verify a recording against what it currently detects.
	It can also display if what it has received so far matches the recording.



* Need to update ReadMe to reflect new design




	


