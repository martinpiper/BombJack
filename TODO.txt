* Check if constant _OE can be used on all 6116 and 6264 chips instead of toggling them
	Video board shows logic contentions, but data writes seem to still be OK




* When running with BombJack\output\DebugAPUOutput.txt from the SotB demo, frame debug*31 has a wrong sprite for the tree, bottom right under the logo.
	This doesn't happen from the emulation debug output VideoHardware\target\debugData.txt
	** Perhaps reconcile the simulation output with the emulation output, find any mismatching write first
		This will need a tool to check data bytes written after each ^-$01, but will need to sync using w$ values instead since the simulation output doesn't have ^-$01
	Reconcile shows some sprite register write mismatches: python C:\Work\BombJack\ReconcileData\ReconcileData.py C:\work\C64\VideoHardware\target\debugData.txt C:\work\BombJack\output\DebugAPUOutput.txt
		Begin reconciliation
		data     152950   982301a0  :  589568   9823019f	x
		data     152955   982701b0  :  589584   982701af	x
		data     163566   9823019f  :  611192   9823019e	x
		data     163571   982701af  :  611208   982701ae	x
		data     174130   9823019e  :  632764   9823019d	x
		data     174135   982701ae  :  632780   982701ad	x
		data     181770   98180146  :  647816   98180106	f
		data     184699   9823019d  :  654340   9823019c	x
		data     184703   982701ad  :  654356   982701ac	x
		data     185739   98190115  :  655916   98190100	c
		data     195258   9823019c  :  675908   9823019b	x
		data     195263   982701ac  :  675924   982701ab	x
		data     205826   9823019b  :  697484   9823019a	x
		data     205831   982701ab  :  697500   982701aa	x
		data     216394   9823019a  :  719060   98230199	x
		data     216399   982701aa  :  719076   982701a9	x
		Read lines  226919  :  740465
	This shows all the reconciliation differences are data byte not address based.
		Most are "x" position differences
		One "f" is a sprite frame difference
			; Frame 44
		One "c" is a sprite colour difference
	d$98180106 the sprite frame difference only appears once in DebugAPUOutput.txt
		It also only happens at w$ff03ff00,$94021901
		;@time:0.680369
		;delta:0.000003
		w$ff03ff00,$94021901
		d$98180106
	Using a timed breakpoint run for 0.680368 seconds (-0.000001)
		It is using APU RAM $1bb which contains $06
		Added APUDRAMA[0..12] and _APUDRAMWE for U17 Can record DATA[0..7]
		Looking for d$01bb0006 in BombJack\output\DebugAPUDataRAM.txt
			;@time:0.673315
			;delta:0.000071
			d$01bb0006
		Only one instance...
		So run to 0.673314 (-0.000001)
		The write to the data RAM is definitely outputting an occasional 06 even though it started out as 46
		This is due to the data selection and direction logic at U22 U124 U125
		The APU DigitalData generator is using timings
			0.000000125
			0.000000125
			0.000000000
			0.000000000
		This seems a little short?
		Perhaps set the DigitalData to use these values as they are meant to come from the user port module...
			0.000000150
			0.000000125
			0.000000015
			0.000000390
		Hmm still seeing:
			;@time:0.673315
			;delta:0.000071
			w$ff03ff00,$24036f01
			d$01bb0006
		Perhaps still not long enough? Measure and replicate the timings from the userport interface...
		* The userport interface, with 4MHz, has 270ns setup and 240ns write
		Even with:
			0.000000270
			0.000000240
			0.000000015
			0.000000625
		The U22 74LS373 is generating UND outputs, even through the 6264 is FLT and OE is disabled
	** Making _OE always low seems to solve the incorrect UND write issue
		According to the datasheet this is a _OE write cycle 1 model: https://www.mouser.sg/datasheet/2/12/Alliance%20Memory_64K_AS6C6264v2.0July2017-1144693.pdf
			Page 2 of 12 shows _OE can be X (Don't care) when _WE is low
		Data reconciliation shows the 46 write is fixed
			There are other recon issues, but these seems to be old data which could be a slow write issue, not wildly incorrect data issues
		Could this explain why writing to the chars with the screen on, during the visible screen portion, sometimes generates that spurious write?
		


* Check if 27C512 needs wiped sockets


* Kobiconn plugs are obsolete and need replacing
	https://www.mouser.sg/ProductDetail/Kobiconn/161-0097-E?qs=XvXsANjzvCPrZr5AKzRXng%3D%3D
	removed from V8.0 BOM


* Video: The analogue signals between the resistor ladders and their headers could benefit from being manually placed with wider gaps?
	Also the VGA and 2x4 header output could benefit from being closer to the resistor ladders?



* Audio: Perhaps widen the resistor ladders and separate the analogue output, much like the video board usage of keepout areas



* Plastic (PDIP) 6116 (6116SA20TDB) 2Kx8 SRAM 20ns is going end of life
	EoL notice: https://www.mouser.sg/ProductDetail/IDT/6116SA20TPGI?qs=sGAEpiMZZMt9mBA6nIyysK6VW3GrAnba45Kc6Apw0Go%3D
	https://www.renesas.com/us/en/products/memory-logic/srams/asynchronous-srams
	https://www.renesas.com/us/en/products/memory-logic/srams/asynchronous-srams?field-organization=2K%20x%208&method-field-organization=OR
	The ceramic (CDIP) parts however (search for A20) are still continued
	https://www.renesas.com/us/en/products/memory-logic/srams/asynchronous-srams/5962-89690-50v-2k-x-8-asynchronous-static-ram
	All sizes https://www.mouser.sg/c/semiconductors/memory-ics/sram/?interface%20type=Parallel&mounting%20style=Through%20Hole&organization=1%20k%20x%208%7C~2%20k%20x%208%7C~4%20k%20x%208%7C~8%20k%20x%208%7C~16%20k%20x%208&supply%20voltage%20-%20max=5.5%20V
	** 16k https://www.mouser.sg/c/semiconductors/memory-ics/sram/?interface%20type=Parallel&memory%20size=16%20kbit&mounting%20style=Through%20Hole&organization=1%20k%20x%208%7C~2%20k%20x%208%7C~4%20k%20x%208%7C~8%20k%20x%208%7C~16%20k%20x%208&supply%20voltage%20-%20max=5.5%20V
	** 20ns https://www.mouser.sg/c/semiconductors/memory-ics/sram/?access%20time=20%20ns&interface%20type=Parallel&memory%20size=16%20kbit&mounting%20style=Through%20Hole&organization=1%20k%20x%208%7C~2%20k%20x%208%7C~4%20k%20x%208%7C~8%20k%20x%208%7C~16%20k%20x%208&supply%20voltage%20-%20max=5.5%20V&sort=access%20time
	
	
	
* Sprites2 
* Scaled sprite rotation, if the EPROM is too slow, then split the pixel output across two clocks?
	There would need to be some latches for the second part of the output path, to ensure that the next sprite being read (during the attribute read) does not affect the final values being written
		Or simpler to pass through the reset logic signal to the last part of the pixel output, which would increase the end period between one sprite and the next sprite reads by one clock as the pixels are flushed...
	2 x 64KB EPROMS, for X and Y rot, the high bit in one of the EPROMS would indicate if the result it out of the sprite bounds or not
	Possible to have different X/Y rotations? Which would generate some skews?
		Doesn't look good...
	https://segaretro.org/Sega_X_Board
		Sprite pixels/texels per frame: 833,333 (at 60 Hz) to 838,408 (at 59.6368 Hz)
		Sprite pixels/texels per scanline: 3180 to 3200 sprite pixels/texels per scanline
		Sprites/textures per scanline: 256
	https://github.com/bji/libmame/blob/master/old/src/mame/video/segaic16.c
	https://github.com/bji/libmame/blob/master/old/src/mame/video/sega16sp.c#L1059
	Perhaps the sprite index high bit could signify sqrt(2) corrected scales to avoid sprite edges
		Meaning select different rotation EPROMs...
		Allowing the full 256 rotations to be used in the lookup
		Plus full 8 bits used for X/Y coords...
		Hmm X and Y would need to be used, or would need multiply lookups for separate X and Y with adds, which doubles IC count...
		Plus X/Y coordinate correction EPROMs based on rotation...





* The single cycle low pulse for "end of hblank" as well as "start of hblank" could be exposed via the backplane




* Sprites2: Try reducing the time needed to read the registers, by not having the memory rest periods before the latches
	Initial test didn't work so well, looks like the calculations and loads went wrong




* Sprites2: ROM needs ZIF socket space, or at least a socket with wipes (not precision)




* Audio: DAC to opamp output: http://users.ece.utexas.edu/~valvano/Volume1/E-Book/C13_DACSound.htm



* Consider a "hat" board for each voice, using a common bus interfacing with the main logic board
	Each hat would have a signal to select it from the voice schedule




* Audio: Clarify oscillator and crystal timing rate (4MHz) and C5 capacitance for this rate.
	Need correct mouser links.

		


* For the video combination layer, for each pixel input, perhaps add a pixel XOR value that can be used to introduce fast changing palette effects?
	This would be very useful for road layer palette cycling effects: 		http://www.extentofthejam.com/pseudo/#hw
	Or an alternative would be to have the tiles layer have two roads of course. Perhaps a copy of the first road but with different palette for the second.
	https://www.spriters-resource.com/arcade/outrun/




* User port layout : Consider moving the ribbon cable header to the bus edge

* User port: For the Raspberry Pi interface it is useful to have the %v from the C64 drive the 5V side of the level shifters
	This would need an extra line for the C64 5V and call the net "C645V", be careful not to connect it to the 5V on the externally powered user port interface!




* USB logic analyser and data generator: https://www.linkinstruments.com/logana32.html



* Any way to use the connectivity report to assert for fan out limits for LS and HCT part inputs?



* Clock/video lines may need some buffering / extension with 74ls240 or similar for some of the larger boards due to the LS limit of 10 fan-out
	Design Explorer
	Main menu->View->Netlist view
		Then move up/down the netlist entries for each root sheet checking the size
		Sort the netlist table view by "Type" and monitor the number of inputs
	Potential problems:
		6MHz
		_MEWR
		EA*
		ED*




* https://www.mythtv.org/wiki/RGB_Scart
	Generating CSYNC from HSYNC+VSYNC
	https://en.wikipedia.org/wiki/Component_video_sync





* For the mode7 register latches, it might be better to only latch on the HH byte write, but this would use an additional 3*6 latches, which would be too much.
	This would allow updates at any point in the scanline, with the copper. At the moment a write to the l/h/hh registers cannot happen in one pixel clock so the added value will be partially updated and used.



* Idea for new layer, scaled rotated sprites
	Setup sprite data x/y/dx/dxy/dy/dyx like mode7, plus a screen top left x/y plus width/height bounding box to iterate.
	It spits out pixels into the screen buffer and signals when it's done
		* This signal would need the ability to read values over the user port interface
	And could optionally hop into the next item in a link list... and signal the end of the link list
		the mode7 render got me thinking, because the circuitry only really differs in the "fetch a tile index from the screen memory" side of things
		So basically rendering a rotated quad outside the edges test becomes "is the X and Y tile position = 0" instead of "fetch tile index"
		If it's outside the edges then don't plot pixels
	* Could have one pixel push pipeline, that ends up writing to two RAMs, where the address is selected as the screen display (in read mode) or the write address from the calculation (in write mode)
		So 2 input 1 output selectors for the address.




* Need a simple bottom left |_ tile, then position this in the four corners with suitable H/V flips to allow the maximum pixel extent to be validated
	Then validate the border shrinks






* Need DigitalDisplay frame recording and verification of displayed frame with recorded frame.
	Pixel by pixel tests. Can display if the current frame as it is being built up matches the recording, or not.
	Highlight areas that don't match?
	
	

* Need the DigitalData model to also verify a recording against what it currently detects.
	It can also display if what it has received so far matches the recording.



* Need to update ReadMe to reflect new design




	


