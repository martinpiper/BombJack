* Output video signal with resistor ladder. Exclude from simulation once analog behavior has been verified.



* Removed duplicate component references that were causing incorrect auto router errors.



* Sheet 8 - Palette read/write logic



* Need a VSM model for a display that takes digital RGB + HSYNC + VSYNC
	https://github.com/MockbaTheBorg/VSMModel
	https://www.edaboard.com/showthread.php?188054-Creating-A-New-Component-(DLL)-For-Proteus-VSM
	http://fractale.gecif.net/si/logiciels/proteus/ProteusVSMSDK.pdf
	https://github.com/Pugnator/openvsm
	http://pugnator.github.io/openvsm/vsm__api_8c.html

	
	
* Interesting logic with _9A00CS 7R 6R 6S 5R 5S as it is only taking DB0-3 which implies a value 0-15 only. Hmm.
	Resulted in discovering new 0x9a00/0x9a01 functionality for sprite size select, documented in README.md

	
	
* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS2:EXTWANTIRQ
	This is because memory writes to 0x98xx can only be made when the video HW is not accessing the sprite regs

	
	
* At some point around here, when working on the sprites schematic,	I chose to use 2114 SRAMs instead of 6148 SRAMs for 4A/4B/4C/4D, as seen in the original schematic
	https://datasheetspdf.com/pdf-file/515019/Hitachi/HM6148HLP/1
	https://www.jameco.com/Jameco/Products/ProdDS/38957NTE.pdf
	* This change is apparent in the very first revisions of the board. This might account for the difference observed in the pull-up resistors when building and testing the boards.
	The 6148 and 2114 are pin compatible.
	The 6148 isn't available in Proteus whereas the 2114 is, which was probably the deciding factor.
	The 6148 spec does have much shorter timings compared to the "no specific manufacturer" spec for the 2114.
	




* Examine bus SREAD for the timing of sprite reads corresponding to the BH pixel clock and pixel output timing during the scan
	Done - Examine when the scan RAMs get cleared before sprite rendering
	Find out the reason for the first few bytes of what looks like odd data being written even when sprites are not at that coordinate?

	
	
* Add page 6 character screen logic
	Original schematic bug?
	2R-6 should not connect to 8C-4



* Complete page 8 pixel combination logic
	page 8 - For the 153x4 ICs D3 seems to be left to float high. Which means, for those pixels it will be floating up to the last entry in the palette.
	Added a push button to cause the D3 input to be lo or high producing a nice debug purple rendering option.
	
	
* Page 7 background picture logic done



* Inspect original PCBs and look for 74 LS/HCT types to match with where possible
	https://www.jammarcade.net/tag/bomb-jack/
	https://www.jammarcade.net/images/2019/06/Arcade-DIY-46-Bomb-Jack-pcb-repair-14-19-screenshot-768x432.png
	Indicates that M74LS174P is 8B (174x2) should suffice

	
	
* _MEWR needs to be connected to the header, might need invert?
	No need an invert, active low

	
	
* To interface with the CPU, the _9800CS and _MEWR lines can be used without any more tri-state buffering, since they are not driven by the video circuitry



* 6MHz clock needs a full can oscillator part in the schematic (disabled for simulation) and layout
	12MHz Can oscillator
	https://www.mouser.sg/ProductDetail/CTS-Electronic-Components/MXO45HS-2C-12M0000?qs=sGAEpiMZZMt8zWNA7msRCvpTgpVI8f3UwUWPm0GFK9s%3D
	Needs the signal and not signal created
	DIP-8 https://www.mouser.sg/datasheet/2/96/008-0258-0-786357.pdf
	
	12.096MHz Short crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-4X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxj6PWo6GSXrZU%3D
	https://www.mouser.sg/datasheet/2/122/hc-49usx-791.pdf
	12.096MHz Tall crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-1X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxjBlVr3Wwx1PM%3D
	https://www.mouser.sg/datasheet/2/122/hc49ux-88.pdf
	
	Added JP1 to select between crystal output from 4T pin 5 when connected, or can oscillator VIDCLK when disconnected
	R1 and R2 from schematic top left page 3 are labelled R21 R22 in Proteus schematic
	
	Same as OSCCLK for CPU project, root sheet 2
	Check original schematic for inverse signal generation, it might have some offset skew
	* Schematic sheet 3, top left, shows a 12.096MHz crystal driving a 7474 dual edge-triggered flip-flop and generating _6MHz 6MHz and .6MHz
		But in the design I used .6MHz and 6MHz as the same thing, logically they are the same
		The inverted output comes from the 74368 hex buffer inverting tristate outputs
	* Added VIDCLK signal and 3T:A and hex inverted drivers 4T
	
	Breadboard https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D

	
	
* Regarding 6MHz from 4T, the trace is very long. Perhaps this is why .6MHz was created in the original schematic?
	6N2:B root sheet 6 (6N 456 page 6 bottom middle left)

	
	
* Change screen colours to exercise the 6N2:B flow



* Perhaps move the edge connectors up the board to improve component auto place?



* Instead of using ROMs, use RAMs and add extra logic to enable their write via the external header.
	* Will need 74245
	* To free up the cartridge port, think about perhaps a non-memory mapped interface, so something via the C64 user port?
		https://www.c64-wiki.com/wiki/User_Port
			* The edge connectors have 3.96mm pitch (distance between contacts) and accept cards (PCBs) 1.57mm thick.
		https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
		https://csdb.dk/forums/?roomid=11&topicid=19759
			/PC goes low for one cycle after port B access.
		http://www.devili.iki.fi/Computers/Commodore/C64/Programmers_Reference/Chapter_6/page_359.html#User
			Looks like I can have 8 bits output with PC2 signalling when it's written
				FLAG2 as input for VSYNC (NMI trigger or poll DD0D bit 4)
				PA2 as an output bit flag
			So on PA2 this can reset the state to reading a lo/hi address, then any number of bytes to store without needing the number of bytes
				C64Docs\C64PRG10_TXT.txt
					DD00
					2      RS-232 Data Output (User Port)
					DD02       56578                 Data Direction Register - Port A
					PA2 is bit 2 of PORT A of the CIA
	* Need to find out how much RAM will be needed and decide a memory map
		All the used *.bin files (mapped into ROMs) total 64K of data.
		This means a linear 16 bit address bus model won't work as there isn't space for the RAM to be mapped.
		Instead, the ten!! ROMs can be selected with an explicit chip select register combined with an address, so 24 bits instead.
		byte:
			0		Chip select using a 74154 to map up to 16 chip groups
			1/2		Lo/hi address setup
			3		Bytes to store, address++
		Done: UserPortTo24BitAddress
			Done: U6-U9 needs to load the lo/hi address as needed, when they are selected and on the negative edge of _PC
					RCO goes to ENP&ENT
					CLK needs to cause the address to count up on the positive edge of _PC and only when U10 is being populated with CS3 low.
			* U3, U10, U18 and U19 contain the chip select, data, addr lo/hi with auto increment
			Done: EMEMWRITE will need to be low for a short tick while after the data/address are stable
				Perhaps add logic to toggle this based on a delayed flip-flop chain?
				* Actually just used the after byte tick instead
				* Added a quick debug selector and RAM, to visually display the memory can be selected and written
			Done: EXTWANTIRQ, from the _VBLANK negative edge when it starts the VBLANK will need to be sent to FLAG2 (which is negative edge triggered on the C64)
		* 74154 Obsolete!?
			74139 used instead
			74138 is also available
	* 4T on sheet 3 which creates the 6MHz/.6MHz/_6MHz signals from the input VIDCLK has OE
		This output enable could be tied to a register line to enable or disable the whole display, which would massively help with writing to any RAMs for the video data.
		This could be the higher bits of 9e00?
			Root sheet 7, 4S7 could store the extra bits if it was rewired a bit. Default is low, so no video output?
			3S+3R could also be reset on low
			* Added DB5 line for 0 = disable display and 1 = enable (DISPLAYENABLE and _DISPLAYENABLE)
				This allows large amounts of data to be written to RAM while the display is disabled without fear of contention with the display HW
	* ROMs will need RAMs, the memory setup timings will need to be honoured.
		The original RAMs can be selected as per normal and can be the first line, suitable _CSEN+_MREQ can be faked for those.
			Inverted EBS0 perhaps?
		The other lines can enable or disable the ROM->RAM segments as needed with perhaps 2-3 8K chunks memory mapped on each line
			74LS245 plus 74157
	* Done: User port (write memory) timings, need to honour the expected timings for address and data setup
		Check with the logic analyser
			EMEMWRITE might not have the correct setup timing constraints
			There should be the memory and data setup, then a delayed write pulse (low) where the data and memory is still setup afterwards
				Might be because _PC is timed wrong on the input simulated data?
					* Done: Yes, the signals need expanding a bit more to include the leadin and leadout states
					* Done: Check leadin and leadout states on CIA timing diagram with _PC and data levels
						* BombJack loads 4S7 (root sheet 7) on the positive edge (trailing edge) of _MEWR with a low _9E00CS and 7432 (OR) output
							This makes sense since it might be trying to accommodate timing issues where the data might be settling during RAM cycle timing
						* Done: So update userport design to also accommodate this
							Memory and data are primed, _MEWR is held low for a short pulse, memory and data still held
							Verified by logic analyser
	* Done: Attempt RAM replacement for Root sheet 7. Read only background picture logic
		4P7 2764 can be replaced with a 6264
			_CE will need a low to select
			CS can be high all the time
			_WE low on _MEWR
			_OE low on memory read
			To select address perhaps a 74157 with _A/B based on _ADDRCS? With _ADDRCS OR (7432) _MEWR going to _WE
			74245 needed for bus tristate?
				Or maybe a simple 74373 for tri-state outputs since we don't need read logic
				The 6116 RAM on root sheet 6 has interesting _OE/_WE based on a simple NOT 7404
		* 4P7R (RAM) replaces 4P7, BusEBS.ptn added to simulate "Root sheet 7 EBS7 EA13 RAM select"
			There are some logic contentions on BIDxx at the start, but similar CID contentions are also seen on 6LM6 RAM writes from the original schematic
			* 4P7 has been schematic and placement disabled
			* 4P7R is obviously enabled
			* Only memory from 02_p04t.bin $400 to $5ff is included in the pattern file, to reduce the data specific to the sphinx graphics
				It is $100 bytes of char data, followed by $100 bytes of colour data
	* Done: Will need a replacement for the Proteus data generators because they have a 1024 byte limit
		VSMDD2 on root sheet 1 now uses TestData.txt to set all the data needed
	* Done: Root sheet 7 8R7 using 08_r08t.bin to RAM	EBS6 EA14 RAM select	$2000
	* Done: Root sheet 7 8N7 using 07_n08t.bin to RAM	EBS6 EA15 RAM select	$4000
	* Done: Root sheet 7 8L7 using 06_l08t.bin to RAM	EBS6 EA13 RAM select	$8000
	Note all new logic for the RAMs on root sheet 7. The original ROMs are still present, just disabled from the simulation and layout.
	
	* Character data
	* Done: Root sheet 6 8K6 using 05_k08t.bin to RAM	EBS5 EA14 ram select	$2000
	* Done: Root sheet 6 8H6 using 04_h08t.bin to RAM	EBS5 EA15 ram select	$4000
	* Done: Root sheet 6 8E6 using 03_e08t.bin to RAM	EBS5 EA13 ram select	$8000
	
	* Sprite data
	* Done: Root sheet 4 7J using 14_j07b.bin to RAM	EBS4 EA13 ram select	$2000
	* Done: Root sheet 4 7L using 15_l07b.bin to RAM	EBS4 EA14 ram select	$4000
	* Done: Root sheet 4 7M using 16_m07b.bin to RAM	EBS4 EA15 ram select	$8000



* Group EBS usage for the tile/char/sprite data to EBS6/EBS5/EBS4 so that all three available 8K banks are in the same EBS



* Remove the vertical flip button and associated logic? Since it's not really needed as I'm not strictly emulating an arcade board any more.
	The layout complexity can instead be used for pixel level scrolling and the extra timing generation

	
	
* Background layer (root sheet 7) pixel fine scrolling enable?
	Could have an extra register $9e01 (l/h nybbles for x/y) that add values 0-15 to the X/Y pixel clock before addressing the background data?
		This could in effect generate a pixel scrolled background image?
	* For 6S7 and 5S7 timing
				cba9876543210 = Address at 4P7R/4P7
		_SL2	0010010100111
		4x6MHz clocks
		_SLOAD	0010110100111
		4x6MHz clocks
		_SL2	0010010101000	*
		4x6MHz clocks			*
		_SLOAD	0010110101000	*=
		4x6MHz clocks			*==	One 16x16 tile being loaded, character/tile index then colour
		_SL2	0010010101000	*=
		4x6MHz clocks			*
		_SLOAD	0010110101000	*
		4x6MHz clocks			*
		_SL2	0010010101001
	* Signals that need handling: XXH' and XXV' plus 4H, SLOAD and _SLOAD (which trace back from BIS0)
		Added new signal prefix BGH for these by copying the logic from root sheet 3
		Initial tests of the X nybble write seem to indicate success!
	* TODO: At this point, could do with a DigitalData wait for edge (for _VBLANK) and output new data code
	* X and Y pixel scroll logic added

	
	
* Need some extra logic (and control bit) to hide the gaps behind slightly contracted borders (just like the C64)
	U65 has spare two bits 6/7, if 1 then contract the Fair right and bottom borders respectively
	X & Y Border shrink works





* When running at VIDCLK 6MHz, the target speed, the sprites fail to render correctly.
	This is because Root sheet 5 4A/4B/4C/4D/ have by default 200ns address access time.
	They are 4 bit RAMs, obviously the original hardware was slightly exceeding the 166.6 ns timing from the 6MHz clock
	Verified that if the default 200ns is changed to be 100ns then the sprites start displaying again
		* It is interesting to note 8K replacement 6264 RAMs are all 100ns address access time
	They only use A0-A7 internally
	Consider using 8 bit RAMs with lower access times instead
	The next viable RAM would be: https://www.jameco.com/z/6116P-70-Major-Brands-IC-6116P-70-CMOS-SRAM-16-384-Bit-2Kx8-70-ns_242675.html
		This can be simulated and it is still able to be ordered.
	Running a 12 MHz VIDCLK with 70ns address access time results in some corrupt sprites at their correct positions
		Running with 10 MHz VIDCLK (49.2 FPS) means the sprites render correctly.
		With 50ns address access time the sprites render correctly.
		(See Root sheet 5 with 6116 RAM for sprite spans for an example)
	* TODO: Split the 2114 RAMs into two or more, based on their low address, to interleave the bit accesses
		Might have to latch the address and data to hold the address and data for longer, have 2 or 4 latches?
		This latches will need to use the low address lines to decide which chip to enable for read/write
	http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html
		Note: No address setup time
	http://www.ukvac.com/forum/bomb-jack-pcb_topic368665.html
	* TODO: Study the memory, data and WE access patterns to plan for the best strategy
		From about 1.33 seconds into the simulation will be the middle of the frame
		Note: VSMDD3 on root sheet 5 setup to record the:
			Address
			Byte
			D24 _write
			D30 0 = Output pixel data to the screen and clear to ff, 1 = reading/writing sprites
			D31 _CE
			Clock start time 1.33
		Note: 4C4DRecording.txt
		Note: The first few thousand lines were trimmed to align with the start of the d$4 phase
		d$0 indicates _CE and outputting pixels to the screen
			So the following:
				d$0100ff08
				d$01006f08
				d$00006f08
				d$0000ff08
				d$0100ff09
				d$01006f09
				d$00006f09
				d$0000ff09
			Note the address counts up, reads, then quickly writes ff, note the data is not stable during the _WE
		d$4 indicates writing sprite data
			Using TestData.txt "Top left all the same" it's possible to see the same address range 0-f repeatedly being used
			4D (ID4-7) starts to get 77...
			4C (ID0-3) still shows ff...
			So the following:
				d$4100ff00
				d$4000ff00
				d$40007f00
				d$41007f01
				d$4100ff01
				d$4000ff01
				d$40007f01
			Indicates that the RAM will consume the written data even after the 6MHz negative edge, basically when it's low
				However note that the address is stable
		Perhaps on _WE, the relevant latching address hold and write hold can hold the WE low for the relevant RAM whilst the new address switches to its read mode
		Once the address switches to read mode the WE is not held low
		* In Test2114 project, using the 10MHz VSMDD3 recording only half of the bytes are visible in the 2114s
		* Now the VSMDD3 clock is at 100MHz, now the 2114s do show both halves are written to.
			It shows there is some high-frequency interaction going on that needs study.
			Which is visible in the recordings:
				d$0000ff00
				d$0100ff00
				d$0100ff01
				and
				d$40007f00
				d$41007f00
				d$41007f01
			Note the very quick (<10ns) write address 0, then read address 0, then read address 1
		* 4C4DRecording output pixels.txt
			Been created to start with pixel output and clear
		Note however the high frequency variance in address lines:
			d$41007f01
			d$41007f03 <<<
			d$41007f02
		Probably due to 6C/6D 74163 counters displaying a non-stable ripple output
			Solved by adding U77/U78 74273 that use _VIDCLK for CLK to latch the address inputs a short time after the counters have finished
				See StableSpriteScanAddress.png
			Note the recording now shows a stable address lagging behind 21/22 lines (210/220 ns) plenty of time for the signals to settle
			Visually the output sprite pixels do seem to be a little bit better formed, more regular
			Unfortunately, this latch lag means even VIDCLK at 4MHz shows the "purple bars" corruption, due to the late arriving address compared to the data
			Without the "fix" at 4MHz the sprites display correctly.
		https://www.mouser.sg/Semiconductors/Logic-ICs/Logic-Comparators/_/N-cbost?P=1z0y33v&Keyword=74ls688&FS=True
		* Test2114
			* TODO: If _6MHz (writing) and IDA0 then use memory, memory _WE needs to be held low for longer than _6MHz, enable write latch signal, also latch data to write to memory, also U2 load address and U9 load data, and output enable U9 for cached output
			* Done: If 6MHz (reading) and IDA0 and IDA=C0A then bypass memory and output enable U9
			* TODO: If 6MHz (reading) and IDA0 and IDA!=C0A then use memory, bypass U2 and U9, select raw memory signal 74257, reset any write latch for memory and output enable select memory
		* Going back to testing the 2114 chip access timing profile:
			With the Proteus defaults then 6M is about the limit, however using 2114AL-1 values ( http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html )
				{TAA=100ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
			Then 8M is the limit (with a single pixel vertical line duplicating the background near the right hand edge)
			With 9MHz no sprite data is visible, then changing to use:
				{TAA=100ns}
				{TCE=10ns}
				{TOE=10ns}
				{TOD=10ns}
				{TWP=10ns}
				There are only some bad pixels, but hardly anything visible.
				Instead changing to use:
				{TAA=75ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are visible correctly again. It seems as though the TAA access time is what is important.
				The above takes the VIDCLK up to 10.5M. At 11M there is a purple vertical bar near the top left edge, but most sprites are still visible.
				At 11M using:
				{TAA=70ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are correct.
				At 12M some sprites display doubling or missing line corruption.
				Using this:
				{TAA=60ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are fine at 12M = 59.2 fps
				10.1M = 49.8 fps
			Back to 2MHz and all is well. Test2114 indicates that a write through caching version of a 2114 would work as a daughter board to the 2114 socket, if needed.
			The unstable addresses from the counters could be handled by more than two cached lines. In the real hardware they may cause spurious reads or writes in the RAMs.
			So for now continue to assume that modern real world 2114s are as fast as those used in the original hardware decades ago.
			The Proteus 2114 model could do with some checks to see how fast it really can write according to finely controlled timings.

			
			
* Use the DigitalData negative edge wait to add a horizontal scroll test




* Demo animation for sprite and scrolling
	TestData.txt updated to include display register updates for each frame
	cd /d C:\Work\BombJack\output
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug.gif && debug.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 384x264! debug.gif && debug.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug2.gif && debug2.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 384x264! debug2.gif && debug2.gif
		Using this option is good with 3072 x 264 in the VSMDD digital display
	For the hires schematic: c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 768x528! debug.gif
	This demonstrates horizontal and vertical pixel scrolling, using a variation on the original Bomb Jack hardware. Extra screen banks are updated into the new graphics RAM to update the tile positions. One sprite is updated too.

	
	
	
* Double check the exact input clock rate and logic with the original schematic for running at the required frame rate
	12.096MHz

	
	
* Replace the 2114s with a single 6116
	Here we have very fast memory: https://www.mouser.sg/Semiconductors/Memory-ICs/SRAM/_/N-4bzpt?P=1z0z63x&Keyword=6116&FS=True
	* Going back to testing the 2114 chip access timing profile
		With the Proteus defaults then 6M is about the limit.
	* With 6116 defaults then 8MHz is about the limit
		However 20ns access time can be found: https://www.mouser.sg/ProductDetail/IDT/6116SA20TPGI?qs=sGAEpiMZZMt9mBA6nIyysK6VW3GrAnba45Kc6Apw0Go%3D
			* https://www.mouser.sg/datasheet/2/464/IDT_6116_DST_2014115-882651.pdf
	* Using these speeds in Proteus:
		{TAA=19ns}
		{TCE=11ns}
		{TOE=10ns}
		{TOD=8ns}
		{TWP=12ns}
	* The old 2114 4A,4B,4C,4D have been disabled/excluded and replaced with two 6116 U77 U78 instead

* Auto place OK



* Using the logic analyser, measure the _VSYNC and _HSYNC timings and compare between the original at 12.096 MHz and the higher resolution version at 24.192 MHz
	A2	_HSYNC
	A3	_VSYNC
	A5	VBLANK
	Logic analyser capture on _VSYNC (A3) positive edge
	Using 2u capture resolution.
	From the original schematic:
	First A3 negative edge 16.25 mS
	Next A3 negative edge 33.02 mS
	First A5 negative edge 1.02 mS
	Next A5 positive edge 15.24 mS
	Next A5 negative edge 17.78 mS
	A5 positive edge to negative edge 2.54 mS
	A3 positive edge to A5 negative edge 1.02 mS
		A2 negative edges between 16
	A2 negative pulse length 16 us
	Negative edge A5 to negative edge A2 8 uS
	A2 positive edge to positive edge 64 uS

	
	
	
* With faster sprite RAMs being used, it might be possible to expand the horizontal resolution of the whole screen to be 512 pixels :D
	Extra bytes would be needed, $9900 or $9a00 and extra 2114 RAMs to load in parallel to the high-X pos value load per sprite
		Maybe use bit 4 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?
	Initial tests of adding an extra bit to the H values works quite well.
	At 24.192MHz then 3E and 3F need to be made faster, replace with 6116 instead?
	The timing for sprite register colours is quite tight though. Also there is going to be extra memory needed for the char screens.
	Reverted the change for now, needs more pondering.
	* First change all references to *256H* to be *512H*
	* Change *ZZZH* to *512H*
	* Then create the _512H to 512H circuit
	* And tackle the HBLANK timing test
	* Tweak background address lines to reduce the number of screen but increase the horizontal resolution using 256H/512H as appropriate
	* Add extra sprite scan address line
	* Add extra sprite registers address lines
	* Add extra byte for MSB for each sprite from $9900, to be loaded when the sprite X pos is loaded
	* 6LM6 6116 needs to be a 6264 for the AB11 and to use 256H' the lower address bits will need to be shifted up
	* Test project: Bomb Jack 512x256 test 48 sprites.pdsprj
	* Sprite and char screen logic done
	* Done: Tile screen logic, there will need to be some 256H handling to addresses as it is currently missing
	* TODO: Instead of VIDCLK = 24.192 MHz going into the 3T:A 7474, could instead use VIDCLK directly into 4T
	* Done: Sprite register 3E/3F loading address is different in hires compared to lores?
		Yes, they start at $9840 not $9820 according to the logic analyser
	* 6264
		https://www.mouser.sg/ProductDetail/Alliance-Memory/AS6C6264-55PCN?qs=sGAEpiMZZMt9mBA6nIyysDfDw0vDQxSwL3Jgh6owPVw%3D
		https://www.mouser.sg/datasheet/2/12/Alliance%20Memory_64K_AS6C6264v2.0July2017-1144693.pdf
		{TAA=55ns}
		{TCE=55ns}
		{TOE=30ns}
		{TOD=20ns}
		{TWP=45ns}
	Created 2114FAST, 6116FAST and 6264FAST to reflect timings in datasheets and empirical values for 2114
	* Done - 3E/3F could use one 6116 instead
	* TODO: There is a strange sprite colour corruption when running at VIDCLK = 24 MHz
		Output from 7E and input to 6E matches
		Output from 6M MV0-3 is sometimes out of sync
			Tried configuring very fast RAMs 7JR 7LR 7MR did not fix the issue
			TODO: Signals going into the above RAMs? Use VSMDD5
			VSMDD6 shows O0..7 is OK
			VSMDD5 shows C0..12 is sometimes wrong
				Which bits are mostly wrong?
				C0..4 are OK
				C5..8 are sometimes wrong, which?
					C5 always 0 when wrong at 24 MHz
						MD0 or 16MH? S?
							S seems to be late sometimes?
								5R or 5S late/wrong at high speed? Disable and test. Does not seem to fix the issue.
				C9..12 are sometimes late, but no wrong signals detected
	* TODO: At the moment it looks like the timing is too tight for 512x256 hires

	
	
* Update the standard resolution schematic to use 2114FAST, 6116FAST and 6264FAST
	Test with 12.096 MHz VIDCLK

	
	
* Standard resolution: 3E/3F could use one 6116 instead



* Disable 5F and the screen fills with sprite data, this obviously disables the Y pos range check.
	This could be easily configured with a sprite Y pos test register bit to allow full height sprites with repeating patterns.
	3E/3F are the sprite register RAMs, it's possible to read extra data from $9900- and an extra RAM to feed this daft idea cheaply
	Maybe use bit 5 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?

	
	
* Last plane, it's a latch for pixel colour from palette
	Can up dated during screen time by a copper
	Use similar for $01 $9e03 to store this?
	* Added U81 for BBCL0-7

	
	
* 4 bit adds for tile plane ($9e02)
	The demo has been updated to use this instead of duplicating the screen data in different banks with a shift

	
	
	
* There is also the possibility to allow the horizontal pixel clock and/or the vertical raster position to be read via a latch and suitable address chip enable logic of an 8 bit latch
	* Alternatively, have a "copper" mode on the interface logic board?
	* To test this, the digital data part can be expanded to accept more inputs for RH and RV, no need for _HSYNC with this remapping model
	* Done: Need wait for X/Y pos in DigitalData, added some test data patterns for copper bars and split sprites

	
	
* To get multiplexed sprites working, the sprite logic seems to need to be disabled to avoid spurious data bus reads
	Or the data bus writes need to be precisely timed, with a proper copper, to coincide with periods where the sprite registers are not being read
	See: TODO: While this works, it needs a proper copper



* Alternatively, have a "copper" mode on the interface logic board?
	* The mapping of the RH and RH values and CLK to a header could allow RAM to output defined signals to the ED, EA, EBS output.
		The RH values could be divided down to only trigger during _HSYNC for example
		Or it should be possible to program a "mapping" memory for RH and RV, that defines when/how the real "copper" memory can be accessed.
			This could translate into addresses that are logically ORed into a final lookup address into the copper.
		This could be selected by a particular EBS mode, perhaps even the idle 0x00 or maybe the 0x02 mode?
		Setup of this memory will have to be done during the _VBLANK to avoid visible artefacts, writing takes priority.
		* TODO: Idle EBS mode would be good, the user port interface can be tweaked to disable all outputs to DB/AB/EBS etc when EBS == 0
		* TODO: Digital data would need an output disable mode for certain pins, the copper could then be added as real extra logic from the main board
			* EBS would obvious need to be maintained as output with 0 to stop the whole board chip groups being selected at once
			* Or to emulate, the DigitalData could have an extended output value command that accepts override data setup and _MEWR timings
		Old DigitalData clock=500k
			TOLOW=0.00000025
			TOHI=0.0000005
		Now using clock=2M
			TOLOW=0.000000125
			TOHI=0.00000025
		* Note: At 2M the sprite multiplex split is very small and does not interfere much with the video output
			* This means it might still be possible to emulate and find safe spots for the sprite register writes, needs experimentation
			* There are no safe spots, the sprite RAM is constantly read during the scan frame
				$9a00 Upper nybble: $10 = Enable sprite output (6S SPREN), works by resetting the contents of the sprite shifts on low
			* Success! Examining the rendered output the tall stretched sprites not yet updated are visible without artefacts

			
			
* Investigate latched writes to the background colour. It's not entirely stable if the copper bars move up and down?!
	* A double write to "d$9e0301XX" seems to fix the issue? Is this because the address should be maintained, not incremented?
		Or is it the horizontal timing position that is just right?
	* Perhaps, a second sprite register RAM can be used, while one is being read the other can be written to?
		Perhaps not, it would need quite a bit of extra logic to isolate the DB and AB
	* Fixed a bug in DigitalData where waiting for an input value caused the first value to be skipped
	* Double writes removed from the data generator, the display still renders correctly


	
	
* Introduce extra colours bars.
	TODO: Some of the frames show some colour bar sparkles visible on the left of the screen in the blue area of the scrolling top screen?
		Why? How?
		Shifting the first colour change on the left over 32 pixels seems to have vastly reduced, but not entirely removed the problem.
		Might it be one of the colours from the last or first segment? It seems to move with the bars?
		* Test a full run without auto-increment addresses during the colour bars
			Sparkles still happen.
		* Try using this for the first colour bar position: file << "001000" << std::endl;
			With d$9e000120	; Disable the tile screen
			With the DigitalData clock input = 2MHz this shows how interaction with the 12.096MHz video clock introduces some timing variance on the left vertical bar
				Changed the clock to be the Q2 (divide by 8) output from a 74161 and VIDCLK clk input
				This fixes the timing variance on the left colour bar
				TestTileDisableRapidColours.txt indicates this equates to colour changes at precisely every 4 pixels, as expected.
					Useful data for a hardware copper...
		* Using the Q1 (divide by 4) output from the 74161 and the display demo is stable, and rapid colour writes are now at 2 pixels resolution
			Also very useful data for a hardware copper
		* Try running with this new clock input
			Up to frame 275 it all looks clear!
			All frames look clear.


			
			
* 7483 no longer made? Change to 74283 with different pinout.



* GenerateData2
	Add a simple (naive) multiplexor test using WaitForRaster() to then reset the sprite used back to the first if there is enough gap



* Board separation preparation work
	* Need to rationalise and reduce the memory decode logic single pin nets (Design Explorer root sheet 10)
		_WRAM0
		_WRAM1
		_ROM0-4
		_RAM0-1
		WAIT
		_8800CS
		_8C00CS
		Above all removed
	* Using Design Explorer->Net->Type: Single Pin Class: SIGNAL, these are all in need of checking
		BBCL7	Last colour of the "background" colour, U82, part of the tiles board, root sheet 7
				Since this feeds directly into the pixel combinatory logic, then removing the chip would allow the "background" to be set by a mode7 layer etc
		BGHSS	Root sheet 7, it comes from the updated SS related logic from root sheet 3 (for SL1, SL2, SW etc) that generates the background tiles signals with the X/Y scroll values
				SS is used by the character screen, not the tiles, so it is really unused. Removed.
		HBL		Unused, root sheet 3, removed. Not useful like the _HSYNC and _VSYNC, since the copper can read RH0-8 and RV0-7
		ISAB7	Root sheet 4, sprite logic, last unused pixel colour
		_BGHSL1	Unused by the tiles, same as BGHSS origins, from the tiles x/y pixel scroll update. Removed.
		_BGHSW	Unused, same origins as BGHSS and _BGHSL1. Removed.
		_SW		Root sheet 3, unused. Removed.
	* Created _EXTCS8000-B800 lines which can be moved to a header from the main "Video gen, pixel clock timing, final mixing output" board
		Created header INRAMSEL1
		Note: _9000CS renamed to _EXTCS9000
		* _EXTCS9800 logic that decodes the _9800CS, _9A00CS, _9C00CS, _9E00CS duplicated on each board that uses these
			_9800CS root sheet 40	(Sprites)			U86:A
			_9A00CS root sheet 30	(Sprite size logic)	U88:A
			_9C00CS root sheet 80	(Palette)			U87:A
			_9E00CS root sheet 70	(Tiles)				U88:A
	* Merge _CSEN and _MREQ and remove
	* Sprite size logic now moved to root sheet 40

	
	
* Part 7N Outputs... Moved to sheet 50 and and split to sheet 80 (U33)
		_256H*.		Sheet 50
		256H*.		Sheet 50
		1V*.		Sheet 50
		_1V*.		Sheet 50
		_CMPBLK*.	Sheet 80

* SS from sheet 3 1T output 11 was wrong, the 1T 13 input was only connected to 1S 2 input and not connected to 2T 4 output
	SS			Moved to Chars board sheet 60
	_SL1		Moved to Chars board sheet 60
	_SL2		Moved to Chars board sheet 60

	
	
* Board connectors
	https://sg.rs-online.com/web/c/connectors/pcb-connectors/idc-connectors/
	https://sg.rs-online.com/web/c/cables-wires/ribbon-flat-cable/flat-ribbon-cable/
	Perhaps it's going to be better to split the boards into video generation and combination logic, char screen, tiles, sprites and mode 7?
		Video gen, pixel clock timing, final mixing output
			This needs a header for each pixel for the mixer
		Chars
		Sprites
		Tiles
		Mode7
	* Use the following properties, which can also be set as "Group" in the Design Explorer
		{GROUP=Video}
		{GROUP=Chars}
		{GROUP=Sprites}
		{GROUP=Tiles}
		{GROUP=Mode7}
	* Figure out how these signals need to be exposed:
		Done
			SLOAD
			_SLOAD
			CMPBLK
			_CMPBLK
			_MDL
			_CDL
			_VPL
			_256H
			BGBORDERX
			BGBORDERY
			DISPLAYENABLE
			_DISPLAYENABLE
		TODO
		No need (internal to a single board, or all on headers already)
			_VBLANK
			_MEWR
			16HSPR



* Automatic detection of missing routing across board boundaries and filtering with a known list of header points
	It should be possible to parse the IPC file and the Pre-Production Check output
	IPC example lines:
		P  NNAME00002 D0.00002
		P  NNAME00035 D0.00035
		317NNAME00002       U1    -2   MD0762PA00X-090170Y+007620X1270          S0
		317NNAME00035       U2    -2   MD0762PA00X+012700Y-001270X1270          S0
	Pre-Production Check lines:
		Missing connection: U1:2, U2:2
	Steps:
		Parse the NNAME00002 and NNAME00035 from "U1:2", "U2:2" mapping to "U1    -2" and "U2    -2"
		Resolve the NNAME00002 and NNAME00035 to "D0.00002" and "D0.00035", note common prefix
	CheckConnectivity tool
	// "C:\temp\Proteus\test multi board.IPC" "C:\temp\Proteus\Pre-Production check.txt"
	// "C:\Work\BombJack\V3.0\Bomb Jack.IPC" "C:\work\BombJack\V3.0\Pre-Production Check.txt" "C:\Work\BombJack\HeaderNets.txt"
	Using the V3.0 files, deliberately creating an "EEK" net with components across two boards, I see:
		Final report
		EEK                  From: U99:1,U98:6
	So it works well, even the component pins are correct.


	
	
* Move the "background colour" logic and latch to the video generator layer?
	This might allow the mode 7 layer to be added as well?
	* An extra layer can use the LAYER 4 header, which is pixel 4 (background colour) from the tiles board.
	
	
* Check the layer memory select logic, mostly layers should not need a full header but instead have select lines for their video RAM etc.
	* For now, the full headers can be retained, they supply a good consistent connection point that can be stacked, or ribbon cable connected
	* If needed for extra flexibility the EBS[0..7] lines can be connected with individual wires to allow other layers to be added at different addresses.

	
	
	
	
* Connect the last palette line giving more colours?
	6A2, 6B2, 6C2 do have A9 free, so it can be used for an expanded palette
	5E2 has some interesting logic with pin 3 (D0) being _CMPBLK*. and then the D0 output going to MR, but why is this needed?
		It seems overly complex to me, perhaps it's related to edge of screen pixel clearing logic?
		But we already have 7A2 8B2 using ENABLEPIXELS as MR?
			This does however only kick in when the borders have been shrunk, for scrolling for example
		* The _CMPBLK*. logic is there to turn off pixels at the screen edges, otherwise we get horizontal overscan screen tiles being rendered.
			Note, the tiles are rendered using incorrect memory locations
			This is used when the border shrink X/Y bits are not enabled.
		* TODO: Investigate if the _CMPBLK*. logic can instead feed into ENABLEPIXELS, freeing 5E2 pin 3 (D0)
			_CMPBLK*. goes high at HV$8 and low at HV$188 indicating (again) the pixel output logic is shifted 8 pixels
			* U67:A now combines the VBLANK, border shrinks and _CMPBLK*. and frees the line on the 5E2
			* Extra colour logic all connected
			* Tools updated to handle 32 palettes of 8 colours each



* Mode 7 display from DigitalDisplay\TestJig\Design7.pdsprj
	For the memory address space decoding to latch load signals, it could use similar logic to that observed in U70, U66
	As long as the data is read on a positive edge
	* Perhaps the background colour logic can feed into the combination board?
	* Initial logic and test data with ROMs added, it seems to be working quite well
	* Done: Added some generated dx and dy delta values, it doesn't quite rotate all the way around, probably to do with the wrong dy being used. Check the animation...
		Note: "; Trying rotates" in BombJack\TestData.txt which demonstrates the four quadrants
			At least I've figured out what register values result in 0/90/180/270 rotations now
			Note working calculations for intValue in BombJack\GenerateData\GenerateData.cpp
	* Done: Need to test for empty pixel $00 and replace it with the background colour
		Use the same address as the tile? This will need slightly more logic, but will retain compatibility with existing data
		Or just use a new address? The generated data will need updating.
		* Used new address $a01401
	* Choose between 32 16x16 or 128 8x8 tiles?
		Depending on logic constraints, it might be possible to select the relevant RAMs simply
	* Add extra map select coordinates, extra 4 or perhaps 8 bits, make the map wider
	* Add offset l/h/hh loads for x/y origin values
		Added "LDXORGL/H" note "; Trying mode7 xorg writes" seems to work
		Added "LDYORGL/H" note "; Trying mode7 yorg writes" seems to work
		74HC138 used
			Addresses spaced out allowing HH value to be used later
			Now allows a 128x64 tile screen, uses 8192 bytes
		* Done: Sheet 10 needs three more interleaved graphics fetches
	* Done: Add extra logic to use RAMs not ROMs

	
	
* Mode7 pixel calculate and output was reduced from 4 to 2 stages. Significantly reducing the complexity.



* Mode7, root sheet 10: Need to add pixel output header and common pixels/signals/address/data bus inputs headers




* Make boards top silk text V3.0



* Connectivity check shows missing:
	_HSYNC               From: J1:1,U181:1
	_VSYNC               From: J1:2,U120:1
	* Add to video headers

	
	
* Using the same x/y flip inverter trick for the mode7 tile lookup, it might be possible to add support for these in the map
	Especially now since the output pixel complexity has been reduced and there are 32 tiles

	
	
* Where 6264FAST is used, the _OE = NOT _WE is not good. the _OE should be a NOT of the NAND EBD, EA instead
	Very strange timing contention issue when two 6264FAST are on the same output regarding _OE
	* Update 6264FAST _OE _WE logic to improve write stability timing

	
	
* Also check 6116FAST _WE _OE timing
	Simplified _MERD logic, by removing it entirely. We do not want to read any internal RAMs, only writing is needed.
	Far fewer logic contentions now

	
	
	
* Logic contentions remaining:
	Caused by the palette RAM read/write switch
	Contention state CSF on net ED0.
	$ILOGIC ANALYSER#0109(B20) =>  FF
	2F_U2(B7) =>  FF
	3L6_U2(A0) =>  FF
	7B2_U2(B0) =>  SH
	7C2_U2(B0) =>  FF
	VSMDD2(D0) =>  SL
	Contention state CSF on net ED1.
	$ILOGIC ANALYSER#0109(B21) =>  FF
	2F_U2(B6) =>  FF
	3L6_U2(A1) =>  FF
	7B2_U2(B1) =>  SH
	7C2_U2(B1) =>  FF
	VSMDD2(D1) =>  SL
	Contention state CSF on net ED2.
	$ILOGIC ANALYSER#0109(B22) =>  FF
	2F_U2(B5) =>  FF
	3L6_U2(A2) =>  FF
	7B2_U2(B2) =>  SH
	7C2_U2(B2) =>  FF
	VSMDD2(D2) =>  SL
	Contention state CSF on net ED3.
	$ILOGIC ANALYSER#0109(B23) =>  FF
	2F_U2(B4) =>  FF
	3L6_U2(A3) =>  FF
	7B2_U2(B3) =>  SH
	7C2_U2(B3) =>  FF
	VSMDD2(D3) =>  SL
	Contention state CSF on net ED4.
	$ILOGIC ANALYSER#0109(B24) =>  FF
	2F_U2(B3) =>  FF
	3L6_U2(A4) =>  FF
	7B2_U2(B4) =>  SH
	VSMDD2(D4) =>  SL
	Contention state CSF on net ED5.
	$ILOGIC ANALYSER#0109(B25) =>  FF
	2F_U2(B2) =>  FF
	3L6_U2(A5) =>  FF
	7B2_U2(B5) =>  SH
	VSMDD2(D5) =>  SL
	Contention state CSF on net ED6.
	$ILOGIC ANALYSER#0109(B26) =>  FF
	2F_U2(B1) =>  FF
	3L6_U2(A6) =>  FF
	7B2_U2(B6) =>  SH
	VSMDD2(D6) =>  SL
	Contention state CSF on net ED7.
	$ILOGIC ANALYSER#0109(B27) =>  FF
	2F_U2(B0) =>  FF
	3L6_U2(A7) =>  FF
	7B2_U2(B7) =>  SH
	VSMDD2(D7) =>  SL



* How about lo/hi registers for tile background char address offset to enable hardware scrolling?
	Added, but the left border needed to be brought in by 4 pixels

	
* Can the right border be pushed out by 4 pixels?
	Yes!

	
	
* Removed old redundant ROMs




* Mode7 tiles to 64 instead of 32? Would need more RAMs
	The write logic works, but the output logic has contentions. Going to need a 2 to 1 selector 74157... Tried 6MHz strobing the _OE, no better.
	* Is this causing the output pixel corruption visible when the line has >= 32 tile index present?
	* Hmm no, a selector 74157 on >=32 tile index, did not work either. So it doesn't look like an output from RAM data hold issue?
	So what could it be? Mathematical?
		Not mathematical, one of the tile RAMs on the second pixel phase was in contention with the other tile RAM, even though _CE is exclusive
		The contention value was being read by the output latch
		So separated the two input ED0..7 bus inputs with an extra 74373

		
		
* Align the 3 bus headers in the video cards with UserPortTo24BitAddress.pdsprj



* UserPort: On reset of the state clear all output values to zero instead of needing to send 0 bytes to clear them all. See reset24BitBus
	Use bus write pulse to zero output when not active

	
	
* Twiddle the mode7 HV flips to align them with tiles




* It springs to mind that I should perhaps hook this up to a 6502 emulator with a "realtime" emulated display to help prototype games/demos.
	* Display container
	* Write data method, calls write data events in layers
	* Calculate pixel method, at current H/V position, advances to each pixel
		* Takes VBLANK and border shrink into account
	* Maintains the image X/Y, which are different to H/V
	* Add layers
		* Write data event
			* Can set a bus contention timer (in pixels) to allow simulation of display artefacts
		* Get pixel index event includes H/V display registers
	* Mode7, tiles and chars tests work well: https://twitter.com/MartinPiper/status/1251190688173027328
		Code: https://github.com/martinpiper/BDD6502/commit/061eaa68c0dedacdcd5d0586308e5bffdee34ec8

		
		
* Spot common section in the output music events file and add a new command to "gosub" to a start/end offset section
	First test run: saving=41620
	This is based on byte stream data compression, it isn't taking into account the command lengths
		This means the buffer will need shuffling around when a match is found to enable the next searches to use real in memory data including the new compressed chunked
		The buffer will also need to be pre-scanned to find a suitable escape byte
		* With all the above: saving=37059
			The reduced saving is expected due to some of the duplicated existing data being detected has been removed
			There are 5 levels of recursion here
		* With escapeByte handling: saving=36898
	* Single pass savings: saving=24686
		Multiple pass decompression is going to be hard in 6502 with limited RAM
		With escapeByte detection: saving=24693

		
		
		
* Audio board - Audio.pdsprj
	* BDD6502\src\main\java\com\bdd6502\AudioExpansion.java
	* Target 4 voices, for one channel output, 
	The 8K sample RAM can be populated using the output from C64\VideoHardware\target\debugData.txt
		* Done - Needs expansion to the full 64K
	* Audio registers, latches, are needed
		Starting to connect voice 0, the latches so far read the correct values
		All voice 0 latches work, loop mask and active mask also work
	* voiceInternalCounter[voice] += voiceRate[voice];
		with V0ST_ADDCOUNTER phase
	* voiceInternalCounter clear on voice inactive
	* TODO - voiceInternalChooseLoop will need the result of length comparison
	* HW: Note selective reset of only some adders when length is reached
	* Can use data: ..\C64\VideoHardware\target\debugData.txt
	* Or TestAudio1.txt
	* For comparison: http://www.ti.com/lit/ds/symlink/sn54s85.pdf?ts=1591365901295
		Comparison output works
		Now needs to process the result comparison at the appropriate time, after the output has a chance to be stable
			V0INTCOMPARELOOP latch works
			Need a suitable input to the counter latches
				V0ST_COMPARELENGTH	| VOICEACTIVEMASK0	| V0COMPISGE	| output
				0					| 0					| 0				| 0
				0					| 0					| 1				| 0
				0					| 1					| 0				| 1
				0					| 1					| 1				| 1
				1					| 0					| 0				| 0
				1					| 0					| 1				| 0
				1					| 1					| 0				| 1
				1					| 1					| 1				| 0
			https://www.dcode.fr/boolean-expressions-calculator
				Using: (!a && b && !c) || (!a && b && c) || (a && b && !c)
				Gives: (NOT a AND b) OR (b AND NOT c)
			Using the result in: https://www.dcode.fr/boolean-truth-table
				Matches my intended truth table
			Using digital data recording mode, output\DebugAudio.txt, with read on RAM read state, shows the counter values correctly counting

		Done - Need voicesActiveMask reset logic based on not looping
				V0ST_COMPARELENGTH	| _V0RESETCOUNTER	| VOICELOOPMASK0	| output
				0					| 0					| 0					| 1
				0					| 0					| 1					| 1
				0					| 1					| 0					| 1
				0					| 1					| 1					| 1
				1					| 0					| 0					| 0
				1					| 0					| 1					| 1
				1					| 1					| 0					| 1
				1					| 1					| 1					| 1
			(!a && !b && !c) || (!a && !b && c) || (!a && b && !c) || (!a && b && c) || (a && !b && c) || (a && b && !c) || (a && b && c)
			NOT a OR b OR c

		Done - Need address or loop address add to counter and memory read states
			V0ST_OUTPUTADDR
			V0ST_READRAM
			Created common adders for:
				COMMONADDRESS0..15
				COMMONPOSITION0..15
				COMMONREADADDRESS0..15
			TODO: Read debug and logic analyser indicates an incorrect value read for AUDA=4
				Perhaps the setup address time is not long enough?
				But reducing AUDCLK results in the RAMs not being written?!!
				d$00230002
				d$01c00003
			>>>>	d$01080004	Should be 0xff but reading 0x08???
				d$01730005
				d$01004020
			Why? With SAMP8 enabled in the simulation the RAM fails to write and read properly
				74245 is needed to isolate each RAM, it fixes the incorrect read
				The _OE,_WE, _CE is connected, just like all other RAMs for their respective banks
				_OE period has been reduced to only the time for address setup and read result
				_CE period has been reduced to only the time for address setup and read result, or EBS2 request time
				* This has fixed SAMP8 write issues and SAMPD read issues
					d$01230002
					d$01c00003
					d$01ff0004
					d$01730005
					d$01014020
					d$01024021
					d$01034022
					d$01014020
					d$01024021
					d$01034022

		* Done - Need to remove all unique voice internal terminals and group all unique voice input/output terminals for easier update

		Done - Need volume calculation, could be part of the common sample read module with a large EPROM
			This can simply cascade into the final output
			COMMONVOLUME0..7 created
			
		
		Done - And if not voice active then just output 0x80
			This could use the common logic from _VO_ADDRCNTOUT, when there is no RAM chip enabled at U1 (connected to _VO_ADDRCNTOUT and U52:C)
				This enables uses a latch and selector for the value to load into the final output after the volume calculation
				This uses AUDOE to combine detection for the sample RAM being written to and mutes the output when this happens

		
		* Done - Need to create other voices

		Done - And latch output of sample once for all four voices?
			Added extra step V0ST_OUTPUTADDR2 to allow V0ST_READRAM to be used for +ve edge trigger
			Cascade adders for sample?
			Then final output latch or 0xff read on carry detection for values > 0xff
			* At the end of a sample, without loop, does the MOD file player output a 0x80 or the last sample read?
			
		
		* Done - VOICELOOPMASK0 all of them, need to be moved to the left and connected
		

		* Check output data by using VideoHardware demo file and decoding the result for left and right channels
			* Use ffplay with u8 raw sample input
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 0 4
			"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 31250 c:\temp\t.bin
				Initial check seems to be OK, the pitch might be off, need to adjust for the final frequency


		
		* Done - The final output frequency from the hardware needs to be calculated and adjusted in the MOD converter
			The input clock rate for the crystal/oscillator will play a part here
			As will the final position of LOADOUTPUT which also resets the counters
				https://www.unitjuggler.com/convert-frequency-from-%C2%B5s(p)-to-Hz.html?val=40
				25000 Hz
					C:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\ffmpeg.exe -i "C:\Users\Martin Piper\Downloads\Digital Leisure\Dragon's Lair\VIDEO_TS\VTS_06_1.VOB" -y -acodec pcm_u8 -ar 25000 -ac 1 c:\temp\sample.wav
					Then trim the WAV header and make it 65536 bytes long for testdata\sample.pcmu8
				IntelliJ run config "TestRunner --exportmod (2)" used and "target\" music data files copied to testdata
				C64\VideoHardware\BuiltIt.bat also works


* When listening to the audio simulation output
	Simulation to use: C:\Work\C64\VideoHardware\target\debugData.txt
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\temp\t.bin
	Compared to the emulation debug output:
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\work\C64\VideoHardware\target\debugchannel.pcmu8

	The pitch seems to be off, perhaps there is a fault with the looping?
		Try one voice in simulation first
		
	* Or perhaps test the output from run configuration: TestRunner TestVideoHardware.feature
		Simulation to use: C:\Work\BDD6502\target\debugData.txt
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 C:\Work\BDD6502\target\debugchannel.pcmu8
		After editing: C:\Work\BDD6502\target\debugData.txt
			To find d$802c0100 and remove previous video writes, leaving the data writes intact
		The simulation pitch seems to be OK, but the audio is not entirely clean as expected
		Listening to the debug data from the channel pre-combination stage:
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudio.txt c:\temp\t.bin 3 4
			The audio also seems to not be clean, but of the correct pitch
	Indeed the DebugAudio.txt indicates incorrect memory address reads that are not entirely in sequence:
		d$00ff7d7d
		d$01008080
		>>> d$08017474
		d$01028383
		>>> d$08037171
		d$01048282
	AUDA breakpoint on 0x100
		Found: U34->U41 are inverted, whoops
		DebugAudio.txt indicates correct sequence now
		Correct audio plays now, sounds clean
	VideoHardware demo smoke test feature was also missing: And enable video display bus debug output
		So the debug output was a month old, not using the new rate->frequency conversion
	Need to test with new data
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 0 4
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\temp\t.bin
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 C:\Work\C64\VideoHardware\target\debugchannel.pcmu8
	Sounds cleaner, but the pitch/address/loop still seems to be off still?
		Higher rates sound worse?
		* It looks like the "COMMONPOSITION" comparison lines are slightly wrong going into the comparators 7485s
			Sounds better now


			
			
			
* Master latch for mode7 regs?
	Plus independent x y counter reset? Which could actually be used to hold the counter low for interesting effects
	This would allow the copper to update in one pixel all the parameters and allow interesting effects where sections of the screen can be changed independently
	Try in emulation first
		Emulation looks good
	* Done - Extend to make all the MR lines independent, do not affect the clock lines
		reg	MR		tick
		x	_HSYNC	6MHz
		xy	_VSYNC	_HSYNC
		y	_VSYNC	_HSYNC
		yx	_HSYNC	6MHz
		Added handleRegisterFlags();
	* Done - Generate data (both of them) needs updating write: 0xa015=0x1f
	* Done - Hardware schematic needs to include extra logic for _HSYNC and _VSYNC based on flags
		Checked with test data
	* Done - Check extra AND gate IC usage and board group in Mode7
	* Check auto-place and route board size
	* Done - 6502 driver code needs write: 0xa015=0x1f
	* Done - Feature files need updating too

	
* Test: For audio playback of the audio simulation output:
	For: C64\VideoHardware\features\smoke test.feature
		@Demo1
		Enable: And enable video display bus debug output
	For: C64\VideoHardware\asm\main.a
		Disable: IncludeGraphicsData = 1
	Run C:\Work\C64\VideoHardware\BuildIt.bat
		The digital data input uses the output debug bus data from the above demo
	Then use:
		cd /d C:\Work\BombJack
		AudioPlay.bat
	
	
	
* Audio - Consider sub-circuit mode for all other voices
	voice 0 starts, then at 7.7+ seconds voice 2 is active
	Root sheet 4 (voice0) schematic note:
		Copy this entire schematic to the first sub-circuit sheet.
		The sub-circuits are located on the next sheet.
	The sub-circuits are connected using voice 0 labels, the four channel output has been checked.
		Auto place and auto route checked
		
		
		
		
* At the moment the video and audio output uses a 2N-net resistor arrangement, but this can be inaccurate.
	https://hackaday.com/2015/11/05/logic-noise-digital-to-analog-with-an-r-2r-dac/
	Consider using a 2N-net arrangement: https://elinux.org/images/e/eb/Howtocolor.pdf
		Page 16 gives a good example
		Page 20 advises a pot for the audio volume
		Page 21 discusses SCART, but a composite signal, we want RGB
	https://www.retrorgb.com/csync.html discusses TTL sync and 330-450 ohm resistor
	https://en.wikipedia.org/wiki/SCART SCART lines are 75 ohms
	https://www.epanorama.net/faq/vga2rgb/scart.html also useful reference
	* Note example: TTL to SCART resistor ladder.pdsprj
	* Audio layout done
	* Video layout done, added proper output connectors
	* Analogue components are disabled in the simulations
	



* Building V3.0 video and char screen boards
	3 October 2020




* Are sheet 4 sprites 4E/4F really needed?
	They do bolster signals going to the internals of the sprite board: 5E 5F 6E 6F
	As well as somewhat isolating flow of sprite RAM read/write logic side of the board
	* Temporarily disabled 4E 4F and removed from placement. Wires connecting input to output added.
		TestData.txt and TestData2.txt seems to generate correct sprite animations




* For the sprite scan RAMs, while leaving the 2114s disabled in the simulation, add them back into the PCB layout
	This gives the option of using the single 6116 RAM, or two 2114s instead simply by populating the relevant sockets
	Also verify the value of the pull-up resistors
	Added 4A 4B 4C 4D with {GROUP=Sprites} to the sprites board
	** Done - Auto place and route needs testing
		Sprite board generated in V3.0 folder



* Rotated the memory bus and video headers in the schematic to match the PCB orientation



* Some of the 7432 components were using the wrong size package, don't know how that happened.
	Checked all other components for inconsistent sized packages
	U91 on the chars board was wrong, for example.
	Also the 6116FAST (chosen in the mouser.sg link) uses a narrow IC package, not a wide package. *Sigh*



* C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus.osp
	Is the OpenShot Video Editor project file for: C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus final.mp4
		https://www.openshot.org/download/
	the file looks like json format.
	To be honest, it's a little slow while using the editor. But it eventually let me assemble the various input files and produce a single video.
		However I noticed that during video export, around the 8 minute mark, it would produce corrupt video files *sigh*
	This can be used to increase the volume of a whole video file: "C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffmpeg.exe" -i "C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus final.mp4" -filter:a "volume=2.0" "C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus final louder.mp4"
	
	Links:
		The main project page with dev logs and downloads: https://martin-piper.itch.io/bomb-jack-display-hardware
		Proteus simulation and PCB design: https://www.labcenter.com/
		Xinweike PCB manufacture: http://www.xinweikedz.com/




* Done - Check "user port" orientation for UserPortBreakout.pdsprj and UserPortTo24BitAddress.pdsprj
	Avoid cable twists, remember component side is facing away from the computer *towards* the expansion board
	Added power planes, both GND




* Check vsync logic
	TODO - On the C64 it may signal the NMI only once on the edge *and* reset the CPU read signal once after it has been read (the read acknowledges it).
		Simulation checked: EXTWANTIRQ = _VBLANK which triggers on the negative edge at raster $f0
		Checked, it is a one off event that gets reset when the memory location is read - Check the C64 strobe behaviour
		Done, improved logic to reflect hardware - Check emulated logic around device.extEXTWANTIRQ() that it reflects a one shot strobe
		Done - Video_WaitVBlank might need to be simplified to do an initial read, then wait for the single strobe, to align with the hardware
		Checked, setting EBBS = 0, waiting for VBLANK, setting EBBS=1, using some time, then setting EBBS = 0, does display expected raster line in hardware - Also Check the timing of the negative transition from the hardware with respect to the raster position




* Videos\BombJack\20201030_223915.mp4 shows the simple C64 memory bus interface working
	* BASIC test code needs a simple 8x8 character conversion routine, perhaps converting a string into bit planes sequentially line by line:
		a$="  123  4":gosub xxx
		a$="  1 3  3":gosub xxx
		... etc ...
	Where space (or 0) is transparent, and the numbers correspond to pixel colours 1-7
	* Try an assembly language wait for NMI to be read test. Should be possible to read the memory address and simply write the value to the border in a tight loop to test.
		Oh I so love not having even a simple assembler on the real C64. Since the 1541 drive is very ill and won't read my disks.
	Better demo: https://youtu.be/PXDLMjCwmgw
	* Daft idea, get the BASIC to write machine code for all of the memory writes it does, basically "compile" the output of the BASIC code. This will let me test how fast the simple memory bus is.
	* Created "BDD6502\features\TestVideoHardware Chars.a" and "BDD6502\features\TestVideoHardware Chars.feature" which uses a simple address bus and displays a static char screen using real 6502 code




* User port board is missing U2 and U24 because they are not part of the placement. These must have been unmistakably block copied with the option disabled.
	For now the following ICs will need to be moved to breadboard and their signals connected back. *Sigh*
		U13
		U12
		from pin 5 _MEWR of U24 will need to go to the top of the bus header
	* The hacky breadboard fix worked (see videos).



* Need user port board power LED





* Observed from the C64 user port, the byte output change and _PC goes low at the "same time".
	For the user port interface, U3 (the first EBBS latch) loads the byte value on the negative edge of _PC
	The positive edge of _PC is used is used to increment the state counter U1 and U22:A demux output
	But the U3 latch needs a data setup time of 20ns, which would indicate it does not fit the "at the same time" byte and _PC behaviour, so the U4:A NOR which has a 10-18 ns propagation time seems to be luckily giving just enough data setup time
	* Note: This is tested working on the C64, but it is slightly dodgy.
	* Alter the simulation data to reflect the "same time" change of the byte and the _PC signal.
		Then re-design the board such that the data setup time is definitely maintained
		* TODO: Perhaps OSCCLK could be used with a single flip-flop to buffer, and delay by one clock, the _PC signal
			Since the _PC -ve to +ve edge is 1us (1MHz) then a OSCCLK of 10MHz would be adequate. Currently the board uses 4MHz.
		These measurements explain that perhaps the introduced logic gate latency between data signal and latch is just long enough to reliably work...
			Measured from the C64 data arriving at the user port board (at 500 MHz): C:\temp\User port breakout capture 2.LPF
			The data signal is set 8ns before the -ve edge on _PC
			Measured propagation delay of the NOR _PC2 (-ve _PC to +ve CLK of U10) is 12ns
			Measured time from data signal to +ve CLK edge is 18ns
		The simulation also has 10ns propagation delay for the NOR
		* Done: The new 7474 U27 uses the user port _PC2 line (which in the renamed _PC) and outputs the real _PC. This gives a measured 130ns delay on the _PC2 to _PC transition.
			Board name now: C64 userport to 24 bit addr auto++ V1.2



* Hardware tests https://youtu.be/23YtiLoUx7U?t=850 indicated left hand pixel edge flickering issues for full screen height sprites: https://positronic-processing.slack.com/archives/C8GP4S84Q/p1608180015000600
	The SPRFULL signal makes U80 tri-state, ignoring the high nybble of the screen Y position, forcing the sprite to always be in range for output, thus making it full screen height
	The tri-state nature of the logic means it was not floating high quickly enough.
	Weak pull-up resistors (5.6k) were added to the outputs of U80, this fixed this left hand edge flickering issue. This is the same logic as the pull-up to $ff for the sprite scan RAMs




All layouts now use V3.1

* The pixel header rotations need to be consistent across the boards
	LAYER4 especially does not have the pixel and palette lines arriving in the same order as the other layers



* Char screen uses two extra lines for more chars. So only the bottom 16 palette entries can be used.
	However this SC4 allows the upper or lower palette to be used by the char screen instead.
	Current design has 0x9000 - 0x901f latching into U250, of which the lower bit is used for the lower or upper char palette bank select
		However this can be $9000 only in the future, if other character screen registers are needed





* C64 userport references
	Nice looking breakout board with reset button: https://www.tindie.com/products/syzygy_systems/c64-user-port-breakout-board-v11-syzygy-phobos/
	Just the connector: https://www.thefuturewas8bit.com/userport-connector.html
	Simple flashing LEDs example with code: https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
	Many edge connectors, need to verify board thickness and pitch: https://www.mouser.sg/Connectors/Card-Edge-Connectors/Standard-Card-Edge-Connectors/_/N-axj7dZ1yzvvqx?P=1ytcyi4Z1z0wxnn

	* Using logic analyser
	** C64UserPort.lpf shows 8_PC2 going low one cycle before data is output, then high one cycle after the data is output.
		** Checked : Check memory bus schematic expects this
	Also shows M_PA2 is able to be strobed by poke 56576,0 : poke 56576,4
		10 poke 56578,4
		20 poke 56579,255
		30 for i = 0 to 255
		40 poke 56577,i
		50 poke 56576,0 : poke 56576,4
		60 next i
		70 goto 30
	* Video_WaitVBlank hardware signals tested
	
* UserPortTo24BitAddressSimple.pdsprj is a simple user port interface, not optimal at all as it uses a 4 bit data and 4 bit control protocol just using the bottom row of the user port
	* UserPortDataSimple.ptn and UserPortSignalsSimple.ptn demonstrate the input protocol and eventual memory writes
	It does however use very few ICs and allows the C64 to precisely control (slow) write timings rather than relying on a clock and other more complex logic
		Only 8x 74LS273 and 1x 74LS138
		
		
		
* UserPortBreakout.pdsprj
	Simple breakout board for user port
	Cables and connectors:
	https://www.mouser.sg/Wire-Cable/Cable-Assemblies/Ribbon-Cables-IDC-Cables/_/N-bkree?P=1yny8w4Z1yny8w3Z1yyu1hy&Keyword=idc&FS=True
	Reduced lengths search: https://www.mouser.sg/Wire-Cable/Cable-Assemblies/Ribbon-Cables-IDC-Cables/_/N-bkreeZ1yzvvqx?P=1yyu1hyZ1yny8w4Z1yny8w3Z1z0wxp6&Keyword=idc&FS=True
	https://www.mouser.sg/Connectors/Headers-Wire-Housings/_/N-ay0lo?P=1ytkn1nZ1z0wxp6Z1z0z63x&Keyword=idc&FS=True
	Same plug manufacturer as for the the cable: https://www.mouser.sg/Samtec/Connectors/Headers-Wire-Housings/_/N-ay0lo?P=1ytkn1nZ1z0z63xZ1z0wxp6Z1z0sq61&Keyword=idc&FS=True




* Move the layer output pixel headers up (or the bus interface downwards) to avoid the upper video generation board top edge. This will make it easier to access the lower board pixel and select headers.
	Version 4.0 PCBs



* Chars layer can have an enable / disable output flag using the new latch (U250), which goes to Enable on 6F6. This logic is roughly what the tiles layer does with 5N7
	EBBS $80 and Address $4000 is now used for char screen display data, writing memory now has priority, so no need to exactly time with the vblank to get guaranteed writes
		Older hardware prioritised video reads from the RAM, instead of prioritising video writes
	EBBS $01 Address $9000 bits:
		0		Palette bank
		1		Display output: 0 = Enable  / 1 = Disable
		7-8		Screen bank 0 - 3
	TestData*.txt updated, emulation code will need to be updated with new syntax
		Version 4.0 PCB
		
		

* Chars layer extra banks, can use the U250 latch of the high address bits? Use a 6264 like the tiles layer



* Components should be placed in imperial mode
	Tidied the layout of all the boards, including some passives




* V4.0 Real hardware When Tiles X scroll & 7 = 7 then the tile fetch timing goes from and corrupt data is fetch for the tile index
	Why? Colour timing clash fetch?
	Not seen in simulation
	** Prime suspect is the tiles X pos adder delay for U63/U64/U234
		* Probably best to latch the X and Y added output for safety
		A latched value will probably mean 1 pixel delay, the border shrink will need to take this into account
	** Or maybe 6S7 with _BGHSL2 CLK load, needs to have similar logic to that seen in 5S7 with 6MHz and OR added? This should time the read pulse better?
		This is also a simpler change than latching the entire adder value
	* Use TestTileScrolls.txt to test the pixel scroll values from 0 - 63 and verify output video before and after changes
	** Chars layers also updated to add 6N2:C 6N2:D to time the _SL1 _SL2 pulses using 6MHz, which times the +ve pulse to happen about 5ns - 20ns before to 2H or BGH4 changing state
		VIDCLK could be used to bring this sooner, but it should be fine
	* Running a test, disable the new signals on chars and tiles with a bypass. Generate lots of output frames with "debugold"
		Then add the new signals back again, generate more debug frames with "debug"
		** Then use the picture comparison to check, the pixels should be the same or better
			c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -quiet -metric AE debugold00000000.bmp debug00000000.bmp -compare -format "%[distortion]" info:
			Or use this to compare the first 78 images: compareimages 78
				Which shows all zeros (followed by the file number compared)
	*** Need to test on the real hardware, remove 6S7, move to bread board, add a 7432 using 6MHz (pin 20 bottom left of Video header)
		It worked, with the code xpos&7==7 check removed. But the problem is that is same code works with the 74ls273 placed back into the socket but the boards are connected with ribbon cables. The 74273 is the same batch.
		The length of the ribbon cables might be causing the timings to "fix" themselves. The tiles video quality is noticeably reduced with vertical banding in scroll positions, with the socketed 74273, and the "fix breadboard" installed.
		It's also possible that the tiles board was not connected properly, but not that likely since the problem scroll position was 7 which is %111 (all three bits)
		** Fixed!
	*** Will need version increment for chars and tiles
		V4.1 for both now
	*** Check component layers
		Checked




* Tiles board, is there some weird timing issue when X flipped different tile indexes are adjacent? I'm seeing some wobbly pixels
	Perhaps the video board output needs to be properly latched to present a consistent stable source of RH and RV
	* Added, tested, validated sprite positions etc with emulation
	** V4.1 Video



* Why when using the 2MHz clock input to the digital data device, does ..\C64\VideoHardware\target\debugData.txt with RPG demo output fail to draw sprites on frame 33?
	compareimages.bat 34
		... all OK ...
		0         00000031
		0         00000032
		706         00000033
		744         00000034
	At 1MHz, errors fewer, but still:
		0         00000011
		91         00000012
		0         00000013
	Solved. The to low pulse was too soon after the start of the EBS asertion. This meant there wasn't enough OE cool down time before switching to WE and a logic contention was generated
	Now an external 2MHz clock and TOLOW=0.00000030 TOHI=0.00000039 can be used
	This means the APU could be setup to use a variable external clock, completely separate to the VIDCLK if needed
	* Sigh. Longer test with TestData.txt shows it's not solved, still getting sprite glitches and logic contentions
		Old VIDCLK derived values were: TOLOW=0.000000125 TOHI=0.00000025 for Q1
			But these now result in an "early trigger ignored" message from the improved data generator
			So trying slightly reduced values TOLOW=0.000000125 TOHI=0.000000225
	* Expanded the digital data model to include force hi/lo timings, as well as guard timings
		Setup to be the same as the old model, it validates exactly the same for 100 frames with TestData.txt
		Also RPG debug data up to 220 frames




* Programmable layer order selection
	Can use a few latches on the video board and selector 4-1 demuxes
	Added U263 latch and the rest of the memory address select logic
	Need to wire in the demux
	** 9900 is not a good choice, since it causes the sprite RAMs to be asserted
		Perhaps $9e08+ would be better, like the U230 in the Tiles layer, perhaps starting with _TEN9E08. Add a note to the tiles to say it has been taken by the video board.
		This has the benefit of not impacting any RAMs
	* Video layer now controls DISPLAYENABLE,_DISPLAYENABLE,BGBORDERX,BGBORDERY instead of the tiles layer. The signals are still passed through to all boards.
	* Due to the much longer path for output pixels, for the priority output select, all layers now need an extra output pixel latch on 6MHz. This means _EHSYNC, _EVSYNC, _ETVSYNC and ENABLEPIXELS are also latch delayed to compensate
	** The RPG demo can utilise this register to flip the cloud layer priority without changing the schematic
		Then in simulation - Tested
	** The bat ball demo can use this to shift the sprites behind the scrolling ship tile layer for some twinkling stars
	** BDD6502 needs updating to use this extra register in its layer combination logic
		The border and display enable flag detection can be moved out of the tiles layer
	* Need group check and version bumps on all layers




* Bit plane decoding logic, could remove the need for duplicate decoders/demultiplexers by moving the specific RAM _MEWR test and having a common test for the bit plane external RAM write test
	This would remove 6 quite large dexmux ICs for each board
	* Sprite logic works well
	* Chars logic also works
	* Tiles logic works
	* Update emulation memory address selection logic




* Add extra bit plane for each layer, change to using 16 colours for each CLUT
	The RPG demo will particularly benefit from more colours
	* The freed signal for the chars layer can then be used to address all 256 colours, not just the lower 128
	The 0 bank can be detected with a triple NAND from EA15/EA14/EA13
	* Done: BDD6502 will need to be updated to support extra colours (Turrican data test)
	* Extra pixel bitplane lines will need shifters
	* Video layer will need to to a 4 bit transparency check, not 3 bit check
	* Sprite transparency check will also need 4 input NOT and AND



* Instead of having 4 pixel headers in the video board, have one pixel input header. Then every board can have an input pixel and output pixel header instead.
	Each board can then do its own transparent pixel test and choose to pass-through the pixel or replace the pixel to its output pixel header
		The mode7 board can do an 8-bit pixel is transparent test, the other layers can use their 3-bit pixel test logic
	This would allow many more combinations of boards to be created and reduce the video board size.
	* Bad idea, the delays would kill the ability to process pixels fast enough.




* APU Bug. If a memory write to the instruction or data occurs, this causes the whole execution to pause until the next WaitForEqualsHV
	The APU, should resume instructions as soon as the writes finish (as long as it's not waiting of course)
	This is reproducible with "; Test memory access APU delay", note the RH and RV values for the first write if the memory writes are enabled
	* Actually, the U29 instruction latch is latching $ff for some reason?!
		Reason: While on LATCHINSTR state, the _INSTRSEL is hit, which resets the instructions
		Add an extra instruction latch, that only progresses the instruction if the first read was entirely OK
		Added extra latch for instruction bits 8-15




* APU Test that "kAPU_InterceptBus" is not needed before "kAPU_InterceptBus | kAPU_ExternalMEWR" due to the kAPU_ExternalMEWR being shifted later in the PCINCR cycle
	From: First rewrite 01 to MEWR breakpoint: 2.3148us	(RH 0x199 0x1a7 = 14 pixels)
	Also using "kAPU_Incr_ADDRB1 | kAPU_Incr_EADDR" instead of two instructions
	To: 1.1574us and still rewrites the correct data (RH 0x196 0x19d = 7 pixels)




* Programmable Macro Logic Device PMLD
	The end result would be to accelerate 3D polygon drawing, for example.
	A generic board with several external and internal RAMs, counters, and 8 bit registers.
	Some internal RAMs could be used as programmable ALU lookup tables etc
	Runs microcode than can trigger various latches and RAMs
	This could be an extension of the planned copper processor as it could in theory wait for horizontal and vertical pixel positions
		Then assert various values on the external memory bus, or its pixel output header
		The user port interface would need a "disable output" feature, make it tri-state
			Or this board could act as a memory/data pass-through board, where the user port memory interface is input and there is an output for the memory bus data.
				If the microcode had a default of memory pass-through mode, then during the visible portion of the screen it could take over the memory bus
				This would allow the C64 to control writes to the memory bus during the VBLANK and then the board can optionally takeover the memory bus when it needs
			Asserting the PMLD board EBS (to write its RAMs) will halt (not reset) the microcode PC clocking and processing
			It would need to pass back the VBLANK signal
	* APU.pdsprj
		On sheet 2 - EXPANSIONBUSA2, EXPANSIONBUSB2, EXPANSIONBUSC2 are all from the user port board
		All signals to be intercepted from the user port board are renamed to be prefixed with I
		Some signals can just pass straight through, so they are not renamed
		IED0..7	from the user port board eventually goes to ED0..7
		IEA0..15	from the user port board eventually goes to EA0..15
		IEBS0..7 from the user port board eventually goes to EBS0..7
		IEMEMWRITE from the user port board eventually goes to _MEWR
	* Need optional clock dividing and sync with either VIDCLK, 6MHz
	* Sheet 3
		Data bus selection logic, either pass through or intercept values
		Instruction and data memory logic
		APUPC0..12 = APU PC instruction counter
		APUDA0..12 = Current data address, also a counter but independent of the PC
	** Done: Need a recording of _VBLANK, RH0..8, RV0..7 for the signal generator that will emulate the video hardware signals
		Using VIDCLK timing
		Also perhaps the signals from VIDEO1 since they will be useful
	APU registers need to sit in EBS2 to allow an effective reset of internal state to be executed.
		If the APU is in pass through state, then all is good.
		If the APU is not in pass through state, then this will still allow the registers to be updated.
	** Perhaps instead of 8KB of 8 bit values, convert it into 1024 x (up to) 64 bit instructions from a bunch of parallel 2114s?
		This would allow the parallel microcode model instead of trying to decode quite a large instruction set
		Going to need assembler macros for this work I think
		Added 2114 RAM instead, to give INSTR0..15
		** Use the narrow 6116 instead, gives more memory for less board space. Also it's working in the sprites board scan RAMs
	* Very simple program with small loop is working: TestAPU1.a
	* Intercept bus logic
	Next need a simple wait instruction, this could reset a latch (that is usually set) pausing the the PC clock until the matching condition triggers a set latch condition
		On reset the latch needs to be set, allowing the PC clock to progress
		WaitForEqualsHV logic seems to be working
	* For the RAMs need to use the external bus, so the APU can write its own memory? Probably not needed, too much complexity
	* Read from ADDRB1 RAM and store write to external bus seems to be working
	** Done - Need wait to include X position, not just Y
	*** TestAPU1.a works so far!!! ***
	* Done - Need to check the bus sharing for RAM writes coming from an external source
		Seems to work, the initial write on $00000000 is being delayed until H$6d after the digital data debugger writes






* Video - Changing from 12.096MHz to 15MHz to enable a 320 pixel (480 scan) wide display
	output\12.096M compared to output\15M shows sprite colour issues with 15M.
		Similar was seen when attempting hires mode Done.txt: "There is a strange sprite colour corruption when running at VIDCLK = 24 MHz"
	* Perhaps this is due to ripple from the pixel counters?
		* Try adding a latch for the counter outputs
			No improvement
	* Perhaps it's the whole long pathway from U79?
		Note: Even at 15Mhz the data generator needs to use the next slower clock pulse, which kills the picture comparison test
		The sprites don't start drawing until 8 pixels delay from the first register read...
		So... Try latching the outputs from the RAMs to the internal values only when 8H is low
		However frame 1 is showing no change, since it is full frame without raster effects
			115         00000000
			0 	        00000001	<<<<<<****!!
			127         00000002
		* Fix at 15MHz! : For 7R which outputs _MDL _CDL _ VPL which latches the results of the frame, colour, vertical position
			The enable input uses 8H OR (Q output of 4S:B below)
			Visual verification of the sprites and other layers looks OK
		* TODO: Now to decide if I want the horizontal resolution to be increased...
		* TODO: Using a OR gate with both inputs tied together, check the timing on this, also test with a large number of frames at the same clock speed to decide if the improvement can be in the next revision regardless of the screen resolution
		* With original design, using TestData_DebugSprites2.txt, at 12.096M compared to 15.1M, the 15.1M clock using video with 768 as the horizontal resolution, the sprites have a gap at the right screen edge.
			The OR gate modification does not fix this issue.
			However the OR gate does not change the output at 12.096 rate when comparing 17 frames from TestData_DebugSprites2.txt
		* Using TestData.txt with 768 screen width at 12.096MHz original and with the OR gate improvement
			Frame 1 shows a small improvement in the "tall" sprite where in the original frame there is a corruption on a couple of lines where the sprite registers are updated.
				In the OR gate improved frame the corruption is removed, indicating the sprite register values are better latched in this scenario.
				Most of the frames are entirely the same however.
		* Added U54:C 7432 extra OR gate to help the sprite register load signals
		* A big change would be: Try adding 3 extra RAMs that consistently read the values and latch them with more time than trying to select all the values from the same RAM





* With the video circuitry tweaks, try a higher clock speed, note sprites
	Sprites still get that weird black drop shadow effect to the right hand edge
	Using TestData.txt with "Top left of non-rotated screen, all the same"
	The sprite scan line RAM indicates the calculated output pixels are the same, (f8 ff ... seen) which indicates the problem may be in the read or eventual output of those pixels
	Use: TestData_DebugSprites.txt
	Even the 32x32 sprites show the drop shadow effect, so the problem exists for all sprites regardless of their size
	It's not really a "drop shadow" it is actually the last trailing output pixel, when viewed from left to right in the scan line, that is black (or the wrong colour)
		The pixels are not displaced, or shifted
	At 12.096MHz execution: Breakpoint at RV=0x18 and then timed breakpoint execution for 21.5u
	Single Step Time was: 50n
		Now: 25n
	At faster MHz, use 14u timed breakpoint
	1V*. is low when RH=0x0008 and RV=0x18
	Tried a shorter scan line write pulse and longer read pulse, but this did not fix the issue The output pixel latch from the scan line RAM is still reading garbage.




* Split design into layers, use common bus for internal communications
	* Renumber component refs depending on their layer, 1xx main, 2xx screen... etc.
	* Main: Clocking, video timing, pixel combination and palette lookups
	* Screen + colour RAM
	* Sprites
	* Background picture



* TestSpriteTimings.txt
	Some sprite register timing tests, to help check multiplexor ideas with respect to writing certain registers outside of their update slots in the raster line






* APU try merging the APU with the main schematic to real bus signals?
	The headers and output signals might need some renaming
	Done - APU in schematic and test data needs EBBS changed from 0x04 to 0x02 (since the audio layer already uses 0x04 for sample data)
		Changed in readme already
	Done - Created C64\VideoHardware\asm\main3MultiplexAPU.a which exercises the expected sprite timing behaviour
	TODO - Emulation - For the clock edge related state signals, there needs to be a test for a previous inactive condition to allow for the edge to be activated
		Perhaps a debug warning when the condition is not met
	TODO - Consider another two bytes for the instruction and adding a few extra internal and external address latches, with a demux selector, and increment flags
		This would make sprites effects easier to code by having contiguous blocks of sprite registers in RAM
		However at the moment there is no "load" mechanism for the ADDRB1, it only has reset and increment
			To fully use this, there would need to be some generic read/write temporary registers as well the RAM for loads of the address
		It would also reduce the amount of reloading for the external EBS/EADDR
			kAPU_SelectEBS2EADDR2 - 1 bit for 74157 2 to 1 de-mux selecting the output of EBS/EADDR or another EBS2/EADDR2
			kAPU_Load_EBS2, kAPU_Load_EADDR2Lo, kAPU_Load_EADDR2Hi - 3 bits for load EBS2, EADDR2lo/EADDR2hi
			kAPU_Incr_EADDR2 - 1 bit for increment EADDR2lo/hi
		IDATA could have a 4 to 1 de-mux, giving RAM and 3 output 8 bit latches
			The 2 latches could also be wired for simultaneous 16 bit ADDRB1 lo/hi and perhaps PC load
				PC Load would allow for some kind of comparison and jump instruction
			kAPU_IDataSelectRAM, kAPU_IDataSelectReg0/1/2 - 2 bits for output de-mux select of RAM or DATAREG0/1/2
			kAPU_IDataRegLoad0/1/2 - 3 bits for latch loads of DATAREG0/1/2
		Extra ADDRB1 as ADDRB2
			kAPU_ADDRB2Select - 1 bit for 74157 2 to 1 de-mux selecting the output of ADDRB1 or another ADDRB2
			kAPU_Incr_ADDRB2 - 1 bit for increment ADDRB2
			kAPU_ADDRB1/2Load16 - 2 bits for ADDRB1 or ADDRB2 16 bit load from DATAREG0/1
	* Emulation works, now need to test the new instructions with the APU multiplexor test
		Done
	* Then schematic updates
		32 bit instruction read works, with latch
		Output still validates OK output\DebugAPUOutput.txt
	* Solved - Why am I seeing spurious zero memory writes at the recording digital data?
		d$00010000
		d$00010000
		d$00010000
		* The DigitalData model was interrupting with a spurious write to the last state very often. Oops!




* Need ADDRB1 lo/hi logic read, at the moment it's just reset
	Internal RAM read address





* For improved electrical performance
	Menu->Technology->Set Layer Stackup
		Inner 1 + 2 = Plane
		Other copper layers = Signal
		Create appropriate power planes on inner 1 , 2 , 4 using "Create Power Plane"
	Menu->Technology->Design Rule Manager
		Net Classes
			Power : Trace Style : POWER1
				Top/bottom + inner 4 at priority 3
			Signal : Trace Style : DEFAULT
				Top/bottom + inner4 + inner 3 + 4 at priority 1
	However, this does cause complex layers, like Mode7, to not route





* Consider reinstating 4E/4F?




* The "Sprite scan RAM logic" reads scan RAM, tests for transparency, writes sprite pixels in transparent or writes back existing value
	Perhaps change the logic so that the input sprite pixel is tested for transparency and only written if opaque?
		This would reduce the constant read, test, write back cycle to only test and optional write
		* This would mean the last sprite has priority instead of the first sprite however, i.e. the priority of sprites is reversed







* Consider higher current output than a normal 7805 regulator.
	https://www.mouser.sg/Semiconductors/Power-Management-ICs/Voltage-Regulators-Voltage-Controllers/Linear-Voltage-Regulators/_/N-5cg9g?P=1z0z63xZ1z0wadv&Keyword=7805&FS=True
	https://www.mouser.sg/ProductDetail/Texas-Instruments/UA7805CKCS?qs=IEl3ej0IqwDTl9fhEpiFdQ%3D%3D
	https://www.mouser.sg/ProductDetail/STMicroelectronics/LD1085V50?qs=%2Fha2pyFadugp3TsIEWjKyT083J8Jn3o2iWNBXzYOghY%3D
	Or buck regulator?
		https://fr.aliexpress.com/item/32726124435.html?ws_ab_test=searchweb0_0,searchweb201602_4_10065_10068_433_10000509_10000656_10136_10060_10062_10056_10055_10054_302_10059_10000636_10099_10103_10102_10096_10052_10053_10107_10050_10106_10051_10000090_10000729_10084_10083_10080_10082_10081_10110_10000375_10111_10112_10000377_10113_10114_10000349_10078_10079_10073_10000519_10070_10122_10123_10126_10000511_10124_10000514,searchweb201603_2,afswitch_1,ppcSwitch_5,single_sort_0_default&btsid=ba1207db-29e6-4f78-a993-ea479fd99bc0&algo_expid=179a1c71-1922-45a6-97fc-93dabe2447d3-0&algo_pvid=179a1c71-1922-45a6-97fc-93dabe2447d3
		https://fr.aliexpress.com/item/32689938167.html?ws_ab_test=searchweb0_0,searchweb201602_4_10065_10068_433_10000509_10000656_10136_10060_10062_10056_10055_10054_302_10059_10000636_10099_10103_10102_10096_10052_10053_10107_10050_10106_10051_10000090_10000729_10084_10083_10080_10082_10081_10110_10000375_10111_10112_10000377_10113_10114_10000349_10078_10079_10073_10000519_10070_10122_10123_10126_10000511_10124_10000514-10050,searchweb201603_2,afswitch_1,ppcSwitch_5,single_sort_0_default&btsid=466a6ab4-ecc2-442d-8954-e0821251912f&algo_expid=aa25a339-5e7a-4652-bdd2-e70b3f6ef4f2-2&algo_pvid=aa25a339-5e7a-4652-bdd2-e70b3f6ef4f2
		
	* It would help to estimate the total current used by by each board





* IC Sockets should ideally have flat pin spring connections, not round sockets.





** V3.0 needs to be regenerated
	Connectivity check passes
	These ICs were auto-placed, then horizontally and vertically gaps were added and added to the board. This promoted better auto-placement for other ICs and helped auto-routing.
		U136
		U71
		U207
		U215
		U229
		U224
	Added feature request: https://support.labcenter.com/forums/viewtopic.php?f=10&t=7821
	Note: Auto-route seems much easier when one board/group is auto-placed and routed instead of placing all the boards, then routing separately.
		Why? could be that when auto-placing all boards the layout is not as optimal.
			Comparing the force vectors between the "all board" and "single board" place shows major differences.
				Some components are pointing off board, when they should all be self contained to the group. This affects the placement.
	Note: Each board needs to be saved individually, with the other boards removed. Then place ICs by group: In PCB, components mode, use the drop-down filter, right click first component in list -> menu, "Place Group By Room"
		Then route each separate board




* Perhaps a layer combination board, which does the zero 3-bit or 8 bit pixel test and allows multiple expansion planes to be used?




* Investigate the "display enable" being used to still output video timings, just disable the pixel output
	This would allow memory updates to be enabled, without seeing bad video output and while maintaining video sync




* Auto-routing tests
	With default options, it takes ~15 minutes: https://support.labcenter.com/forums/viewtopic.php?f=5&t=7693
	Are there quicker options?
		Yes, changing the grid does help but sometimes the boards are not populated fully as they run out of space.




* VSMDD2 why is "w$ff01ff00,$3f018000" triggering near raster 2f?
	* The copper (VSMDD2) RV[0..7] input needed an extra latching 74273 (U84 excluded from PCB) to smooth the signal from the counters
		This kind of buffering logic is going to be needed on the real hardware, and might need to be added to the VSMDD2 inputs from the CLK
* Below might be related...
* Colour bars: With the sin/cos wave pattern, it seems to clamp to a bad value? Investigate the data driving this pattern...
	The horizontal and vertical pixel counters might need to be latched




* GenerateData2
	* Is the slight pixel ripple effect observed when moving right (output\debug2.gif) is the hardware or the virtual display adaptor...
	* Much higher X resolutions (like 1024 pixels) on the virtual display need to be tested...
		* Higher resolutions do show the grass an other tiles with some very thin vertical colour edge bleeding on perhaps the tile boundary
			This might be due to the colour RAM fetch not being completely synced with the tile pixel shifting and output mix?
			Or this might be caused by the horizontal and vertical pixel clocks not being latched from the counters, so the counter ripple is not quite exactly settling all at the same time?




* Copper plans
	If the hires xpos is used, then consider starting a _MEWR pulse at that point in time and any further writes would be based on that time too.
	This would allow hires writes to the background colour for example.
	Any subsequent writes could then be lower resolution to fit with RAM timing constraints.
	Could the copper board be built in-between the 24 bit parallel board and the main display board?
		Input = EBS + EAB + EDB + ROWCOL, output = EBS + EAB + EDB
			Internally EBS = 2 is used to trigger the copper and ROWCOL checks
			It could use VIDCLK and 6MHz lines from ROWCOL
	Note: The selector and RAM are used to show working memory writes in the main display board
	* It would be possible to store a 16 bit addition value, to facilitate storage of screen data that is stored in values +16 bytes at a time




* Note C5 200P capacitor, check it is a ceramic disc on the board




* Reorganise the memory map detection logic, remove 3M:A for ROMs, 3M:B 4M 5M 2S:B 1C:A
	Add new memory block detection for _9800CS, _9A00CS, _9C00CS, _9E00CS
	Use a memory block that is not used by the expansion RAM, perhaps the BASIC ROM area
	Check the CPU memory expansion, BUSDDR or CPUHASBUS can also be used to improve the memory block chip detection




* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS:EXTWANTIRQ
	Remove extra unused logic E7P:A E7P:B E6P:C 5P:A
	This will need a latch arrangement similar to the CPU latch, no use holding EXTWANTIRQ low for so long without being acked
	CPU->Root sheet 8->U250:A
		CIA1 read ACK U201:A




* Allow the _HSYNC and _VSYNC to be read via the external header, as memory mapped IO. Probably reuse the number of sprite register see _9A00CS
	This would need _MERD to be added to the external header. Also the BUSDDR would need to be used to enable the correct tri-state output
* Allow RH AND RV to be accessed via memory mapped IO




* The expansion bus and the memory write signals will need to be translated to the internal memory write signals




	
* 4C/4D when run at 6MHz will generate "sub optimal write pulses" errors with default values. Running at 1MHz fixes these issues.
	* The output pixel data seems to be better when the timing is reduced.
	* Investigate the output for read/write timings of these memory ICs for 6MHz operation.




* How many layers? Six?
	https://www.allpcb.com/6_layer_pcb.html
		Created template: All PCB Six Layer 1.58532mm.LTF
	http://referencedesigner.com/books/si/6-layer-stackup-ch6.php
	
	
* Singapore PCB fabrication:
	https://www.wizlogix.com/
	http://www.evonix.com.sg/PCBFabrication.php
	http://www.kentronicsengineering.com/
	



* All the very similar block, for the new RAMs and also the pixel shift outputs, could use a sub-circuit now
	Since they are RAM addressed and the ROM with its associated data file in the schematic is not important
	If the RAM/ROM names are still important, then have them outside of the sub-circuit



* Split this layout so that different output planes can be added or removed via internal headers, daisy-chained probably.
	The final combination logic can then take the output pixels and combine the final result via the pallet lookups





* When using TestData_DebugSprites2.txt and display width 1536, debug00000000.bmp will show at xpos 1536 for the column
	* A very slightly different incorrect red colour 240,48,48 instead of 240,0,0
		Interesting to note that the bad colour is on the leading left hand edge of the top right sprite vertical red column.
		But on the trailing right hand edge on the sprite underneath the top right sprite.
	* Larger widths show the pixel line is increasingly thin, so it is a very short signal
	* Use: TestData_DebugSignalSkew.txt
		Interesting, with "Setup grey background colour in the palette" the incorrect colour pixel is at x=1330 y=17, fire first correct red pixel is at x=1331
		Using the first correct red pixel is at x=1331 and the x=1330 pixel is 240,128,128, so the colour has changed
		* Added logic analyser to the FPR/G/B0-3 pixel outputs, it looks like the simulation software is emulating a "random" signal variation in the two output pixel hex latches 74LS174
			Changing to three separate latches and the pattern is the same
			Maybe it is simulating the time taken to transition from lo to hi or hi to lo
			* Since the time to really show the complete transition is ~4ns, this means for some pixel positions the incorrect and correct values can be in two adjacent pixels from the display
				Add a new display "filter signals shorter than" option to the digital display: 5ns should be good enough, or 0.000000005 seconds.



* Added backplane, memory, and video right-angled connectors and headers. Removed the old vertical headers.
	Added VGA female D-sub connector VID2 which uses TVSYNCout for the HSYNC, which gives RGBS or RGBHV option in the conversion box
	Pixel headers as RA enclosed



* Remove the extra headers on the video layer
	Moved to backplane as they form the remaining compatibility header



* Back plane headers are 1,000 mil, ~23mm apart, wide enough to accommodate the ICs with decoupling sockets.
	Added to the backplane headers: UNUSEDEXPANSION*, UNUSEDVIDEO*
		This is so the same backplane can be used if the video layers need unexpected signals
		
		
		
		
* APU. Consider a game with double buffered screens, as is fairly common.
	Need a way for the APU to jump back to a PC and render the screen again using the current screen, or progress onto the second screen.
	* Perhaps have a new instruction kAPU_PCLoad16 which loads from reg0+1
		Done - Schematic kAPU_PCLoad16
		Also have a kAPU_SkipIfEQ which skips the instruction, by zeroing the instruction latches, if the current IDATA0 (IDATA bit 0) is zero
			It will be a good idea to have a stabilise instruction to make the chosen IDATA stable before using IfEQ
		This would allow the game code to have a memory location as a flag.
			Data registers could also be used if they are selected into IDATA, however since they are mostly used by non-trivial code then the extra complexity of allowing the user to independently reset them has little return.
		Done - Schematic kAPU_SkipIfEQ
		** Done - Emulation kAPU_PCLoad16
		** Done - Emulation kAPU_SkipIfEQ
		Schematic behaviour matches emulation





* Mode7 7483 is hard to find, needs to use 74283 instead
	Need to check using compareimages.bat





* APU: If I do add an extra register and some adders, I can use that as a free comparison function
	* Done: Emulation and schematic: kAPU_SkipIfEQ: In combination with a full 8 bit EQ check
	* Done: Remove kAPU_InterceptBus it's always and only used with the external memory write. It could be used for internal memory write instead.
	* 74LS251 could be used to select various results and the extra register
		https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS251NE4?qs=SL3LIuy2dWxH4pHshllfNQ%3D%3D
		* Done: kAPU_Reset_EBSEADDR / _Reset_EBSEADDR and _Reset_EBSEADDR2 (undefined input to U37:B) seems to be little use, reclaim it for extra internal register?
		* Now 4 signals free
		** Done: Add load DataReg3/4
		** TODO: IDataSelect extra results
			Memory
			DataReg0
			DataReg1
			DataReg2
			DataReg3
			Memory + DataReg3
			DataReg3 + DataReg4
			DataReg3 - DataReg4
			* Schematic and code changes done for extra data select logic
				*Needs unit tests - Unit tests done - Schematic validated




* Use new APU add/sub instruction to move sprites in SotB demo




* For board EA/EBS/EXTSEL config - Need to use jumpers (in the schematic it is closed to use the defaults) to connect the external bus to the internally used signals
	The routing will then not automatically connect the gap
	Jumpers should be placed on the edge of the board away from the interconnects
	* Added jumpers for EBS on main video boards




* Consider again char screen scrolling with large virtual screen, like the tiles
	Use case is the SotB demo title screen for the scrolling logos
		Some of the logic for the timing signals already exists on the layer.
		Perhaps the X and Y pos can use 8 bit latches, since the virtual screen will be 2x2 screens of 32x32 chars each
	* Using Bomb Jack - Chars scroll.pdsprj
		When BGXP = 2 or 3 then the char read into 5L6 seems to be wrong on the left and right edges?
			Tested by setting the palette read to be constant 0 colour (disable the colour load clock)
			The problem still happens, therefore the char seems to be wrong during that load
	* Moving the SL1 timing to after the SL2 time seems to fix the issue. Evidently the address is not quite right at the start of the character
		Need to check with more data
	* Done: Might need a MSB for the X and Y scroll registers!
	Simulation checks out with more generated data for X/Y char screen scrolls with wraparound checks
	* Done: Emulation needed
	* Done: Test with simulation from emulation output
	* Done: Update SotB demo to use the hardware chars scroll with a screen split, not APU updated char screen data
		Check with simulation



* Adjusted the left hand board edges to match the edge locating lip for the plugs
	Also adjusted the VGA output header position to sit further inside the edge
	
	
	
	
* Rename IC names like "5E2" because they are being interpreted as as a numeric value "500" (i.e. 5x10^2) and not the text value when reading the CSV
	Now prefixed with "L"



* Moved the labels on the board edge plugs



* The edge jumpers are marked with the default choice to close


* Board _EXTCS default connections now have labels



* Audio and APU boards, with EBS selection jumpers and plane layers, are aligned with the main boards




* Audio: 4082 to be replaced by 74LS21 https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS21NE4?qs=sGAEpiMZZMtMa9lbYwD6ZGuuqVaqkGmOS8GB5LKZP7E%3D
* Audio: 4075 to be replaced by 74 series logic. 7427 + 7404
* Audio: 7413 to be replaced by 7420 https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS20NE4?qs=SL3LIuy2dWy4R7Pu4ZGI8g%3D%3D
* Audio: 7483 to be replaced by 74283
* Audio: 74154 to be replaced by 74 series logic... A few more 74HC138 for example, which really uses this LS variant... https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS138NE4?qs=sGAEpiMZZMtxONTBFIcRfk9GpaUoLd0ck0Ao35GjMhY%3D
	Tested



* Audio: Stock code and Supplier updated



* Hires original PCB: https://live.staticflickr.com/6079/6106060384_34ad2ad34d_k.jpg
	Shows MN2114-2 at row 6 (check the right hand edge numbering)
		http://www.science.smith.edu/~jfrankli/270s02/datasheets/2114.html
		Which means similar to: 2114AL-2 - 120ns Max (40ma Max) ???








* PCB connectivity options:
	DIN 41612:
	https://en.wikipedia.org/wiki/DIN_41612
	https://www.hirose.com/en/product/series/PCN13#
	Backplane straight receptacles 50 way 2 rows:
		https://www.mouser.sg/Hirose-Electric/Connectors/Backplane-Connectors/DIN-41612-Connectors/PCN10-Series/_/N-axj5jZ1yzvvqx?P=1ytkn9pZ1yzve1gZ1z0z5h6Z1z0jmg3Z1z0j1prZ1z0xbxo
	Right angled board edge connector 50 way 2 rows:
		https://www.mouser.sg/Hirose-Electric/Connectors/Backplane-Connectors/DIN-41612-Connectors/PCN10-Series/_/N-axj5jZ1yzvvqx?P=1ytkn9pZ1z0spqhZ1yzve1gZ1z0z5h6Z1z0jmg3Z1z0xbyw

	Or perhaps Harting connectors. But these a press-in, which look more complicated to solder:
		https://www.mouser.sg/HARTING/Connectors/Backplane-Connectors/DIN-41612-Connectors/_/N-axj5jZ1yzvvqx?P=1z0z5h6Z1z0wxp6Z1z0zl89&Keyword=41612&FS=True
		https://www.mouser.sg/ProductDetail/HARTING/09282486804791?qs=%2Fha2pyFadujf%2FON5mzZXH%252BmRzB7nM%2FaLl9OChyBxONU%3D
		
	>>**<< These are 64 way and have solder pins plus Proteus parts:
		https://www.mouser.sg/ProductDetail/HARTING/09021646921?qs=gIpPgrDBK%2FiWr6s0yE4P1A%3D%3D
		https://www.mouser.sg/ProductDetail/?qs=gIpPgrDBK%2Fj7cjNJs9Ij%252BQ%3D%3D
	These are >=48 way, suitable for the video connectors:
		Receptacles: https://www.mouser.sg/TE-Connectivity/Connectors/Backplane-Connectors/DIN-41612-Connectors/_/N-axj5jZ1yzvvqx?P=1z0xby7Z1ytf3jyZ1ytkn9pZ1ysmvawZ1z0z63vZ1z0z5h6Z1yzvwjmZ1z0wxp6Z1yzs6iiZ1z0j1pr
		>> https://www.mouser.sg/ProductDetail/TE-Connectivity/5535091-5?qs=U4pz39agNJApG5vcI2Ocug%3D%3D
		Connectors right:
		https://www.mouser.sg/TE-Connectivity/Connectors/Backplane-Connectors/DIN-41612-Connectors/_/N-axj5jZ1yzvvqx?P=1ytf3jyZ1ytkn9pZ1ysmvawZ1z0z63vZ1z0z5h6Z1yzvwjmZ1z0wxp6Z1yzs6iiZ1z0vlpq
		>> https://www.mouser.sg/ProductDetail/TE-Connectivity/5650478-5?qs=xrnNvQC1SKQL0IHY3tGLpg%3D%3D
		
		
		
		
		
	
	


	Backplane:
		https://www.ti.com/lit/an/szza016b/szza016b.pdf
		https://resources.altium.com/p/signal-integrity-simulations-backplane-bus-connectors
	Ribbon cable + IDC:
		https://electronics.stackexchange.com/questions/206133/ribbon-cable-noise-susceptibility
		https://www.machinedesign.com/archive/article/21818753/tricks-of-the-trade-for-lownoise-design
		https://forum.allaboutcircuits.com/threads/ribbon-problems-there-has-to-be-a-better-way.17214/
		https://www.avrfreaks.net/forum/shielding-ribbon-cable
	* Perhaps a terminating header row, with a parallel row of headers at ground/power, allowing an easy bridge by any resistor/capacitor as needed




* 5 RCA male to VGA Male is uncommon:
	https://www.cs1.net/products/canare/V5-1p5C_RGBHV_VGA_breakout.htm
	https://www.elecbee.com/en/d-sub-cable-assemblies/3035-vga-to-rgbhv-rca-connector-cable-hd15-male-to-5-rca-male-connectors-12-feet-long.html
	5 BNC male to male VGA is a lot more common:
		https://www.amazon.com/C2G-02572-Premium-Rgbhv-Meters/dp/B0073DP4BC
		https://search.c2g.com/uk?category=1%7CVGA&it=item&keyword=rgbhv
	So consider BNC female for the next generation board
		https://www.mouser.sg/ProductDetail/TE-Connectivity/5227677-1?qs=GSeC4G%252BEqEX0oAnTcsRqKg%3D%3D
			The 3D model orientation is wrong for this part, when it gets imported from the extended search
		** Remember some spacing between connectors is good
	VGA female 15 way 3 row:
		https://www.mouser.sg/Connectors/D-Sub-Connectors/D-Sub-High-Density-Connectors/_/N-9gy6qZ1yzvvqx?P=1z0yy6bZ1yzsf9eZ1z0xbywZ1z0xbudZ1ytmhdpZ1ysmvaw
		>> https://www.mouser.sg/ProductDetail/TE-Connectivity/2311586-4?qs=rrS6PyfT74fCtSRxG4pC6w%3D%3D





* To order and also place into the stock code for the schematic
	https://www.mouser.sg/ProductDetail/Vishay-Cera-Mite/562R10TST20?qs=1Vd4QiMLiWEhnW3IqIibiA%3D%3D
	https://www.mouser.sg/ProductDetail/660-MFS1-4DCT52R5601
	https://www.mouser.sg/ProductDetail/Vishay-Dale/CMF55100R00FHEK?qs=E1R6yEsG10vYngbhrGJpcw%3D%3D
	https://www.mouser.sg/ProductDetail/Vishay-Dale/CMF55220R00FHEK?qs=UEmB0FaNOjg2TC4qgSAJvQ%3D%3D
	https://www.mouser.sg/ProductDetail/Vishay-Dale/CMF55221R00FKEB?qs=gQ87q99%2FLGLtVGUX15QkBw%3D%3D
	https://www.mouser.sg/ProductDetail/Vishay-Dale/CMF55442R00FHEB?qs=gQQ%2FpDEpiRKHk7nNPbIyfA%3D%3D
	https://www.mouser.sg/ProductDetail/Vishay-BC-Components/SFR25H0004700FR500?qs=58bml8Dt%2FllkS%252Ba6658qMg%3D%3D
	Misc:
	https://www.mouser.sg/ProductDetail/161-0097-E
	https://www.mouser.sg/ProductDetail/517-929975-01-10-RK
	https://www.mouser.sg/ProductDetail/575-8034700810001000
	https://www.mouser.sg/ProductDetail/520-HCU1209-SX
	https://www.mouser.sg/ProductDetail/661-E-630L100ME11D
	Power:
	https://www.mouser.sg/ProductDetail/163-179PH-EX
	Userport:
	https://www.mouser.sg/ProductDetail/587-305-52-024
	Jumper cables:
	https://www.mouser.sg/ProductDetail/932-MIKROE-513
	https://www.mouser.sg/ProductDetail/932-MIKROE-512
	https://www.mouser.sg/ProductDetail/932-MIKROE-511




* Find out where TST-105-04-T-D-RA and TST-105-04-L-D-RA orders came from. One is gold, the other is tin. Just need one type.
	Also Harting 09021646921 is missing, need to order
	The Mill-Max 380-10-108-10-003000 is not quite right, it has a solder cup, ooops
		Should have been something like this with longer mating post length:
		8 position
			https://www.mouser.sg/ProductDetail/Molex/90121-0128?qs=PvP5v7EimsmfZ8WDsc6%252BuA%3D%3D
			https://www.mouser.sg/ProductDetail/TE-Connectivity/826631-8?qs=6Tj7fpyCzVoXtZFhyBL3bg%3D%3D
		2 position
			https://www.mouser.sg/ProductDetail/Molex/90121-0122?qs=PvP5v7Eimsnxy72QvVQroA%3D%3D



* Pixel header connectivity
	PCB female header to male right angled: https://www.mouser.sg/ProductDetail/Molex/90122-0764/?qs=kEwmkoUtv7R5aSrMIeNWYw%3D%3D
	Then to socket: https://www.mouser.sg/ProductDetail/3M-Electronic-Solutions-Division/3868-6600/?qs=8XPjJVwSY9BFfS5andYLaA%3D%3D
		Or: https://www.mouser.sg/ProductDetail/Wurth-Elektronik/61200823021/?qs=PhR8RmCirEZvQm5v3EiYrA%3D%3D
	Cable: https://www.mouser.sg/Wire-Cable/Flat-Cables/_/N-5ggmZ1yzvvqx?P=1ytitytZ1z0vl9dZ1yzu8m9
	
	Perhaps these 10 way: https://www.mouser.sg/Connectors/Headers-Wire-Housings/TST-Series/_/N-ay0loZ1yzvvqx?P=1y6pcziZ1yvgchwZ1ytkn06Z1z0spqhZ1z0z63vZ1yzobh4Z1z0z63xZ1z0wxp6Z1yzv8u1Z1yzv7x2Z1yzs9vm&Ns=Number+of+Positions%7c0&FS=True
	Perhaps these 10 way: https://www.mouser.sg/Connectors/Headers-Wire-Housings/TST-Series/_/N-ay0loZ1yzvvqx?P=1y6pcziZ1yvgchwZ1ytkn06Z1z0spqhZ1z0z63vZ1yzobh4Z1z0z63xZ1z0wxp6Z1yzv8u1Z1yzv7x2Z1yzs9vm&Ns=Number+of+Positions%7c0&FS=True
	>> Right angled: https://www.mouser.sg/Connectors/Headers-Wire-Housings/TST-Series/_/N-ay0loZ1yzvvqx?P=1y6pcziZ1yvgchwZ1ytkn06Z1z0spqhZ1yzs9vmZ1z0z63vZ1yzobh4Z1z0z63xZ1z0wxp6Z1yzv8u1Z1yzv7x2Z1z0xbud&Ns=Number+of+Positions%7c0&FS=True
	>> 10 way cables: https://www.mouser.sg/Wire-Cable/Cable-Assemblies/Ribbon-Cables-IDC-Cables/_/N-bkreeZ1yzvvqx?P=1yyu1hyZ1z0wxp6Z1yny8waZ1yny8w9&Keyword=idc&FS=True



* Order replacements:
	74HC138
	https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS138NE4?qs=SL3LIuy2dWx0lDDFWb%252BGZQ%3D%3D

	CONN-DIL34
	https://www.mouser.sg/ProductDetail/3M-Electronic-Solutions-Division/929852-01-17-RA?qs=VCIs6OJqWMkB6xFyOZZSxA%3D%3D
		
	CONN-DIL20
	https://www.mouser.sg/ProductDetail/3M-Electronic-Solutions-Division/929975-01-10-RK?qs=4V84emjyG36NmJ6%252BaqUY8g%3D%3D
	
	CONN-SIL2
	https://www.mouser.sg/ProductDetail/3M-Electronic-Solutions-Division/929850-01-02-RA?qs=s3by4FhMkp0TJ2ZYzpYr%252Bg%3D%3D
	
	CONN-SIL8
	https://www.mouser.sg/ProductDetail/3M-Electronic-Solutions-Division/929974-01-08-RK?qs=neFkstNq%252B6G7LvVslYqF6A%3D%3D
	
	Long tail (wire wrap) SIL and a DIL
	https://www.mouser.sg/ProductDetail/437-8018700353001101
	https://www.mouser.sg/ProductDetail/437-8018700553001101
	https://www.mouser.sg/ProductDetail/437-8018700853001101
	https://www.mouser.sg/ProductDetail/437-8018701053001101
	https://www.mouser.sg/ProductDetail/437-8038301653001101
	
	DIL decoupling
	These can be in the component "Supplier" property, add using View->Property Columns the "CODE" (stock code) and "Supplier"
	DIL08 no cap
	https://www.mouser.sg/ProductDetail/Mill-Max/110-93-308-41-001000?qs=WZeyYeqMOWe5ncqYpB7m3g%3D%3D
	DIL14
	https://www.mouser.sg/ProductDetail/Mill-Max/110-93-314-41-801000?qs=%2Fha2pyFaduiAoJI%252BFT3Un6AU4u1EPWQWyNo%252BHzE50tJ%252B9XjMyXXSECwGDt8yOlKj
	DIL16
	https://www.mouser.sg/ProductDetail/Mill-Max/110-13-316-41-801000?qs=WZeyYeqMOWd122xzWNZKKg%3D%3D
	DIL18
	https://www.mouser.sg/ProductDetail/Mill-Max/110-13-318-41-801000?qs=WZeyYeqMOWcusVdSCp10bQ%3D%3D
	DIL20
	https://www.mouser.sg/ProductDetail/Mill-Max/110-43-320-41-801000?qs=RC2ne4458IKe5rHuueYA%2FA%3D%3D
	DIL24
	Need narrow and wide (7.62 mm and 15.24 mm)
	Narrow: https://www.mouser.sg/ProductDetail/Mill-Max/110-93-324-41-801000?qs=2mZjssE3HVXiFvwLlnaxRQ%3D%3D
	Wide: https://www.mouser.sg/ProductDetail/Mill-Max/110-13-624-41-801000/?qs=WZeyYeqMOWcY1RNZipzOSA%3D%3D
	DIL28 No cap
	https://www.mouser.sg/ProductDetail/Mill-Max/110-43-328-41-001000?qs=IGgAdOvCTsQUPmob89wrvw%3D%3D
	DIL28
	https://www.mouser.sg/ProductDetail/Mill-Max/110-93-628-41-801000?qs=%2Fha2pyFaduh%2F2llJlOg9PDhABSeSvrmpwTTGEnsRDIDydS5MKhEOSHtrFYy51Bes
	https://www.mouser.sg/ProductDetail/Mill-Max/110-13-628-41-801000?qs=%2Fha2pyFaduj2Vn9jTBaNkbbuPoiuMRTWeD8fU3A14YCfUCD0%252BtDLsfAVe9w3OSTn
	
	* Wide 6116 SRAM https://www.mouser.sg/ProductDetail/Renesas-IDT/6116SA150DB?qs=GVScuG1d83icae5fIq%252BJNg%3D%3D
		Also wide https://www.mouser.sg/ProductDetail/972-6116LA45DB
		The wide variants seem to have stock issues, so perhaps better to stick with the narrow variants

	* Can oscillators for user port interface, various speeds. Note the "tristate" ones where pin 1 is EOH "enable on high", it can float:
		https://www.mouser.sg/Passive-Components/Frequency-Control-Timing-Devices/Oscillators/Standard-Clock-Oscillators/_/N-7jdvaZ1yzvvqx?P=1z0yz4qZ1z0wu68Z1yzv18zZ1y95k8nZ1yzmm18Z1yzmm16Z1z0wnuiZ1z0wo7vZ1z0wnt1Z1z0woad&FS=True
		



* Parts list, Book of Materials, stock code links to ordering websites needed
	Adding links to the "stock code"
	Breadboard
	https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D
	Resistors
	https://www.mouser.sg/Passive-Components/Resistors/Through-Hole-Resistors/_/N-7h7z5
	https://www.mouser.sg/Passive-Components/Resistors/Through-Hole-Resistors/_/N-7h7z5?P=1z0z819Z1yzbpodZ1yyxf87
	Multiple resistance values: https://www.mouser.sg/Passive-Components/Resistors/Film-Resistors/Metal-Film-Resistors-Through-Hole/_/N-7gz41Z1yzvvqx?Ns=Resistance%7c0&No=25&P=1yzbppyZ1z0x8ahZ1z0x8beZ1z0wnmfZ1z0wngkZ1z0x8b3Z1z0vpm5Z1z0we4uZ1z0wljo
	
	VGA
	https://www.mouser.sg/ProductDetail/Gravitech/DB15F-VGA-TERM?qs=%2Fha2pyFadujCKQleo0iutDpWDaGRRxjTkj9IAyF0Np7%252BUoWsr1SFIUxZNLIelf9qWe7mZLtJ2l3bbZy4VSVLAA%3D%3D
	SIL/DIL connectors
	https://www.mouser.sg/3M/Connectors/Headers-Wire-Housings/_/N-ay0lo?P=1z0xbxoZ1yvsm2aZ1yvgcdjZ1ytkn39Z1yq9ciwZ1ytkls2Z1ytkn06Z1z0z5h6Z1yzxj1jZ1z0z63xZ1z0wxp6Z1yzv7x1Z1z0zp4d
	With long pins, wire wrap termination style: https://www.mouser.sg/Connectors/Headers-Wire-Housings/_/N-ay0lo?P=1z0z24iZ1z0z63xZ1z0wxp6Z1yzxj1j
	Sockets decoupling
	https://www.digikey.sg/products/en/connectors-interconnects/sockets-for-ics-transistors/409?k=&pkeyword=dip+decoupling&sv=0&pv5=382168&sf=1&FV=589%7C405002%2C-8%7C409&quantity=&ColumnSort=0&page=1&pageSize=25
	Same decoupling socket, found using manufacturer part number
		https://www.digikey.com/product-detail/en/mill-max-manufacturing-corp/110-93-314-41-801000/ED2101-ND/33731
		https://www.mouser.sg/ProductDetail/Mill-Max/110-93-314-41-801000?qs=%2Fha2pyFaduiAoJI%252BFT3Un6AU4u1EPWQWyNo%252BHzE50tJ%252B9XjMyXXSECwGDt8yOlKj
	This shows decoupling sockets by size
		https://www.digikey.com/en/products/filter/sockets-for-ics-transistors/409?s=N4IgjCBcoKxaBjKAzAhgGwM4FMA0IB7KAbRAGYAOAJjADYKQBdfABwBcoQBlNgJwEsAdgHMQAX3y0AnPBBJIaLHkIkQAFjBgKUgOxNWHSNz5DRYiSFqz%2BAE04wdEA5x4CRIfGwCeLbJxuYSOZAA
	Digikey might be a better source?
		https://www.digikey.sg/products/en/integrated-circuits-ics/logic-gates-and-inverters/705?k=74ls27&k=&pkeyword=74ls27&sv=0&pv69=411897&sf=0&FV=-8%7C705&quantity=&ColumnSort=0&page=1&pageSize=25
		https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS27N?qs=sGAEpiMZZMutXGli8Ay4kP28D9wZ8SQIwsPDjIqEADE%3D
	Digikey has memory
		https://www.digikey.sg/products/en/integrated-circuits-ics/memory/774?k=&pkeyword=&sv=0&pv69=411897&sf=1&FV=-8%7C774&quantity=&ColumnSort=0&page=1&pageSize=25
		But no price: https://www.digikey.sg/products/en/integrated-circuits-ics/memory/774?k=&pkeyword=&sv=0&pv142=227740&sf=1&FV=-8%7C774%2C69%7C411897&quantity=&ColumnSort=0&page=1&pageSize=25
		Jameco has: https://www.jameco.com/shop/ProductDisplay?catalogId=10001&langId=-1&storeId=10001&productId=38957
			Faster: https://www.jameco.com/z/2114N-2-Major-Brands-IC-2114N-2-SRAM-1Kx4-DIP-18-pin-200ns_38973.html?CID=MERCH





* V6.0

* 2114 SRAM might be unreliable to find. Consider using the same workaround from the sprite layer scan lines
	Two 6116 SRAM have been added, the original 2114 SRAMs have been disabled from the simulation, but left in the layout to allow for both chip types to be used.




* Check the trimming resistors produce a good tweak range
	They do. the colour channels can be made very dim or very bright.



* APU write back to its internal data RAM? Currently the internal data RAM cannot be accessed by itself.
	This could change if the data RAM is connected via the destination external address bus
	The init code should always set the APU into pass-through mode
	But this would introduce extra complexity with the _MEMBSEL logic that retries the instruction on a write to its internal memory
	* So, another signal to cause a write pulse with the currently selected ADDRB would be a lot simpler.
	* Tested simulation with kAPU_InternalMEWR



* IC Pin Straightener DIP Alignment Tool
	https://www.mouser.sg/ProductDetail/Aries-Electronics/T-516AS?qs=%2Fha2pyFadugyCCs6foAxw32%252B71CytEXs2beegWfw3qAoFiGedY8kFpk7%2Far1WGmu
	https://www.jameco.com/z/ICS-01-R-Jameco-Benchpro-IC-Pin-Straightener-Tool_99363.html
	https://www.amazon.com/JAMECO-BENCHPRO-Pin-Straightener-Tool/dp/B00B888W5S/ref=cm_cr_arp_d_pb_opt?ie=UTF8
	https://www.conrad.com/p/conrad-components-pin-straightening-tool-168203
	https://www.conrad.com/p/tru-components-pin-aligner-1-pcs-1564782-suitable-for-grids-sized-762-mm-1524-mm-compatible-with-semiconductor-en-1564782
	https://www.conrad.com/p/tru-components-pin-aligner-1-pcs-tc-8990560-suitable-for-grids-sized-762-mm-1524-mm-compatible-with-semiconductor-2247640
	




* APU Seems to have 1 bit available in the instruction set. Perhaps use this to create 16 bit adds? By expanding kAPU_IDataSelect
	Used by _InternalMEWR



* Check the headers on the chars and other layers are using the vertical SIL-2 not the right angled connectors



* Original PCB pictures: http://ikotsu.blogspot.com/2011/09/bomb-jack-pcb-tehkan-1984.html



* APU needs VIDCLK counter/divider with jumper output select, first choice being raw VIDCLK, going to U35:D
	U126 and jumpers output USECLK




* APU: Double check the timing for one entire instruction and compare with the pixel timing in the hardware
	APU timing for 10 consecutive breakpoint on low PCINCR without any memory contention retries
		During execution of the next frame (after the wait)
		0.016282774		0.00000463
		0.016287404		0.00000463
		0.016293190		0.000005786
		0.016298977		0.000005787
		
		Single cycle triggers right at the start:
		0.000329200		0.00001579
		0.000344990		0.00001579
		0.000345569		0.000000579
		0.000346147		0.000000578
		0.000346726		0.000000579
		
		Same timing logic from APU copied to video, single cycle triggers:
		0.031484630
		0.031485208		0.000000578
		0.031485787		0.000000579
		0.031486366		0.000000579
		
		RH samples, single cycle triggers
		0x0141
		0x0144		3
		0x0148		4
		0x014b		3
		0x014f		4
		0x0152		3
		0x0156		4
		0x0159		3
		0x015d		4
		0x0160		3
	Note cycle timings per cycle alternate 3 and 4 pixels per APU instruction
	* BDD6502 updated with correct cycle count, validated the same instruction and RH pattern
	* Enabled "And enable video display bus debug output" in @ShadowBeast and validated simulation with "..\C64\VideoHardware\target\debugData.txt"




* main7.a using HardwareTest_VideoPattern0
	If the screen is enabled with HardwareTest_VideoInitDisplay then the simulation shows corrupted sprite data, char and tile data is fine.
	However the same demo, with display enabled, on real hardware did not show any sprite corruption.
	* Test: Perhaps the data generator needs some timing value tweaks to safely write data, with a longer write pulse perhaps? This might align with the 24bit userport hardware writes.
		* Using data generator MEWR LOW/HI timings: 0.000000225 and 0.000000425 solves the corrupt sprite write issue
			This is however a very long write period
			Using 0.000000225 and shorter time period 0.000000125 also works but generates "early data trigger ignored" warnings
			0.000000150 and 0.000000125 works and does not generate warnings



* APU memory write timings need to be tested properly at the current VIDCLK faster clock speed
	The hi InterceptBus to _MEWR timing seems to be quite short
	The _MEWR pulse length also seems to be quite short, when InterceptBus is hi
	The _MEWR pulse also seems to be quite early in the InterceptBus timing, when InterceptBus is hi. It would be much better to push this much later in the slot.
		When using APU JP11 (which is VIDCLK/2) instead of JP10 (VIDCLK) then the InterceptBus to _MEWR = 175ns and lo pulse time = 160ns, which seems to be adequate
	Need to sync the APU generated timings to the data generator in the video schematic
	Also the emulation needs to use the correct APU speed when a suitable default timing is found




* Pull-up resistors
	https://eepower.com/resistor-guide/resistor-applications/pull-up-resistor-pull-down-resistor/#
	* A typical pull-up resistor value is 4.7 kΩ, but can vary depending on the application
	* A rule of thumb is to use a resistor that is at least 10 times smaller than the value of the input pin impedance. In bipolar logic families which operate at operating at 5 V, the typical pull-up resistor value is 1-5 kΩ. For switch and resistive sensor applications, the typical pull-up resistor value is 1-10 kΩ.
	Currently using 5.6k, but had to add another 5.6k in parallel: https://www.allaboutcircuits.com/tools/parallel-resistance-calculator/
		= 2800 ohm
	So instead of: https://www.mouser.sg/ProductDetail/660-MFS1-4DCT52R5601
	Try using 3k ohm: https://www.mouser.sg/ProductDetail/KOA-Speer/MFS1-4DCT52A3001F?qs=0J7VXftDlT5UxbwvicmnGw%3D%3D
	** All pull-up (PULLUP) resistor values on the sprite layer were changed



* APU: Consider pushing kAPU_InternalMEWR and kAPU_ExternalMEWR later into the instruction cycle and making their pulses twice as long
	This would allow the APU to operate at JP10 speed, not currently JP11 speed as it is in the current emulation
	* The setup and pulse needs be at least 150ns and 125ns
	output\DebugAPUOutputInternal.txt
		d$02080000
		d$02090010
		d$020a0002
		d$020b0008
		d$02080008
		d$02090002
		d$020a0010
		d$020b0000
		d$02080000
		d$02090010
		d$020a0002
		d$020b0008
		d$02080008
		d$02090002
		d$020a0010
		d$020b0000
	output\DebugAPUOutputJust9800.txt
		d$98200111
		d$98210112
		d$98200101
		d$98210101
		d$98200111
		d$98210112
		d$98200101
		d$98210101
	* _MEWRSLOT now triggers at cycle 6+0/1 and hits _ExternalMEWRPulse or _InternalMEWRPulse
		Expected internal and external memory data is validated
		With highest JP10 (VIDCLK) speed, MEMORY VSM shows bus intercept is 580ns and intercept to -ve _MEWR is 220ns and _MEWR pulse time is 185ns
		_InternalMEWR pulse is 185ns and data/memory bus setup time to -ve _InternalMEWR is 180ns
	* This means the emulation can use the faster APU timing again
	
	

* Debugging incorrect raster bar wait position
	* TestData_DebugPixelTiming.txt
	; This reproduces and fixed the incorrect wait position check observed in the raster bars wait
		Basically add the _VIDCLK signal to the value wait
	; Note: Inverted VIDCLK to be used in the APU, just after RH8 input
	; Note: "w$ff03ff00," is used instead of "w$ff01ff00,"
	



* Check the APU retry opcode works when it detects writes to its data/instruction memory from an external source
	Add extra validation for delta timings




* Removed old 2114 RAMs from the sprite scan layout 4A/4B/4C/4D
	The 6116 RAMs are perfectly fine



* Need to tidy the components to their layers.




* Video layer: Overscan choice (7A2 and 8B2) with hard clear on hblank/vblank. Could also use _TVSYNC for overscan
	Test _TVSYNC on real hardware first...
	Can be tested by removing U95 (only :A is used) and connecting U284 pin 4 to pin 3
		Tested on real hardware, a picture is generated with expected char corruption down the left and right hand edges where the borders should be.
		But the picture is very dark with brightness varying down the screen in horizontal bands, almost like the conversion box is compensating for the signal being active outside of the display area.



* Sprites2: Trigger on rising horizontal blank edge to edge set flip-flop. The next pixel can reset the flip-flop.
	Removes the large comparators, also allows the potential for overscan operation with longer scan lengths
	Emulation updated to match the simulation



* Sprite2 scale now *32
	Also fixed the logic that detects the sprite X >= extent test and and changes internal state back to fetching sprite registers
		The cascaded comparators can produce a momentary glitch, but isn't longer than the 6MHz low to high edge
		Removed the latch (flip-flop without clock) for the state and used simpler logic
		The last sprite register RAM address selector also needed to be connected, it was floating which meant the sprites were not being stored to the correct address
		Also need currentLineV to match emulation. To avoid the Y coord changing during the scan die to triggering at HSYNC



* Simplified the mode7 logic to remove the second pixel pipeline and use the entire 6MHz clock phase on the remaining pipeline to latch the input and latch the output
	The RAMs should be fast enough to have the two phase lookup going on based on the sprites using similar RAM timings and switch between read/write in the same clock rate.





* Sprites2: Using the scan line clear technique, but with a longer line of 384 pixels, and a drawn scan of 256 pixels, and logic that includes a scale factor...
	Perhaps this would allow scaled sprites, without rotation, (although rotation could be applied with another lookup?) and a mechanism to allow a maximum fill rate of XX pixels
	Where XX = 384 - the time needed to read coordinates, perform vertical clipping tests, and setup the scan segment write, per sprite
	When the scan line runs out of time to process sprites, then it just draws as much as it can
	Sprites could be 16x16 pixels with 240 (256-16) colours as well...
		Or have hi/lo 4 bits for sprite 0/32 (8192 / 256 = 32), and 4 bits palette index
	Try some software logic first, see if it is feasible with simple small per-pixel operations and state...
	Don't forget transparent pixel tests
	* A scale and inverse scale value would remove the need for a lookup table
	* Swap MSBX/Y to match the flips
	* Schematic case 7: "Perform Y extent check" checked working.
	* For case 13:
		For the left (even) scan logic block:
			When S2DOPIXEL == 0 ( S2_DOPIXEL == 1 ) then:
				Scan pixels are output and the pixel logic uses the pull-up resistors to clear the scan memory
				The 6MHz clock is used to count the entire scan
					The counters are always enabled
			When S2DOPIXEL == 1 ( S2_DOPIXEL == 0 ) then:
				Scan pixels are updated from the sprite data
				The 6MHz clock is used to count the sprite X position until the extent is reached
					The counter is only enabled when S2_ADVSPRI == 0 (S2ADVSPRI == 1)
					The counter load happens during S2_LDFRAME == 0
	* Done: currentSpriteXPixel = currentSpriteScaleXInv / 2;
		currentSpriteXPixel will get input depending on S2_ADVSPRI
		Needs to select the S2_LDSCALEXINV or 6MHz clock depending on the S2_ADVSPRI state (U335, U336, U337)
	* Needs to use adders for currentSpriteScaleXInv on rising edge of 6MHz (to coincide with just after the sprite data pixel write)
		S2currentSpriteXPixel[0..15] and S2nextSpriteXPixel[0..15]
	* if ((currentSpriteXPixel >> 4) >= currentSpriteScaleExtentX)
	* currentSpriteYPixel lookup table access
	* The sprite load schedulers (that choose which register to read from RAM) needed to be off for S2LINESTART
	* currentSpriteXPixel and currentSpriteYPixel pixel data fetch
		S2SPRIA0 == 1 (currentSpriteFrame & 0x01) will need to >>4 the sprite data
		Also (currentSpriteFrame & 0x30) will need to select
		* Need remaining selectors...
	* invert currentSpriteXPixel and currentSpriteYPixel
	* Done: Output disable flag, only clears the line...
		Need to calculate the maximum sprite address, then use that is the design. Needs to access somewhere within the $800 range for the selector...
			Don't forget it's using $200 within the $800 range for the sprite registers
			Perhaps offset $100 as it's not within the char screen?
			Think about the mechanism, does it just stop the sprite data being written and zero the "fetching sprite" state/index?
			$9100 = $01 = Enable sprites2
	* TODO: Consider using the two upper bits from the sprite frame to add numeric range to the scale for extremely small sprites. Currently sprites can only scale down to about 4 pixels in size.
		Or perhaps use the palette entry flips and instead have the flips in the sprite frame, to allow the extra scale bits to be read earlier and allow the initial scaleX to use all the available 10 bits



* Sprites2: Fixed the logic contention in the sprite scan buffer by moving the 6MHz OE for the input pixel selector to be earlier in the OR tree and moving the DOPIXEL and sprite enable OR later.



* Logic ICs need tidying again



* Sprite2: Frame now has added  | 0x40 = halfX | 0x80 = halfY to start rendering at a different half of each coordinate. Useful for smaller 16x16 sprites where you might want to start rendering from the other 16x16 quadrants.




* Sprite2: Logic contentions on the scan RAMs, but only for some parts of the screen, not all lines.
	Enabling debug break on logic contentions shows... S2ILD11 Most likely to happen around RV=0x49 RH=0x003 S2SPRIA=0x01
	The 74LS258 _OE = 1 so it's off
	RAM 6116 _OE = 0 so it's on
	But the debug shows the 74LS258 is still driving the outputs for a short while.
		Possible since https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS258BN?qs=%2Fha2pyFadugYCoHUAKZ16e6Ix0Tl4e52u5lkASBqGrE%3D
		Shows average propagation delay of 9ns for the LS part.
	RAM 6116 https://www.mouser.sg/ProductDetail/IDT/6116SA20TPGI?qs=sGAEpiMZZMt9mBA6nIyysK6VW3GrAnba45Kc6Apw0Go%3D
		Indicates the _OE is ignored when _WE is low...
		Perhaps use this behaviour with the slightly delayed _WE, to match the _OE of the 74LS258, to delay the end of the 6116 write and therefore delay the start of the output enable
		This would reduce clash with the output of the 74LS258
	* Added 7432 U396DEL to the _WE inputs of the two 6116 RAMs.
		This holds the _WE slightly longer, adds some delay, to match the 74LS258
		Sine U396DEL is only used for this delay, it can be be bypassed in the real hardware with some jumpers if needed.
		Output video compares the same. No logic contentions now.
		
		
		
* Sprites2: Merging some of the ICs to reduce IC count



* Sprites2: If the Y size is 0 then treat it as an end of list marker and stop processing any more sprite registers for the line
	Done: Simulation
	Done: Emulation



* MegaWang 2000 Turbo Edition: https://twitter.com/too_late_nate/status/1446606425925554181
	https://twitter.com/MartinPiper/status/1448298427142402051
	Logos:
		https://github.com/ianhan/BitmapFonts/blob/main/bb_font.png
		https://github.com/ianhan/BitmapFonts/blob/main/font-pack/Charset-DNS_Kefrens%20The%20Wall%20Font.png
		Wang https://github.com/ianhan/BitmapFonts/blob/main/font-pack/Charset-DNS_Sentinel.png
		https://github.com/ianhan/BitmapFonts/blob/main/font-pack/jet.png
		https://github.com/ianhan/BitmapFonts/blob/main/mvision2.png
		Mega https://github.com/ianhan/BitmapFonts/blob/main/silver_f.png
		2000 https://github.com/ianhan/BitmapFonts/blob/main/tristarf.png
		Turbo edition https://github.com/ianhan/BitmapFonts/blob/main/32X32-F6.png
		https://github.com/ianhan/BitmapFonts/blob/main/32X32-F7.png
		https://github.com/ianhan/BitmapFonts/blob/main/Cool-Cat-Font.png
		https://github.com/ianhan/BitmapFonts/blob/main/FRESH.png
	Mods:
		* https://modarchive.org/index.php?request=view_player&query=83123
		https://modarchive.org/index.php?request=view_player&query=82719
		* https://modarchive.org/index.php?request=view_player&query=80199
		https://modarchive.org/index.php?request=view_player&query=159691
		https://modarchive.org/index.php?request=view_player&query=122630
		https://modarchive.org/index.php?request=view_player&query=104840
		** https://modarchive.org/index.php?request=view_player&query=42987
		https://modarchive.org/index.php?request=view_player&query=122628
		https://modarchive.org/index.php?request=view_player&query=77048
		https://modarchive.org/index.php?request=view_player&query=84825
		https://modarchive.org/index.php?request=view_player&query=157799
	Background:
		https://www.spriters-resource.com/fullview/73184/?source=genre




* Consider replacement packages for sockets that include space for decoupling capacitors
	https://scholarsmine.mst.edu/cgi/viewcontent.cgi?article=2210&context=ele_comeng_facwork
	https://learnemc.com/decoupling-for-boards-with-closely-spaces-power-planes
	https://learnemc.com/decoupling-for-boards-with-widely-spaced-planes
	Note widths: https://www.mouser.sg/c/passive-components/capacitors/ceramic-capacitors/mlccs-multilayer-ceramic-capacitors/?capacitance=0.1+uF&termination+style=Radial&voltage+rating+dc=50+V~~50+VDC&rp=passive-components%2fcapacitors%2fceramic-capacitors%2fmlccs-multilayer-ceramic-capacitors%7cVoltage+Rating+DC
	5mm lead spacing: https://www.mouser.sg/ProductDetail/Vishay-BC-Components/K104K15X7RF53H5?qs=sYfpZ29HcUSlgH5bSUHkYw%3D%3D
		0.19685 inch == CAP20
	* SocketsWithCaps.pdsprj
	** It worked! https://www.youtube.com/watch?v=pFrLmoHeYb8




* Connectors PIXEL1 and LAYER1 are using the wrong pins (orientations) compared to LAYER2/3/4 etc



* PIXEL6 is using the wrong output names
	And using the wrong orientation





* Overscan, disable all pixel blanking from HBL?
	Related to the fading side effect of setting the pixel blank signal to the TV Sync
	* In the boot screen for demo7 try clearing all the display data, except the area in the middle.
		See if the pixel data near edges of the screen causes the fade effect.
	* Success!
		The video (25/10/2021) shows how a char screen with a bright white area can scroll around
		Only when the bright area seems to step into the extreme left/right area does it affect the sprite brightness
		* This is probably because the "zero voltage" cannot be read correctly during the HBLANK period
	** This means it should be possible to have a hardware register for "wideness", that alters the inputs to the comparators for the HBLANK?
		* Or perhaps selects several different "wideness" signals, one of which being the current option as default, with several other wider ones.
		* Reuse the enable/disable register, with the unused 0 bits selecting the overscan extent.
	* Test code in the C64 "overscantest.prg" Prototype2 folder
	** Left/right border edge logic updated to feed into one pathway - Identical output images
	* Perhaps have a less than and greater than comparator, for the left and right hand edge, that has 8 pixel steps?
		This would be an additional four 4-bit comparators with combinatorial logic and suitable inputs from some extra registers.
			Plus perhaps a selector to select old and new operation for maximum compatibility
		If RH $1xx is only used, this reduces the bit sizes needed for the comparator to only the values 0-$7f (ignoring the MSB $8x)
			Could use one register for upper and lower nybbles for the <= right hand edge and >= left hand edge
			* Less than and greater than range check works for a couple of fixed values
			* Add logic to latch $9e09
			* Done: Top right of the screen, and bottom right, show the "pixel notch" issue. Need to latch the vertical line position, probably on -ve _HSYNC (start of the sync), and expose from the video layer that instead?
				Use new PREHSYNC which is inverted PRE_HSYNC
				The PRE_VBLANK and PREVBLANK signal calculation also needs to use the latched 128V/64V/32V/16V values, not the PRE*V values
				This actually fixed the "8 pixel notch" in the bottom right of the screen, there is however a display enable delay of one frame now since the vsync isn't triggered at the right time after the display enable
					Before and after screen output checked, it's exact except for the notch, some raster bars, and one of the sprites is displayed incorrectly...
					Hmm... Could be a sprite schedule issue based on the changing 1V at the wrong time
					So we cannot latch the V signals at this point. Hmph.
				Instead the pre-line-V is latched on PREHSYNC and just used to the VBLANK calculation, this fixes the 8-pixel-notch issue without affecting anything else.
					This does leave the "Y-Pixel" far right edge disjoint issue, where the Y pixels are shifted vertically upwards by 1 at the old screen edge position in over scan mode, the Y position can be latched in the layer to fix this without killing the original sprites
				** TODO: While this proves the design, the chars/tiles/sprites will need to be substantially fixed to really take advantage of this. So for now, leave the line/H/V values as they are
					* TODO: This would include altering the scan schedule so that 0H starts as the +ve _HSYNC and count from 0-383 inclusive, not starting at $180-$1ff then $00-$ff
						* Also that the *V value is updated on +ve _HSYNC
						* And fix the sprite schedule and add a sprite MSBX bit somewhere, and make the sprite raster line longer to accommodate the MSBX
				* First 15 TestData.txt frames are exact at this point
		* TestData_DebugScaledSprites.txt has been updated to include overscan, second sprite Xpos updated to be 0 to hit the left border
			* Done: Emulation needs to be updated to include overscan support
* Done: Video layer: can have 4 register bits to enable each pixel input independently.
	Done: This activity signal for each layer can then be sent out through the pixel headers.
	Done: This reduces the complexity of each layer.
	done: * kVideo_EnableDisplay_Tiles_Enable is already there in the video and tiles logic, it could be reduced in the tiles schematic



* Enable the overscan vsync calculation fix, the line number latch
	The top lines of the first frame are a bit wonky, but nevermind. :)



* Video layer, isolate the signals and ICs used for the timer generation.
	Reduce VIDCLK signal paths by using dedicated ICs 3T:A should be split out



* V8.0 PCB updates



* Expanded backplane by an extra header




* Sprite scan RAMs chip enable use V and _HSYNC
	_HSYNC	V		_CE
	0		0		1
	0		1		0
	1		0		0
	1		1		0
	This reduces the time the RAMs are on, which can help save some power and heat stress




* Simulation video capture width = 384 - 32 = 352



* Simulation: Video capture, restore 384 pixels wide, output signals during _HSYNC
	Add verification option (and warning) that the signals are 0 during _HSYNC
	Note: By setting a very wide overscan extent register, e.g. $0f, it is possible to generate video data output of the display area.




* Add separate use display time, split from the current display in sync option



* Added an early 3-input AND with ENABLEPIXELS, _HSYNC & _VSYNC output pixel disable, just to catch the instances where the overscan extent register is configured incorrectly.
	This definitely avoid any instances of incorrect video signals.




* _EHSYNC _EVSYNC _ETVSYNC all need to be on the external headers and connectors. Sigh.
	* And other layers (mode7!) need to use them too.



* Updated connectors in APU and Audio for new signals



* Video: Make a call to remove the placement of the 2114 RAMs
	Disabled in simulation and placement



* Added extra schematic documentation for sprite multiplexing



* Double check timings with the APU output, use the scope, after +ve edge hold time and align with the data generator




* Chars: Think about adding an extra 8K to make the virtual screen wider
	Simulation and emulation updated for 1024 wide char screen - Tested with SotB demos
	Done: Need to update data files for unit tests
	Done: Update other demos that use overscan (Demo7 and Demo9)




* CMPBLK and _CMPBLK signals might be able to be removed, they seem to be unused
	Could expose FINALENABLEPIXELS instead
	_CMPBLK = UNUSEDVIDEO7
	CMPBLK = FINALENABLEPIXELS





* Fix the Sprite schedule to align with the overscan expectation that the V counter only changes at the end of the hblank
	Could also allow MSBX for the sprite by using the F (full screen height) flag. MSBX is much more useful that the full screen height flag.
	* The emulation would need to be fixed the add an optional new video board behaviour and the fixed sprite behaviour
	The sprite rendering line can be 512 bytes long, like sprites2, giving a much better horizontal clipping range
	Key differences
		* EMUDone: RH=0 is the start of the line just after +ve _HSYNC and RV is changed on +ve _HSYNC
			This is accomplished by extra internal pixel counters
		* EMUDone: The overscan lg register 0x9e09 is now used to mask the left/right borders during any scrolling
		* EMUDone: BorderX shrink flag no longer used in 0x9e00
		* EMUDone: No more "enable overscan" bit in 0x9e00
		* EMUDone: Sprite register reads now start at 0 for RH=0
		* EMUDone: Sprite 32x32 check uses 256H not _256H, which means the selection logic has changed. Will need to be figured out from the simulation again.
		* Sprite raster line output is delayed roughly 8 pixels (due to the 8 pixel shift outputs and the _CONTRLDA/_CONTRLDB switch), which means the sprites are all shifted over by that number of pixels
			Done: The last sprite might be displaying only the first 8 pixels edge?
		* EMUDone: Sprite MSBX = 0x10 in palette register
		* EMUDone: Last sprite is only 8x16 pixels, not 16x16 pixels, due to the reduction in time for the output scan line start
			The 32x32 behaviour will need careful checking
				@TC-9 created for 32x32 behaviour
		* EMUDone: Sprites2 currentLineV no longer needs to be latched
		* EMUDone: Sprites2: Check screen edges related to doLineStart
		* Done: Document new raster line schedule, especially for sprite fetches
		* Hardware: Layers to use combined enable bits from the video board
			Done: Sprite enable flag
			Done: Chars enable flag
			Done: Tiles enable flag
			Done: Mode7 enable flag
				Shift bits down
			Done: Sprites2 enable flag
		* Emulation: Layers to use combined enable bits from the video board
			Done: Sprite enable flag
			Done: Chars enable flag
			Done: Tiles enable flag
			Done: Mode7 enable flag
				Shift bits down
			Done: Sprites2 enable flag
			Done: Check borders with hardware
				Done: right border brought in by one pixel in emulation.
					DisplayBombJack.java
			            // Note: When using $2b in emulation, the very last pixel edge will be duplicated in hardware, but not in emulation which outputs a new column of pixels
						// This is due to a small difference in _HSYNC handling
						// Will be safer to use the recommended $29 for a 320 wide screen
			Done: Check Sprites2 behaviour with hardware to emulation when the raster line runs out of time
				Frame 444 of @Demo9
					Emulation displays worse performance, less pixels filled, than simulation... Hmm...
					Fixed. Combination of Y extent check and transition from load frame to output first pixel
		* Done: Update example code/defines
			Especially the Sprites2 demo
			Added kBus24Bit_VideoLayer_HasOverscan
		* Done: Mode7 X/Y position in emulation compared to hardware
	* Done: The chars scroll in Generatedata\AnimationData.txt seems to have some weird flickering frames
		Narrow down which frames
		Then the data that produces them
		Line 47365 when rendering frame 44
			Should be:
				d$900101ef
				d$90020101
				d$900301f5**
				d$90040100**
			But CHXP[0..8] is showing f5ef instead?!!
			But CHYP[0..8] is showing 23f5 instead?!!
		Line 49801 when rendering frame 46
		Line 53695 when rendering frame 49
		Changing data generator "Then time to MEWR HI" from 0.000000125 to 0.000000100 (shortening the write pulse, making the after data hold time longer) seems to fix the incorrect latch write issue
			This might be because the READCHYH time got the 8-bit latch on sheet 6 using three 74HC138 chained together, could be taking a long time and the data hold time wasn't quite long enough...
			Done: Try using _MEWR on the _OE inputs to the 138s with the 0.000000125 timing
				Worked
				Updated a few other latches on other layers
				Sprites2 (scaled) tested, still works




* Original timings from the original schematic from root sheet 3
	1H	2H	4H		_SLOAD	_SL1	_SL2
	0	0	0		1		1		1
	1	0	0		1		0		1
	0	1	0		1		1		1
	1	1	0		1		1		0
	0	0	1		1		1		1
	1	0	1		1		1		1
	1	1	1		0		1		1
	* Looking at the timings, it seems as though the original tiles layer has some timing bugs to do with colour loading, but these would not be visible in the graphics data as the edges of tiles and tile colours didn't change much





* New Tiles board mostly works with 16 colours, except certain there is a weird colour strobing effects with what looks like 8 pixel gaps that do not move with the X or Y scroll position
	Investigate further: Perhaps related to: Real hardware When Tiles X scroll & 7 = 7
		Note: This effect is visible in the 8 colour board version (videos) after the X scroll bug is fixed with the extra external board. https://youtu.be/UzVHgiNhnio?t=69
			So it's not a regression per se
	* Options:
		* No difference - Try bypassing the adders, by removing them and using the BGH values without any add, to see if that fixes the ripple
			Although, setting the plane selector to %11111111 to select the last plane, filling the remaining palette with grey scale colours, and then using the 1H debug header pin did show considerable unstable values in the "meant to be" alternate pixel colours
				Note: The same noisy effect, with 1H to pixel header, is visible in the 8 colour board stack as well. So also not a regression per se.
			* Repositioning the VGA cable and video conversion box did show some improvement.
			* Going to have to get the logic analyser out I think and try to see how clean the captured signal is with a test pattern on screen
		* Perhaps because the 6MHz clock is used to latch the H/V/signals then the counters for the original signals should be used _6MHz instead?
			* Tried: To remove the H/V/signal latch effect, the latches can be removed and the inputs and outputs can be connected to restore the previous functionality
				Remove U255 , U256 , U259
					Connect pins:
						3	2
						4	5
						7	6
						8	9
						13	12
						14	15
						17	16
						18	19
				* No effect, tiles still shows the wobbly pixels. The 1H pin header into pixel header also still shows wobbly pixels, even without any other boards plugged in.
					Starting to think it is signal reflection on these lines?
					But even sourcing the pixel signal directly from U255 pin 2 or 3 (1H or pre1H) still shows the wobble
			* Alternatively try changing 3T:B clock input to be _6MHz
				Before and after change output images are exactly the same in simulation
			* TODO: Need to try changing the input clock pin on 3T:B pin 11 from 4T pin 9 6MHz to 4T pin 13 _6MHz
				Also 3S pin 2 and 3R pin 2

		* Since the above, likely no difference - Try using a 74273 latch for the BGH values coming from the adders with a latch on 6MHz
			This will push the tile pixels one pixel behind, but can be corrected by using a 0xffff X scroll value
				As long as the full screen edges are correct
		* Remove the same RAM being used and separate out the colour and screen display RAMs. This means the screen and colour loads are in parallel
		* Remove the 16x16 tiles completely and just use the double RAM technique to increase the size of the 8x8 chars screen instead
			Basically have one chars layer design only and just build two or even three to get desired layer functionality
			Will need to test chars layer hardware scrolling capability first
	* The new chars board, with those tall columns that show the effect in the tiles board, is also visible in the charslayer
		The logic is very different in the tiles board, so perhaps this indicates the issue is in the video board after all?
			* TODO: Check if the video board timer generation needs some pull-up resistors? Or perhaps a filter capacitor?
	* Squeezing, or even touching, CSYNC1 produces noticeable visual horizontal shifting of the video signal and alters the noise observed?
		Squeezing TVSYNC1 produces a similar effect, but less noticeable.
		Perhaps related to the VIDCLK and 6MHz signals being routed through 3T:a which is quite distant from the main clock circuitry on the version of the video board fabricated
			Split out 3TT:B from 3T:B to ensure the 3T and 4T ICs are very near each other
			Also added GND thick tracks
	* TODO: Using the header and jumper VGA connector from the prototype 1 board, try switching back to the HV sync method... and also try some filtering caps




* Flux
* Power meter
* Solder sucker https://www.electronicshub.org/best-desoldering-stations/
	https://www.amazon.com/YIHUA-Desoldering-Station-Soldering-Iron/dp/B07RTXCHGV/ref=sr_1_5?dchild=1&keywords=YIHUA+948+ESD+Safe+2+in+1+80W+Desoldering+Station+and+60W+Soldering+Iron-+Desoldering+Gun+and+Soldering+Station&qid=1623224018&sr=8-5





* PCB Smoke test procedures
	Populate timer crystal, resistors, capacitor
	Populate 3T and 4T
	Connect jumper
	4T pin 1 input needs to be driven low (display enable)
	Connect power
	Measure 4T output pin 9, remember to connect GND (grey wire) on the logic analyser
	Logic analyser logic threshold 2V
	DSW9 to choose _EHSYNC or _ETVSYNC




* Added DIL24NARCAP20




* To prepare for DIL*CAP20
	https://resources.altium.com/p/emi-reducing-pcb-shielding-techniques-incorporate-your-designs
	Some of the shield guard traces need to be moved.
	Using the design explorer, IC package search, look for:
		DIL14
		DIL16
		DIL18
		DIL20
		DIL24NAR
		DIL28
	Highlight the column, type in and append "CAP20" to the package name
	Look for unplaced package ICs, delete IC, then replace IC using new package to ensure netlist is correct
		Check ground and power pins are populated



* CheckConnectivity
	Include alias names for header nets
	Include video connector nets, including layer enable



* Each layer enable can be used to zero out the layer's output pixel latch
	Except sprites, since they are using scan lines and multiplexing needs to work
	
	


* Instead of headers for the address selects, think about a bank of dip switches
	Two options:
		>> https://www.mouser.sg/ProductDetail/TE-Connectivity/ADE08A04?qs=sGAEpiMZZMtt%2FePYj%2FTMhwk%252B%2FhX4O0WAjJubDt0lPR8%3D
		https://www.mouser.sg/ProductDetail/TE-Connectivity/5-435626-5?qs=sGAEpiMZZMvC4tFtz7F%252BjiWKZepm43pLTfhntRPSxuc%3D



* To attempt to reduce signal crosstalk on the video board between the digital and analogue parts
	The resistor ladders have been horizontally separated to allow signals to pass between the resistors
	L5E2 and the input 5F8 , 5H8 , 5J8 , 5K8 have been placed closer to the output and the resistor ladders (their traces were straying into the output header areas)
	Keepout boxes have been placed below the resistor ladders, and to the left of the output headers
	The output latches 7B2 , 8A2 6MHz track passes to the left of the ICs, not to the right near analogue signals
	The sync signal output U284 moved closer to the VGA header output and the _ETVSYNC resistors
	
	
	
* Header text protected by placement keepout and DIP switch default markers moved to the edge of the board with DIP switch moved away from the board edge



* Perhaps the APU schematic needs a clock divider for the VIDCLK to 6MHz clock, which is excluded from the layout of course...
	To avoid any chance of clock skew
	* Check if _VIDCLK for the ID17 can be changed to be 6MHz instead
		Also would need to check com.loomcom.symon.devices.UserPortTo24BitAddress#apuCheckTriggers
		Tested successfully with emulator output
		Also the first couple of frames from simulated APU output are correct




; Using BombJack\output\DebugAPUOutput.txt
	From the simulated APU output from the emulated APU input, described in BDD6502\Done.txt: @TC-1: When using "enable APU mode" and "enable user port bus debug output"
	** Waiting for $24017e01 line 578539, frame 5, it misses that trigger, why? :)
		Well, the previous wait is:
			**w$ff03ff00,$24017901**
			d$9e020100
			;@time:0.220757
			;delta:0.000001
			**w$ff03ff00,$24017e01**
		This is a gap of 5, which is a bit too short
		Using a quicker output from the VIDCLK divider pushes the problem to waiting for $2d020501 line 579055, why?
			w$ff03ff00,$2d030001
			d$00000000
			;@time:0.221266
			;delta:0.000001
			w$ff03ff00,$2d020501
		Which is again quite short, but also the 6MHz phase is opposite...
			** Also the RH8 is inverted, meaning it is looking for $100 then $005 ????!!!
		** Is this because the U95:B which is a 7474 is lagging compared to the U1 74LS374?
			Perhaps, temporarily changing this this push the error to wait for $24017b01 line 582727...
				Added a U95 to buffer the RH8 along with the U1 and U2, also placed these very the board connector to shorten the time
				w$ff03ff00,$24017501
				d$00000000
				;@time:0.237517
				;delta:0.000001
				w$ff03ff00,$24017801
				d$9e010109
				;@time:0.237518
				;delta:0.000000
				w$ff03ff00,$24017b01
				d$00000000
			This time, notice the d$00000000 writes
		** Perhaps this means the recorder needs an "ignore $00000000" write mode?
			Testing ignore zero writes does clean up the data a lot and results in more successful frames
		* Since the video board already buffers the RH/RV signals, is another latch in the APU needed?
			Removed latches and just use 6MHz for the comparison





* Why did the APU have a weird wait 0x47ff60 that was never reached?
	At 0.706843665 seconds
	Line 162501 $25002600
	RH=0x012
	RV=0x25
	It had recently finished this wait and write from the user port:
		w$ff03ff00,$24017600
		d$0
		d$41bc0215
	The $ff looks very wrong, breakpoint on that value... WAIT_VAL[16..23] = 0xff
		The write happens at 0.706841640 seconds
		RH=0x006
		RV=0x25
		At line 162499 PC=0x00fb
			This write is still being processed IEMEMWRITE is low:
				w$ff03ff00,$24017600
				d$0
				d$41bc0215
			Hmm _MEMBSEL is low, which is correct
			The instruction schedule U71 is being reset, which is correct
		This means _Load_Wait16Pulse was low, which happened when _Load_Wait16 and PCINCR were low
		Hmm... This would mean the memory write interrupted the load pulse and the pulse to increment the instruction
		** This is bad as the instruction will not retry the load instruction after the memory contention is done
		*** Perhaps stop the instruction increment when there is any member contention? i.e. when _MEMBSEL is high??
			Fixing this, seems to avoid the wrong wait read
	>50 frames seem to be output correctly...




* TestDataAPU1.txt
	; Why does this write fail?
	d$420002fe
	IEBSx wasn't being used for the internal APU dip switch... Doh!




* When running with BombJack\output\DebugAPUOutput.txt from the SotB demo, frame debug*31 has a wrong sprite for the tree, bottom right under the logo.
	This doesn't happen from the emulation debug output VideoHardware\target\debugData.txt
	** Perhaps reconcile the simulation output with the emulation output, find any mismatching write first
		This will need a tool to check data bytes written after each ^-$01, but will need to sync using w$ values instead since the simulation output doesn't have ^-$01
	NOTE: Before using ReconcileData.py in debugData.txt look for "d$20000203", copy everything from the top of the file, replacing everything in DebugAPUOutput.txt to the first d$20000203
	Reconcile shows some sprite register write mismatches: python C:\Work\BombJack\ReconcileData\ReconcileData.py C:\work\C64\VideoHardware\target\debugData.txt C:\work\BombJack\output\DebugAPUOutput.txt
		Begin reconciliation
		data     152950   982301a0  :  589568   9823019f	x
		data     152955   982701b0  :  589584   982701af	x
		data     163566   9823019f  :  611192   9823019e	x
		data     163571   982701af  :  611208   982701ae	x
		data     174130   9823019e  :  632764   9823019d	x
		data     174135   982701ae  :  632780   982701ad	x
		data     181770   98180146  :  647816   98180106	f
		data     184699   9823019d  :  654340   9823019c	x
		data     184703   982701ad  :  654356   982701ac	x
		data     185739   98190115  :  655916   98190100	c
		data     195258   9823019c  :  675908   9823019b	x
		data     195263   982701ac  :  675924   982701ab	x
		data     205826   9823019b  :  697484   9823019a	x
		data     205831   982701ab  :  697500   982701aa	x
		data     216394   9823019a  :  719060   98230199	x
		data     216399   982701aa  :  719076   982701a9	x
		Read lines  226919  :  740465
	This shows all the reconciliation differences are data byte not address based.
		Most are "x" position differences
		One "f" is a sprite frame difference
			; Frame 44
		One "c" is a sprite colour difference
	d$98180106 the sprite frame difference only appears once in DebugAPUOutput.txt
		It also only happens at w$ff03ff00,$94021901
		;@time:0.680369
		;delta:0.000003
		w$ff03ff00,$94021901
		d$98180106
	Using a timed breakpoint run for 0.680368 seconds (-0.000001)
		It is using APU RAM $1bb which contains $06
		Added APUDRAMA[0..12] and _APUDRAMWE for U17 Can record DATA[0..7]
		Looking for d$01bb0006 in BombJack\output\DebugAPUDataRAM.txt
			;@time:0.673315
			;delta:0.000071
			d$01bb0006
		Only one instance...
		So run to 0.673314 (-0.000001)
		The write to the data RAM is definitely outputting an occasional 06 even though it started out as 46
		This is due to the data selection and direction logic at U22 U124 U125
		The APU DigitalData generator is using timings
			0.000000125
			0.000000125
			0.000000000
			0.000000000
		This seems a little short?
		Perhaps set the DigitalData to use these values as they are meant to come from the user port module...
			0.000000150
			0.000000125
			0.000000015
			0.000000390
		Hmm still seeing:
			;@time:0.673315
			;delta:0.000071
			w$ff03ff00,$24036f01
			d$01bb0006
		Perhaps still not long enough? Measure and replicate the timings from the userport interface...
		* The userport interface, with 4MHz, has 270ns setup and 240ns write
		Even with:
			0.000000270
			0.000000240
			0.000000015
			0.000000625
		The U22 74LS373 is generating UND outputs, even through the 6264 is FLT and OE is disabled
	** Making _OE always low seems to solve the incorrect UND write issue
		According to the datasheet this is a _OE write cycle 1 model: https://www.mouser.sg/datasheet/2/12/Alliance%20Memory_64K_AS6C6264v2.0July2017-1144693.pdf
			Page 2 of 12 shows _OE can be X (Don't care) when _WE is low
		Data reconciliation shows the 46 write is fixed
			There are other recon issues, but these seems to be old data which could be a slow write issue, not wildly incorrect data issues
		Could this explain why writing to the chars with the screen on, during the visible screen portion, sometimes generates that spurious write?
	Remaining reconciliation errors:
		Begin reconciliation
		data     152950   982301a0  :  589568   9823019f
		data     152955   982701b0  :  589584   982701af
		data     163566   9823019f  :  611192   9823019e
		data     163571   982701af  :  611208   982701ae
		data     174130   9823019e  :  632764   9823019d
		data     174135   982701ae  :  632780   982701ad
		data     184699   9823019d  :  654340   9823019c
		data     184703   982701ad  :  654356   982701ac
		data     195258   9823019c  :  675908   9823019b
		data     195263   982701ac  :  675924   982701ab
		data     205826   9823019b  :  697484   9823019a
		data     205831   982701ab  :  697500   982701aa
		data     216394   9823019a  :  719060   98230199
		data     216399   982701aa  :  719076   982701a9
		Read lines  226919  :  740465
		;@time:0.319097
		;delta:0.000001
		w$ff03ff00,$01015400
		d$9823019f
	So run to 0.319096
	It comes from from $003a which is $9f
	Look for d$003a009f in DebugAPUDataRAM.txt
		;@time:0.317519
		;delta:0.000001
		w$ff03ff00,$f1020d00
		d$003a009f
	From external write $403a029f
	From line 146931 debugDataJustUserPort.txt which is $403a029f
	So it's just a precise timing issue, not an incorrect write, because the writes here are all done without timing sync in the vblank
	Note: For SotB title demo, in C64\VideoHardware\asm\ShadowBeast\APUTitle.a , changing the first "+MAPU_EmitWait kBus24Bit_VideoLayer_XPos_HSYNC_start , 0" to use raster line 11 "+MAPU_EmitWait kBus24Bit_VideoLayer_XPos_HSYNC_start , 11"
		This solves the remaining reconciliation issues as it gives enough time for the CPU to send blimp sprite position updates to the APU data RAM.




* APU adjust board size
	Add *CAP20 packages
	Move DIP default indicators to top
		Add * to APU and Audio DIP
	Needs a + shaped placement keep out in the centre of the board. As tall as the internal expansion bus header


* Add GND track isolation and keep-out to audio



* Audio to use DIL*CAP20 packages and adjust board size




* Trim pots rapidly out of stock
	Similar: https://sg.element14.com/w/c/passive-components/potentiometers-trimmers-accessories/trimmer-potentiometers?trimpot-type=multi-turn&adjustment-type=side-adjust&track-resistance=100ohm&potentiometer-mounting=through-hole&trimpot-shape-size=3-4-inch-rectangular&range=inc-in-stock
	
	Original: https://www.mouser.sg/ProductDetail/Bourns/3005P-1-101?qs=%2Fha2pyFadugNvqHzgUEG%2Fv4gN98QRkBfjRsbXcFAihF0XyOI7GuhTQ%3D%3D
	Replace with: https://www.mouser.sg/ProductDetail/Bourns/3006P-7-101LF?qs=GiVA9kKujyafZRjN8HNnfA%3D%3D





* Audio needs stereo headphone socket
	https://www.mouser.sg/c/connectors/audio-video-connectors/phone-connectors/?q=audio%20jack&mounting%20style=Through%20Hole&number%20of%20positions=3%20Position&orientation=Horizontal&standard=3.5%20mm%2C%201%2F8%20in
	Metal socket https://www.mouser.sg/ProductDetail/CUI-Devices/SJ1-3523N?qs=WyjlAZoYn50aNl0vAhb3Tg%3D%3D
	>> Plastic socket https://www.mouser.sg/ProductDetail/CUI-Devices/SJ1-3523NG?qs=%2Fha2pyFadug1PPkGIC3KLTQ8pv5w8IY43h8lhtTB0RjfsNT227Qv1Q%3D%3D
	https://www.headphonesty.com/2019/04/headphone-jacks-plugs-explained/
		Left = 2 = tip
		Right = 3 = Middle
		GND = 1 = Sleeve, closest to the cable





* Vectors:
	Done: bank0 RAMs data write, needs isolated address from bank1 RAMs data write
	Done: bank select register
	Done: bank demux data from bank select register
	Done: Index counters, reset to zero on !_Vsync or !enablelayer
	Done: Reset pixel count counter and final pixel latch on !_Hsync
	Done: When _hsync and _vsync
		TODO: This could have been _ETVSYNC but it's not on the backplane...
		if pixelcount == 0
			clock in new final pixel and inverted pixel count
			also increment the idx
		else
			clock pixelcount
	Tested with emulation output data




* Need IC grouping
	Vectors layer will need code and supplier data added
	Layout created


* V9.0 PCB updates

* Dip switch on PCB needs numbers
	Perhaps rotate all the dips for convention left to right numbering?
	Moved DIP switches to the left of the board near the backplane connector




* Video: VGA VID2 output wasn't showing a Hsync, but the VID1 header was
	VGA VID2 header stupidly using TVSYNCout
	Had to disconnect R104 as it was a dodgy pull-up that was just not working at all.
	The VGA header should just use _EHSYNC and _EVSYNC signals
	There should be another VGA header using _ETVSYNC, or have the sync selectable via DIP switch
	* Added DSW9 to choose _EHSYNC or _ETVSYNC
		Using: https://www.mouser.sg/ProductDetail/TE-Connectivity-PB/1825360-1?qs=Ftb%252BnBCDTZKCT4kLG1kHfw%3D%3D



* Right angled connectors need silk screen indication




* Scaled sprites clocking, perhaps have a faster clock, with a divider clock. Include VIDCLK and 6MHz
	When calculating a line have a DIP switch that chooses one of these clocks so it can be manually tweaked for performance.
	* Maximum simulated VIDCLK rate before seeing significant issues is ~15Mhz, which really doesn't offer enough performance gain for much benefit
		It would give around an extra 92 pixels, which would help with the sprite reading overhead
	S2DOPIXEL and S2_DOPIXEL can be used to switch the 6MHz or other clock rate selector signals appropriately for the scan logic
	* Trying... Generate baseline
	* Added select of S2CalcCLK / _S2CalcCLK to S2CLKA / S2CLKB / _S2CLKA / _S2CLKB
	This isn't working at all well. If the clock is not synced to the 6MHz then it is missing scan lines, wobbly lines appear etc
	* Interesting to note: The DEL (delay) OR into each _WE for the scan RAMs can be removed
	It works so badly, it indicates there is some core logic going wrong with the sprite calc and the scan calc
		Is this a serious clock skew issue?
	** Ah ha, it's because the short tick S2_LINESTART from VID_LINESTART was not being synchronised reliably with S2CalcCLK
		It still generates wobbly scanlines, but at least all scanlines are present now
		This indicates some residual timing pulse issue at the start of the scanline...
		Perhaps the scanline start reset signal should be held lower longer or delayed...?
			** S2DELVID_LINESTART created, which delays the line start pulse until after the S2DOPIXEL swap and fixes the wibbly line issue
			This basically resets the scan counters a few pixels later when they are meant to be outputting the scan
	Using 15MHz calc clock, which is divided by 2: Observed the massive scaled sprite, behind others, does render more horizontal pixels
	* Problem: The bottom right flipped scaled Turrican legs sprite doesn't seem to want to complete rendering?
		Is this because the sprite X extent signal is early? Cascading extent test issues?
			Adding a bunch of OR delays, and adding a off-cycle _S2CalcCLK delay, did not fix the issue... Hmm...
			Could be a adder ripple carry issue then...?
			>> Yes, causing the pixel test to be "one extra" by using the latch clk line into U341 ANDed with DELS2ADVSPRI avoids the issue
			But it renders one extra source pixel... hmm...
			When U95:B(CLK) running at 12.2M the one extra pixel overflow render is fixed without any cascade delay compensation
			When running at 13M the incorrect leg rendering cascade issue comes back
			This is actually because the calculation result from the add and the S2nextSpriteXPixel extent check takes too long for the clock speed
			It doesn't have time to shutdown the clocks, create S2nextNextSpriteXPixel, and use that to test ahead for extent and delay the extent result by one S2CalcCLK
			This allows the scan adders to be switched off at the correct time
			The fix is to have a second adder
			>> This makes the issue fixed at 14MHz now, it gives an extra 60 pixels of scan fill rate
			** The question now is, does this extra scan fill rate justify the extra complexity?
	* Done: Problem: Also lots of sub-minimal write pulse ignored issues for U307 and U355
		Might be due to the switch between clock rates. Perhaps turn off the RAMs during the line start period
		Turned off the clock generation during the extended line start. Also seemed to fix the logic contention in the sprites2 scan RAMs.
	* Problem: For calculated pixels trying to output when the end of the scan is reached (S2_LOGICRESET) this causes write errors to the scan data at the calculated X position 
		Caused by the need to delay the S2DELVID_LINESTART for the pixel output until after the S2DOPIXEL toggle, which happen at different clock rates
		* One way to solve this might be to hold the line start low for longer, before and after the line switch and to reset the counters regardless
		Fixed with S2_LONGLINESTART
	* Note for emulation: Output pixels are delayed by 2 (more) to the right now. Due to the shifted line end
	Oscillators (for OSCCLK)
		NOTE: Sizes vary from DIL08 to DIL14
		https://www.mouser.sg/c/passive-components/frequency-control-timing-devices/oscillators/standard-clock-oscillators/?operating%20supply%20voltage=5%20V&output%20format=CMOS~~CMOS%2C%20TTL%7C~TTL&product%20type=Clock%20Oscillators&termination%20style=Radial&instock=y&rp=passive-components%2Ffrequency-control-timing-devices%2Foscillators%2Fstandard-clock-oscillators%7C~Output%20Format&sort=frequency
		>> Selection of sizes:
		https://www.mouser.sg/c/passive-components/frequency-control-timing-devices/oscillators/standard-clock-oscillators/?frequency=2%20MHz%7C~4%20MHz%7C~8%20MHz%7C~10%20MHz~~14.31818%20MHz&operating%20supply%20voltage=5%20V&output%20format=CMOS~~CMOS%2C%20TTL%7C~TTL&product%20type=Clock%20Oscillators&termination%20style=Radial&instock=y&sort=frequency&rp=passive-components%2Ffrequency-control-timing-devices%2Foscillators%2Fstandard-clock-oscillators%7C~Output%20Format%7C~Frequency
		>> Specifically DIP-8:
		https://www.mouser.sg/c/passive-components/frequency-control-timing-devices/oscillators/standard-clock-oscillators/?length=13.2%20mm&package%20%2F%20case=DIP-8&width=13.2%20mm&instock=y&sort=frequency
	* At 14.2MHz the S2FRAME6HalfX/S2FRAME6HalfY signals arrive a little late which causes the first X pixel for the "quadrant" flipped sprite to be incorrect. Ignoring this the calculation is OK at 14.31818MHz, giving an extra 71 pixels of fill rate per scan line
		Using demo9 output, removes frames 3 to 370, keeping frame 371 onwards where the letters have a large "kBaseScale = 32" "kBaseScaleMax = 26" "kPulseScaleMax = 20" scale with all of them on the same scan line... The emulations reflects the lack of draw time by missing some chunks on the right hand edges of the last sprites
		The simulation, with 14.31818MHz, does not drop any pixels, which is cool!
	
	Remember to choose "no enable" types for the oscillators
	>> 14.31818MHz wide DIP14 https://www.mouser.sg/ProductDetail/ECS/ECS-100AX-143?qs=GxOUx7aO6nydcT%252BF6wMSEQ%3D%3D
	>> 12MHz square DIP08 https://www.mouser.sg/ProductDetail/CTS-Electronic-Components/MXO45HS-3C-12M0000?qs=hbgUSdfWRJVeJrdNsQ6usw%3D%3D
	>> DIP14 wipe open frame https://www.mouser.sg/ProductDetail/3M-Electronic-Solutions-Division/4814-3000-CP?qs=IGgAdOvCTsSwgxfUvPVZeg%3D%3D
	Created SQRWIDOSCDIL14 part and package for sprites2 board
	Simulation using Demo9 output also shows valid scaled sprites2 movement
		Need to wait to see if it will render more large scaled results during the animation...
		** Done: Some frames are rendering no sprites2, find out why. Luckily one of the early frames shows this issue...
			Truncating the output after ; Frame 2 with d$0 shows normal rendering, so it's not a hardware issue?
			** But adding Frame2 data shows U313 on frame 2 gets filled with 00 or 02 and the real data is lost?!
			*** Fixed: Setting U313 _OE to be always low fixes the write issue...




* Check all 6116 writes, in audio/APU/video by setting _OE to be always low
	6264 writes don't work the same way, due to timing.
	Check with SotB demo output, including the APU simulation output, and test input data
	Video seems fine, but APU generated logic contentions as its address switch logic was a different speed
	"C:\Program Files (x86)\WinMerge\WinMergeU.exe" /f *.txt c:\temp\APUOrig\ output\




* TODO: Fix S2FRAME6HalfX/S2FRAME6HalfY signals (above).
	Could use parallel register RAMs and load 16 bits at a time, this would shorten the register setup as well...
	Or just delay the output SPRADV going to the rest of the scan logic by a clock using a 7474? To give the signals time to propagate?
		Adding one 7474 delay mostly fixes the issue. Draw time, judged by the large scaled sprite in the background, is also reduced
		Adding a second 7474 has no visible effect, except to reduce the available draw time more.
		There are still three bad lower left quadrant pixels visible, but the main offset issue is fixed
		Actually the leading left edge of most scaled sprites is fixed, sometimes there was a missing screen pixel
		Using VIDCLK the sprites still match perfectly with emulation test data




* Sprites2: "There are still three bad lower left quadrant pixels visible" from above residual issue
	Note: When using the faster MHz: Pixels output to the display at RV=83 RH=~0xd6 or ~0.015476842
	Will need to be the line before...
		Debug memory view for U307 U355
		BombJack\TestData_DebugScaledSprites.txt is updated to only include the single troublesome sprite
			b$8b
			b$40
			b$20
			b$f8
			b$20
			b$20
			b$20
			b$c0
		Interesting to note that it still displays the problem, it's also the first sprite in the list... hmm...
		With breakpoint RV=83 (the start of the line) then U355 already contains one scanline calculated, since the calculation happened the line before
		Using breakpoint RV=81 then U355 is cleared to ff and U307 starts displaying a blank line of ff with a segment of 4f starting at f8
		* After stepping a few cycles, can see $48 written to U355 byte 0 (kind of expected) but then the erroneous write $48 to $f8
		Looks like the scan X pixel counter load was triggering early on S2_LDFRAME, created a delayed DELS2_LDFRAME
			Makes sense since the S2_ADVSPRI and S2ADVSPRI were delayed
			The troublesome sprite rendering is fixed, in both fast and normal pixel clock rates
		Restore all test debug sprites data
			Fast clock rate perfectly matches (except expected last pixel in the huge background scaled sprite clock edges, but even those are on the same position now)




* Video: With the APU timed DG VSMDD2, is it able to write reliably at high speed because of the VIDCLK->counter->edge trigger timing with the video board?
	Insert a NOT for the DG and check if the other edge is also able to reliably write APU output data from the SotB demo
	Seems to be fine on either edge




* Vectors: If using 2MHz as the data write timing (not VIDCLK synchronised) then the RAM writes seem to be unreliable.
	Seeing logic contentions on VEC*D* from each of the vector data RAMs
	Using VIDCLK synchronised writes there are no logic contention issues
	* Perhaps the userport24bit timing needs to be replicated better in the video data generator?
		As the current userport board uses a 4MHz clock
		Measured 1.02us (1020ns) from address/data to _MEWR for 240ns then 530ns after hold
		For low time is 1.79us (1790ns)
			https://convertermaniacs.com/second/nanosecond-to-second/convert-1020-nanoseconds-to-seconds.html
		This results in a new 500KHz data generator model that can be used. These writes have a very long setup time :)
			0.000001020
			0.000000240
			0.000000530
			0.000001790
		This speed also misses the video timing writes, hmm
		Need a "faster userport model" to reflect the debug output timings
		Always setting _OE to low and using 1.5M with
			0.000000300
			0.000000200
			0.000000100
			0.000000600
		Does show logic contentions, but the output comparison "compareimages.bat 20" shows no differences...
			0.130472535 VEC0D0
		With _OE logic, some logic contentions, some output differences
	* Using "APU Data timing model" with _OE always low...
		Also generates logic contentions, but output comparison shows no issues
		With _OE logic no more logic contentions, output comparison shows no issues
	* Hmm APU uses:
		1MHz with:
			0.000000150
			0.000000125
			0.000000015
			0.000000390
		Lots of missed writes resulting in huge frame timings differences as it cycles around to the next frame
	>> At the moment using _OE always low, like the APU data RAM
	* Using TestData.txt with "UserPort24Bit Data timing model (faster for emulation output)" at 1.5MHz and normal plane configuration shows no issues
	Perhaps the vectors test data is trying to write as the bank is trying to read?
		Try waiting for vsync after swapping banks before writing data?
			No effect?!
			Time to analyse the write attempts more closely.
	With _OE logic and 1.5MHz data generation (DG), Logic Contention (LC) VEC0D0/1/3 @ 0.130474385 so timed breakpoint 0.130474300
		LC time changed after adding logic analyser?!
		Now @ 0.194019655 so 0.194019500
	Back to _OE = low using 1.5 MHz DG and:
		0.000000250
		0.000000125
		0.000000015
		0.000000500
		Some early LC up to 0.158888456s but running for 2.0s (simulated time (ST)) no further issues. Output looks fine too.
	Using emulation output and APU DG:
		Some early LC up to 0.131503488s but running for 2.0s (simulated time (ST)) no further issues. Output looks fine too with "compareimages.bat 120" (CI 120).
			Except:
			1032         00000036	: These look like two well rendered frames, just different frame data. The frames show regular (every 8-10 frames) of disconnect thereafter. Meaning a data write was missed for some period...
	Going to have to live with the early LC warnings I think. The timings seem to be very generous on the 1.5 MHz DG already
		Perhaps the RAM timings can be tweaked to remove the warnings?
	* New debugging attempt
		DG APU
		"Start VSM Debugging" Ctrl+F12 - VECLL1 Logic Analyser (LA) visible
		LC VEC0D9 @ 0.018816342 so "run timed breakpoint" for 0.018816000
		Hit "Start VSM Debugging" (next to pause) (getting the execution to start again after a timed breakpoint is troublesome)
		Start LA capture
	LC VEC1D9 @ 0.024234203 so 0.024234000
	Setup the simulation to break on logic contention. The DG shows line 73287 BDD6502\target\debugData.txt
		d$bffe0200
		>>d$800102fe
		d$800302fe
	* TAA=5ns stops LC. Why?
		Now it's back to: 		LC VEC0D9 @ 0.018816342 so "run timed breakpoint" for 0.018816000
		Ah ha. In a normal write, the VEC0ISA address change to VECRAMLW1 is 155ns
		However in the LC write,there is a short 65ns address glitch, followed by a 95ns address setup.
		Just before: 0.018815800
		APU PCINCR to next PCINCR time is 578.5ns
		APU MEMWR address time is 390ns
		Hmm well this is a problem. The video simulation is using MEWR to next time of 330ns, which is way too fast and it's not bringing the bus low after 390ns as configured :D
		578.5ns is actually 1.7286084701815 MHz
		0.032718431
		OK RAMs TAA down to 15ns fixes the issue
		Using 578.5n as the APU clock period fixes the timing issue and also allows the force bus to 0 to be observed.
			But the SotB demo data seems to having challenges. Perhaps it's missing a wait?
				Or seeing the wait too early due to ripple?
				Removing the w$* wrapping d$0 from the emulated output data  seems to fix the issue with a period of 578.5n
					This makes sense since the extra d$0 would technically need a write slot and this can cause the waits to fail or the at the wrong time...
				Frame 19 had a red sprite line issue, try 575n period instead
				Now frame 11
				Not affected by using _6MHz instead of 6MHz
			Using APU timing circuitry also doesn't fix the spurious red line issue
			Frame 5
			Instead of time to _MEWR 0.000000150 try other longer values?
				nope
				shorter values better...
	Simulated @Demo6 output data for 6.46 seconds




* Chars board (same design as the working chars board from PCBWay) from xinwei was mostly dead: https://www.youtube.com/watch?v=shdOwHSAbxE
	Looking at the display, the screen memory looks "OK" but the chars definition data looks bad.
	The horizontal lines could indicate a failure to access the definition memory, or perhaps a failure to shift data in the pixel shifters
	Debugging with the simulation using DG: C:\Work\C64\VideoHardware\Prototype3\just chars debugData.txt
		Rendering begins at ~0.11
	Disabling the output to CIS0 the control, by detaching it in the simulation in root sheet 6, that goes into the shifters generates very similar horizontal banding results
	The colours of the trees do come through though, indicating the initial bits are picked up, perhaps the colour RAM is also having issues
	Perhaps 4M6 will also account for the colour? No, too dark
	6N2 disable? Nope
	U17 disable? Also similar to CIS0, but colour not affected that much
	U10 disable? No
	>> Board inspection results:
		U10 is using 74LS00 and should be 74LS10
		U17 is using 74HC04 and should be 74LS04
	* Fixing U10 fixes some of the character load timing issues.
	However when DSW2 is set correctly, for the character definitions, it causes the working board to stop working
		Indicating a non-working CHEBS5 line, either short or logic contention, feeding back and killing the working board
		Checking continuity of CHEBS5 indicates shows U29 pin 7 (ICA1) is connected, when it shouldn't be.
		ICA1 is an output for the internal address to fetch char definition data address
		There is a via next to the pin... The via shows continuity, which is correct as it's CHEBS5, but it shows continuity to pin 7 which is wrong.
		Re-flowing the pin to remove the solder bridge to the via fixed most of the character definition data
		There is a single vertical pixel, roughly 3 pixels from the left edge of every character, that seems to always be set
			Also the 0 character indicates one pixel next to it on the left might always be having issues as well? But in a different plane?
		This is probably an output from one of the RAMs, less likely to be one of the shifters, but let's check in the simulation
			The boot test pattern needs flips, this would make it easier the deduce if the input to the shifters or the line inversion are wrong, or the outputs from the RAMs
		Setting 8K6D5 from IC 8K6R to be 1 in the simulation, disconnecting it, causes the red vertical line
			* 8K6D5 on the PCB has a short to VCC power, oops
				Suspect is the VIA near pin 28 (VCC) on 8H6R
		Setting 8E6D6 from IC L8E6R to be 0 causes remaining visible effect on the 0 character
			Another solder bridge at 8N6R pin 23
		
		
			
		
		
	
	
	
	
* APU: Note: BombJack\ReconcileData\ReconcileData.py
	DG using C:\Work\C64\VideoHardware\target\debugDataJustUserPort.txt
	From C:\Work\BombJack\output\DebugAPUOutput.txt
	Why is this a double write? d$9e000170
	EA break point = 0x9e00
	The DG is writing it twice?!
	From C:\Work\C64\VideoHardware\target\debugDataJustUserPort.txt
	Seems that the data before a wait is written after the wait command is executed
		d$9e000170
		w$ff03ff00,$9100b600
		d$20000203
	Fixed DG
	* But the wait seems to be taking too long?
	For example when executing this:
		w$ff03ff00,$72005300
		d$a0140139
	The write cycle, and next instruction, only seems to be ready at RH=0x5c
		Which is 9 pixels
	To get the DebugAPUOutput.txt working in the simulation with the DG needs:
		The data until the display is enabled, no waits because the display doesn't generate timing data when disabled, obviously.
		0.000000150
		0.000000125
		0.000000100
		Force output lo after time 0.000000300
		Period: 50n
	This allows the narrowly timed writes recorded from the APU to be detected while still maintaining the timings separation of the writes and the address bus returning to 0.
	The output simulates frame correctly after that.
	* TODO: Probably need a way to disable the "Early data trigger ignored" in SG and allow the DG logic to "clock" faster than the data output
	Wow, this attempted write is very narrow line 152710:
		;@time:0.086664
		;delta:0.000001
		w$ff03ff00,$24017d01
		d$9e020100
		;@time:0.086665
		;delta:0.000000
		>>>> w$ff03ff00,$24017e01 <<<<
		d$dfbe0315
	Given that VIDCLK 12.096MHz = 82.67ns
	* TODO: Might need a recording option that doesn't output a wait if the last output time is less than a certain threshold
		Debug the very short write attempt, step to see what happens. I bet the DG just misses the next pixel
		Timed breakpoint at: 0.140266 0.140267 0.140268 0.140269 0.1402695 going to need to narrow down
		DG CLK = 10n
		System->Animation options->Single Step Time: 50n to 5n
	* TODO: Actually, the recording of the write is not going to be exact because it records when the edge happened, not what the write cycle *started*
		So the playback of the recording is necessarily going to be shifted later by the write cycle time delta
	Done: For "if (realtime(time) < mNotEarlierThan)"
		Going to have to queue the transitions to .simulate and play them back later on




* Why did the APU simulation generate a write of d$dfbe0315 ?!
	When using @Demo6: C:\Work\C64\VideoHardware\target\debugDataJustUserPort.txt
	Then in C:\Work\BombJack\output\DebugAPUOutput.txt
	The EBS is 03 which is quite invalid
		;@time:0.086665
		;delta:0.000000
		w$ff03ff00,$24017e01
		d$dfbe0315
	It's reproducible with a breakpoint EBS=0x03 line 7863 time 0.086664638 so 0.086664000
		w$ff03ff00,$24017600
		d$41bc0215
	Adding a sustained write value while _MEWR is low to the recorder code fixes the EBS = 0x03 write
		But now the write is still wrong :)
			w$ff03ff00,$24017e01
			d$9e020115
		This time the data value from the APU RAM write is coming through in the write from the external attempt
		This is because the APU is trying to write a value on its internal bus at the same time the external write is happening *sigh*
	* If the APU instruction or data is selected, then slam the bus select back to the external pass through mode
		ReconcileData shows the simulation data is good now
		TestAPU.feature passes



* Check if 27C512 needs wiped sockets
* Sprites2: ROM needs ZIF socket space, or at least a socket with wipes (not precision)
* For CLK/OSC and IC components that need to be plugged in later make sure their BOM CODE is using the socket, to avoid the components being soldered.
	Add a note to the schematic (and design notes) detailing the component ordering links.
	Data sheet https://www.jameco.com/Jameco/Products/ProdDS/203625.pdf
	Start Menu\Programs\Batronix\Prog-Express
	
	
	
* Vectors: Perhaps have an independent disable in the hit MSB of the bank select, to output zeros and kill the counters?
	MSB 1 = kill
		kBus24Bit_VectorsScreen_Control_Kill in kBus24Bit_VectorsScreen_Registers
	U420:A




* Merge layer: A very small board that takes 2/3/4 pixel outputs from layers and merges the output based on transparency rules and outputs to the final video layer board. It doesn't need to be clocked since the layer outputs are clocked and the layer input is clocked.
	This would be useful when stacking several layers together, like sprites or chars layers in fixed order
	* Have one board with two 2-to-1 merges. So 4 inputs and two independent outputs
	* Merge Sprites and Sprites2
	* Merge Mode7 and Vectors
	Current _EXTCS usage:
		8000
		8800	Only @Demo10 for second Chars layer
		9000	Chars 9000, Sprites2 9200 (Using U248/U315:A)
		9800	Sprites / Palette etc
		a000	Mode7 / Vectors
		a800	
		b000
		b800
	* Vectors: It currently uses _EXTCSA000 for its registers which is the same as Mode7.
		Make Vectors detect $a100 and improve Mode7 to detect $a000
			Mode7 added 74138 U413 to differentiate
			Vectors in schematic moved to $a100 with existing differentiator
			Update Mode7 and Vectors software layer and code defines for the test to match new differentiator for address $a100
		This would allow the Vectors and Mode7 to be combined into one layer
		TODO: Update simulation to reconnect the layers with 2-1 combiners
			Copy the existing output layer headers to preserve the names
				Rename the original layer outputs, prefix with C for "combine"
				Done: Sprites and Sprites2 (in the simulation the Sprites2 are in front of Sprites)
				Done: Mode7 and Vectors (in the simulation the Vectors are in front of Mode7)
			The output headers on the graphics layers can be renamed
			The new output headers can use this naming
				Enable all the layer outputs with new names
		TODO: Update simulation to include the Sprites2 and Vectors test in the main test data
			Done: Sprites2 (ScaledSprites)
			Done: Vectors
	All done and tested



* Since the schematic now includes Vectors and Sprites2 in the visible output, add data generator animations for this
	Sprites2 done




* PCBWay sprites board seems to work OK
* PCBWay Tiles board does not. Seems to have at least one logic contention back to the data bus as it stops other boards from working when plugged in without EBS DSW. Probably horizontal pixel count logic contention, i.e. a solder bridge back to VCC/GND
	* 1. Found solder bridge on U18 pin 11 (VCC) to via (ED5) which would cause data issues on the whole bus
	* 2. Found solder bridge near U66 pin 1, two vias internal nets for 4P7R (tile screen and colour data) A5 and A6
	* 3. Found solder bridge on U4 pin 8 (GND) to via (BGYP2) which will affect Y scroll position

* Add design rules rooms using axis aligned bounding boxes, that can overlap, called VIA1..2..3..4..
	Add these rooms over any place where ICs are expected, but not the connectors as these tend to have closely pitched pads
	Add these room names using the same design rule names using 35th pad separation
** Ensure the pad to pad distance is set to avoid soldering bridges, by moving via placement away from pads
	Menu->Technology->Design Rules Manager
	Design Rules tab->Rule Name = VIA*
		Pad-Pad = 35th (This is different to the default 10th)
	Sprites2 debugging:
		When plugged in and connected, main video board and existing sprites/chars/tiles layers generate graphics without issues
		But Sprites2 has severe issues, some alternating scanline display that seems to display RAM data, but it isn't clearing
		Also adding sprites seems to cause random flickering
		Indicates significant issues
		Single sprite debug positions, does show some horrible flickering sprite data at the correct screen position
		Indicating at least some part of the position calculation is sort of OK
		* Things to check
		* Sprite definition debug data clear with all opaque data, does it alter the buggy display?
			Works in emulation, but hardware doesn't show anything recognisable with VIDCLK
			With resistor in R24 and correct palette, Time: 22:34
			Adding the full first bank of sprite data. time: 23:07, seems to render correctly
		* Touching R23-R26 stops the debug sprite flickering for one of the scan lines
			Cannot reproduce, perhaps temperature related
			Using proper resistor, R24 is parallel produces recognisible graphics data for that scanline RAM. Other scanline RAM not responding really. Time: 22:22
			TODO: Check R24 resistor value compared to others.
				Check all the resistor values with those in the sprites board
				Solder in the bodge resistor...?
				** TODO: Check other resistor values?
		* Time: 22:43 Using oscillator at 4MHz doesn't allow the low scanline start pulse to be picked up reliably (timed from VIDCLK using the pixel clock)
			Using the 14.31818 oscillator shows the working scanline has the fill rate observed in the simulation
			Time 22:48 the 16 MHz oscillator also seems to work for the working scanline
				TODO: Need to try faster clock rates!
		* TODO: Since adding a resistor on the other scanline RAM doesn't work, need to trace back from it in the schematic and see what else coould be failing
			Try adding a permanent resistor to remove that failure however?
			Check trace continuity from below and above the board...
		* TODO: Check the 6116 U355 _WE (pin 21) is getting strobed.
		* Fixed: Needed extra 300 Ohm resistors in parallel to the pullups on the first four signals for the pixel value.




* Original board connectors: http://www.mikesarcade.com/cgi-bin/spies.cgi?action=url&type=pinout&page=Bombjack.txt
	Service manual scan: https://www.arcade-museum.com/manuals-videogames/B/BombJack.pdf
	
	
	
* Options for removing the need for pullup resistors for the scanline RAMs. This is because the pullups are causing issues in the Sprites2 board again.
	When the _OE for the 74LS258 is high, this is an inverting selector/multiplexor, the pullups provide a $ff clear signal
		The tristate is also for RAM reading...
	* Instead use a 74LS540 with suitable signal on the _OE. But potential for logic contentions...
		The _OE needs to be low only on RAM _WE S2CLKB=0 and and 74LS258 _OE=1 (or _S2CLKB=1 and _OE=1)
		This is relatively simple, possibility to test with breadboard...
	It would be possible to have the 74LS540 IC and the pullup resistors in the design. Then choose to either populate the resistors or the IC in fabrication.
		It would even be possible to make the resistors socketed, given the correct pitch, and the IC socketed, to really make it configurable and easily tweakable/testable.
	Logic for U220:A and U220:B is: Enable the SRAM if the sprites are being calculated, or enable it during the visible portion of the screen where it gets cleared.
	For the left hand sprite (*not sprites2*) logic, only enable the FF output during the visible portion of the screen:
		_EHSYNC		_1V*.	_OE
		0			0		1
		0			1		1
		1			0		1
		1			1		0
		=NOT a OR NOT b
		=a NAND b
		_EHSYNC		1V*.	_OE
		0			0		1
		0			1		1
		1			0		0
		1			1		1
		=NOT a OR b
	** BombJack\Project Backups\Sprites using IC to drive FF value instead of pullups.png
		And disable the pullups...
		This works, but it also causes logic contentions as the read cycle conflicts with the write... Very often:
			Contention state CSF on net ID17. @0.000306213s
			3A_U4(!Q) =>  FF
			U78_U1(D7) =>  SL
			U428_U2(B7) =>  SH
	** For Sprites: Using two 74LS258 instead, with the same _1V*. signal as 7B:B but with NAND _EHVSYNC, and simulation disable the pullups...
		See: BombJack\Project Backups\Sprites using IC to drive FF value instead of pullups 2.png
		compareimages.bat 30 - OK, no logic contentions
			This works because it is roughly a mirror of the calculation logic.
		Both sides now, resistors removed from simulation. Both work.
			compareimages.bat 40 - OK, no logic contentions
	** For Sprites2: Adding left hand side explicit FF logic, the first frame shows differences in the far left border area (which is usually hidden anyway) due to failure to clear the far left edge during the display portion of the screen
		compareimages.bat 40 : Is OK, except frame 0 (as noted above)
			No extra logic contentions
		Right hand side done. Also 40 compares are fine, except slightly more differences on the first frame, as expected really.
		Also these logic contentions, in the right hand edge, are solved:
			Logic contention(s) detected on net S2ILD10. @0.123305199s
			Logic contention(s) detected on net S2ILD12. @0.123305199s
			Logic contention(s) detected on net S2ILD13. @0.308080255s
			Logic contention(s) detected on net S2ILD16. @0.397140315s
			Logic contention(s) detected on net S2ILD17. @0.397140315s
			Logic contention(s) detected on net S2ILD11. @0.662739680s
	** Done: Pullups for Y height need explicit logic? It's not a very used feature...
		Demux with adder output on high or 0xf signal on low
		Some single pixel differences, but nothing to worry about over 40 frames:
			0         00000012
			0         00000013
			1         00000014
			1         00000015
			1         00000016
			1         00000017
			1         00000018
			0         00000019
			0         00000020
			1         00000021
			0         00000022
			0         00000023
		Also simulation tested with @Demo1 "C:\work\C64\VideoHardware\target\debugData.txt"
		Sprites and Sprites2 PCB to V9.0
		@Demo1 and @Demo6 using "C64\VideoHardware\target\debugData.txt" passed visual check and 40 frames check
			Combiners needed to be disabled and default to Sprites/Mode7 for @Demo6 due to audio/APU memory usage showing in the vector display
	* Removed, excluded, all pullups from PCBs
	** Done: Remove single inverter for the SPRFULL signal and change the demux inputs
	** Done: Tidy components and groups
	Tested Sprites2 rendering with higher clock speeds, generally pixel accurate even on the scaled sprites, except the left hand border.
		Old and new designs do show various logic contentions at the higher clock rate however.
		Packages
		
		
		
* Audio and APU: Check comparator out and input ripple, add latch if needed...
	Related to this thread, which got me second guessing my designs again: https://twitter.com/MartinPiper/status/1536257693110784001
	Audio: Uses ! _V0ST_COMPARELENGTH to time the comparison result (U205:A) after the signals have settled
	APU: Uses WAIT_VAL17 compared with 6MHz which allows the code to decide if it compares with 0/1 clock cycle, which mitigates ripple



* Audio: Check mid-voltage reference comes from the same IC type
	$ff = 1.14V
	$80 is the digital middle = 0.53V
	Added 74LS373 and suitable resistor ladder to the analogue area of the board




* Audio: Add separate debug headers for each channel. Include GND/5V/MIDREF lines and digital debug points




* Audio: Clarify oscillator and crystal timing rate (4MHz) and C5 capacitance for this rate.
	Need correct mouser links.
	* Or add an oscillator, which might be much better :)
		Bomb Jack schematic root sheet 12 OSC1
		Replace AUDCLK and 4T/cap/res/crystal parts
		3T is the 7474 which is useful
	Note the current component links are still using the old 12MHz parts, which is problematic
	Oscillators: https://www.mouser.sg/c/passive-components/frequency-control-timing-devices/oscillators/standard-clock-oscillators/?operating%20supply%20voltage=5%20V&output%20format=HCMOS%2C%20TTL&package%20%2F%20case=DIP-8&product%20type=Standard%20Oscillators&instock=y
	4MHz part: https://www.mouser.sg/ProductDetail/CTS-Electronic-Components/MXO45HS-3C-4M000000?qs=55YtniHzbhCUVfr2tBYy8Q%3D%3D



* Proteus Placement Grid default is 50th. Changing to 0.2in is much faster to auto place. But results is slightly less IC packing.
	Push and shove
	Horizontal
	




* Current PCB six layer stackup
	Used for:
		Most designs
	Template file: Six layers.ltf
		In Design Rule Manager
			Tab: Net Classes
				Power : Trace Style : POWER1
				Signal : Trace Style : DEFAULT
	* All layers have power planes generated by hand, but only some have the plane designation. The others are designated as signal.
	Top to bottom:
		Signal	GND
		Plane	VCC
		Plane	GND
		Signal	VCC
		Plane	GND
		Signal	VCC

* Current eight layer stackup
	Used for:
		Audio
	Template file: Eight layers.ltf
		Same Design Rule Manager : Net Classes as above
	* All layers have power planes generated by hand, but only some have the plane designation. The others are designated as signal.
	Top to bottom:
		Signal	VCC
		Plane	GND
		Signal	VCC
		Signal	GND
		Plane	VCC
		Signal	GND
		Plane	GND
		Signal	VCC


* Audio: Mounting hole size issue: https://support.labcenter.com/forums/viewtopic.php?f=11&t=8204
