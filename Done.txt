* Output video signal with resistor ladder. Exclude from simulation once analog behavior has been verified.



* Removed duplicate component references that were causing incorrect auto router errors.



* Sheet 8 - Palette read/write logic



* Need a VSM model for a display that takes digital RGB + HSYNC + VSYNC
	https://github.com/MockbaTheBorg/VSMModel
	https://www.edaboard.com/showthread.php?188054-Creating-A-New-Component-(DLL)-For-Proteus-VSM
	http://fractale.gecif.net/si/logiciels/proteus/ProteusVSMSDK.pdf
	https://github.com/Pugnator/openvsm
	http://pugnator.github.io/openvsm/vsm__api_8c.html

	
	
* Interesting logic with _9A00CS 7R 6R 6S 5R 5S as it is only taking DB0-3 which implies a value 0-15 only. Hmm.
	Resulted in discovering new 0x9a00/0x9a01 functionality for sprite size select, documented in README.md

	
	
* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS2:EXTWANTIRQ
	This is because memory writes to 0x98xx can only be made when the video HW is not accessing the sprite regs

	
	
	
* Examine bus SREAD for the timing of sprite reads corresponding to the BH pixel clock and pixel output timing during the scan
	Done - Examine when the scan RAMs get cleared before sprite rendering
	Find out the reason for the first few bytes of what looks like odd data being written even when sprites are not at that coordinate?

	
	
* Add page 6 character screen logic



* Complete page 8 pixel combination logic
	page 8 - For the 153x4 ICs D3 seems to be left to float high. Which means, for those pixels it will be floating up to the last entry in the palette.
	Added a push button to cause the D3 input to be lo or high producing a nice debug purple rendering option.
	
	
* Page 7 background picture logic done



* Inspect original PCBs and look for 74 LS/HCT types to match with where possible
	https://www.jammarcade.net/tag/bomb-jack/
	https://www.jammarcade.net/images/2019/06/Arcade-DIY-46-Bomb-Jack-pcb-repair-14-19-screenshot-768x432.png
	Indicates that M74LS174P is 8B (174x2) should suffice

	
	
* _MEWR needs to be connected to the header, might need invert?
	No need an invert, active low

	
	
* To interface with the CPU, the _9800CS and _MEWR lines can be used without any more tri-state buffering, since they are not driven by the video circuitry



* 6MHz clock needs a full can oscillator part in the schematic (disabled for simulation) and layout
	12MHz Can oscillator
	https://www.mouser.sg/ProductDetail/CTS-Electronic-Components/MXO45HS-2C-12M0000?qs=sGAEpiMZZMt8zWNA7msRCvpTgpVI8f3UwUWPm0GFK9s%3D
	Needs the signal and not signal created
	DIP-8 https://www.mouser.sg/datasheet/2/96/008-0258-0-786357.pdf
	
	12.096MHz Short crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-4X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxj6PWo6GSXrZU%3D
	https://www.mouser.sg/datasheet/2/122/hc-49usx-791.pdf
	12.096MHz Tall crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-1X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxjBlVr3Wwx1PM%3D
	https://www.mouser.sg/datasheet/2/122/hc49ux-88.pdf
	
	Added JP1 to select between crystal output from 4T pin 5 when connected, or can oscillator VIDCLK when disconnected
	R1 and R2 from schematic top left page 3 are labelled R21 R22 in Proteus schematic
	
	Same as OSCCLK for CPU project, root sheet 2
	Check original schematic for inverse signal generation, it might have some offset skew
	* Schematic sheet 3, top left, shows a 12.096MHz crystal driving a 7474 dual edge-triggered flip-flop and generating _6MHz 6MHz and .6MHz
		But in the design I used .6MHz and 6MHz as the same thing, logically they are the same
		The inverted output comes from the 74368 hex buffer inverting tristate outputs
	* Added VIDCLK signal and 3T:A and hex inverted drivers 4T
	
	Breadboard https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D

	
	
* Regarding 6MHz from 4T, the trace is very long. Perhaps this is why .6MHz was created in the original schematic?
	6N2:B root sheet 6 (6N 456 page 6 bottom middle left)

	
	
* Change screen colours to exercise the 6N2:B flow



* Perhaps move the edge connectors up the board to improve component auto place?



* Instead of using ROMs, use RAMs and add extra logic to enable their write via the external header.
	* Will need 74245
	* To free up the cartridge port, think about perhaps a non-memory mapped interface, so something via the C64 user port?
		https://www.c64-wiki.com/wiki/User_Port
			* The edge connectors have 3.96mm pitch (distance between contacts) and accept cards (PCBs) 1.57mm thick.
		https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
		https://csdb.dk/forums/?roomid=11&topicid=19759
			/PC goes low for one cycle after port B access.
		http://www.devili.iki.fi/Computers/Commodore/C64/Programmers_Reference/Chapter_6/page_359.html#User
			Looks like I can have 8 bits output with PC2 signalling when it's written
				FLAG2 as input for VSYNC (NMI trigger or poll DD0D bit 4)
				PA2 as an output bit flag
			So on PA2 this can reset the state to reading a lo/hi address, then any number of bytes to store without needing the number of bytes
				C64Docs\C64PRG10_TXT.txt
					DD00
					2      RS-232 Data Output (User Port)
					DD02       56578                 Data Direction Register - Port A
					PA2 is bit 2 of PORT A of the CIA
	* Need to find out how much RAM will be needed and decide a memory map
		All the used *.bin files (mapped into ROMs) total 64K of data.
		This means a linear 16 bit address bus model won't work as there isn't space for the RAM to be mapped.
		Instead, the ten!! ROMs can be selected with an explicit chip select register combined with an address, so 24 bits instead.
		byte:
			0		Chip select using a 74154 to map up to 16 chip groups
			1/2		Lo/hi address setup
			3		Bytes to store, address++
		Done: UserPortTo24BitAddress
			Done: U6-U9 needs to load the lo/hi address as needed, when they are selected and on the negative edge of _PC
					RCO goes to ENP&ENT
					CLK needs to cause the address to count up on the positive edge of _PC and only when U10 is being populated with CS3 low.
			* U3, U10, U18 and U19 contain the chip select, data, addr lo/hi with auto increment
			Done: EMEMWRITE will need to be low for a short tick while after the data/address are stable
				Perhaps add logic to toggle this based on a delayed flip-flop chain?
				* Actually just used the after byte tick instead
				* Added a quick debug selector and RAM, to visually display the memory can be selected and written
			Done: EXTWANTIRQ, from the _VBLANK negative edge when it starts the VBLANK will need to be sent to FLAG2 (which is negative edge triggered on the C64)
		* 74154 Obsolete!?
			74139 used instead
			74138 is also available
	* 4T on sheet 3 which creates the 6MHz/.6MHz/_6MHz signals from the input VIDCLK has OE
		This output enable could be tied to a register line to enable or disable the whole display, which would massively help with writing to any RAMs for the video data.
		This could be the higher bits of 9e00?
			Root sheet 7, 4S7 could store the extra bits if it was rewired a bit. Default is low, so no video output?
			3S+3R could also be reset on low
			* Added DB5 line for 0 = disable display and 1 = enable (DISPLAYENABLE and _DISPLAYENABLE)
				This allows large amounts of data to be written to RAM while the display is disabled without fear of contention with the display HW
	* ROMs will need RAMs, the memory setup timings will need to be honoured.
		The original RAMs can be selected as per normal and can be the first line, suitable _CSEN+_MREQ can be faked for those.
			Inverted EBS0 perhaps?
		The other lines can enable or disable the ROM->RAM segments as needed with perhaps 2-3 8K chunks memory mapped on each line
			74LS245 plus 74157
	* Done: User port (write memory) timings, need to honour the expected timings for address and data setup
		Check with the logic analyser
			EMEMWRITE might not have the correct setup timing constraints
			There should be the memory and data setup, then a delayed write pulse (low) where the data and memory is still setup afterwards
				Might be because _PC is timed wrong on the input simulated data?
					* Done: Yes, the signals need expanding a bit more to include the leadin and leadout states
					* Done: Check leadin and leadout states on CIA timing diagram with _PC and data levels
						* BombJack loads 4S7 (root sheet 7) on the positive edge (trailing edge) of _MEWR with a low _9E00CS and 7432 (OR) output
							This makes sense since it might be trying to accommodate timing issues where the data might be settling during RAM cycle timing
						* Done: So update userport design to also accommodate this
							Memory and data are primed, _MEWR is held low for a short pulse, memory and data still held
							Verified by logic analyser
	* Done: Attempt RAM replacement for Root sheet 7. Read only background picture logic
		4P7 2764 can be replaced with a 6264
			_CE will need a low to select
			CS can be high all the time
			_WE low on _MEWR
			_OE low on memory read
			To select address perhaps a 74157 with _A/B based on _ADDRCS? With _ADDRCS OR (7432) _MEWR going to _WE
			74245 needed for bus tristate?
				Or maybe a simple 74373 for tri-state outputs since we don't need read logic
				The 6116 RAM on root sheet 6 has interesting _OE/_WE based on a simple NOT 7404
		* 4P7R (RAM) replaces 4P7, BusEBS.ptn added to simulate "Root sheet 7 EBS7 EA13 RAM select"
			There are some logic contentions on BIDxx at the start, but similar CID contentions are also seen on 6LM6 RAM writes from the original schematic
			* 4P7 has been schematic and placement disabled
			* 4P7R is obviously enabled
			* Only memory from 02_p04t.bin $400 to $5ff is included in the pattern file, to reduce the data specific to the sphinx graphics
				It is $100 bytes of char data, followed by $100 bytes of colour data
	* Done: Will need a replacement for the Proteus data generators because they have a 1024 byte limit
		VSMDD2 on root sheet 1 now uses TestData.txt to set all the data needed
	* Done: Root sheet 7 8R7 using 08_r08t.bin to RAM	EBS6 EA14 RAM select	$2000
	* Done: Root sheet 7 8N7 using 07_n08t.bin to RAM	EBS6 EA15 RAM select	$4000
	* Done: Root sheet 7 8L7 using 06_l08t.bin to RAM	EBS6 EA13 RAM select	$8000
	Note all new logic for the RAMs on root sheet 7. The original ROMs are still present, just disabled from the simulation and layout.
	
	* Character data
	* Done: Root sheet 6 8K6 using 05_k08t.bin to RAM	EBS5 EA14 ram select	$2000
	* Done: Root sheet 6 8H6 using 04_h08t.bin to RAM	EBS5 EA15 ram select	$4000
	* Done: Root sheet 6 8E6 using 03_e08t.bin to RAM	EBS5 EA13 ram select	$8000
	
	* Sprite data
	* Done: Root sheet 4 7J using 14_j07b.bin to RAM	EBS4 EA13 ram select	$2000
	* Done: Root sheet 4 7L using 15_l07b.bin to RAM	EBS4 EA14 ram select	$4000
	* Done: Root sheet 4 7M using 16_m07b.bin to RAM	EBS4 EA15 ram select	$8000



* Group EBS usage for the tile/char/sprite data to EBS6/EBS5/EBS4 so that all three available 8K banks are in the same EBS



* Remove the vertical flip button and associated logic? Since it's not really needed as I'm not strictly emulating an arcade board any more.
	The layout complexity can instead be used for pixel level scrolling and the extra timing generation

	
	
* Background layer (root sheet 7) pixel fine scrolling enable?
	Could have an extra register $9e01 (l/h nybbles for x/y) that add values 0-15 to the X/Y pixel clock before addressing the background data?
		This could in effect generate a pixel scrolled background image?
	* For 6S7 and 5S7 timing
				cba9876543210 = Address at 4P7R/4P7
		_SL2	0010010100111
		4x6MHz clocks
		_SLOAD	0010110100111
		4x6MHz clocks
		_SL2	0010010101000	*
		4x6MHz clocks			*
		_SLOAD	0010110101000	*=
		4x6MHz clocks			*==	One 16x16 tile being loaded, character/tile index then colour
		_SL2	0010010101000	*=
		4x6MHz clocks			*
		_SLOAD	0010110101000	*
		4x6MHz clocks			*
		_SL2	0010010101001
	* Signals that need handling: XXH' and XXV' plus 4H, SLOAD and _SLOAD (which trace back from BIS0)
		Added new signal prefix BGH for these by copying the logic from root sheet 3
		Initial tests of the X nybble write seem to indicate success!
	* TODO: At this point, could do with a DigitalData wait for edge (for _VBLANK) and output new data code
	* X and Y pixel scroll logic added

	
	
* Need some extra logic (and control bit) to hide the gaps behind slightly contracted borders (just like the C64)
	U65 has spare two bits 6/7, if 1 then contract the Fair right and bottom borders respectively
	X & Y Border shrink works





* When running at VIDCLK 6MHz, the target speed, the sprites fail to render correctly.
	This is because Root sheet 5 4A/4B/4C/4D/ have by default 200ns address access time.
	They are 4 bit RAMs, obviously the original hardware was slightly exceeding the 166.6 ns timing from the 6MHz clock
	Verified that if the default 200ns is changed to be 100ns then the sprites start displaying again
		* It is interesting to note 8K replacement 6264 RAMs are all 100ns address access time
	They only use A0-A7 internally
	Consider using 8 bit RAMs with lower access times instead
	The next viable RAM would be: https://www.jameco.com/z/6116P-70-Major-Brands-IC-6116P-70-CMOS-SRAM-16-384-Bit-2Kx8-70-ns_242675.html
		This can be simulated and it is still able to be ordered.
	Running a 12 MHz VIDCLK with 70ns address access time results in some corrupt sprites at their correct positions
		Running with 10 MHz VIDCLK (49.2 FPS) means the sprites render correctly.
		With 50ns address access time the sprites render correctly.
		(See Root sheet 5 with 6116 RAM for sprite spans for an example)
	* TODO: Split the 2114 RAMs into two or more, based on their low address, to interleave the bit accesses
		Might have to latch the address and data to hold the address and data for longer, have 2 or 4 latches?
		This latches will need to use the low address lines to decide which chip to enable for read/write
	http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html
		Note: No address setup time
	http://www.ukvac.com/forum/bomb-jack-pcb_topic368665.html
	* TODO: Study the memory, data and WE access patterns to plan for the best strategy
		From about 1.33 seconds into the simulation will be the middle of the frame
		Note: VSMDD3 on root sheet 5 setup to record the:
			Address
			Byte
			D24 _write
			D30 0 = Output pixel data to the screen and clear to ff, 1 = reading/writing sprites
			D31 _CE
			Clock start time 1.33
		Note: 4C4DRecording.txt
		Note: The first few thousand lines were trimmed to align with the start of the d$4 phase
		d$0 indicates _CE and outputting pixels to the screen
			So the following:
				d$0100ff08
				d$01006f08
				d$00006f08
				d$0000ff08
				d$0100ff09
				d$01006f09
				d$00006f09
				d$0000ff09
			Note the address counts up, reads, then quickly writes ff, note the data is not stable during the _WE
		d$4 indicates writing sprite data
			Using TestData.txt "Top left all the same" it's possible to see the same address range 0-f repeatedly being used
			4D (ID4-7) starts to get 77...
			4C (ID0-3) still shows ff...
			So the following:
				d$4100ff00
				d$4000ff00
				d$40007f00
				d$41007f01
				d$4100ff01
				d$4000ff01
				d$40007f01
			Indicates that the RAM will consume the written data even after the 6MHz negative edge, basically when it's low
				However note that the address is stable
		Perhaps on _WE, the relevant latching address hold and write hold can hold the WE low for the relevant RAM whilst the new address switches to its read mode
		Once the address switches to read mode the WE is not held low
		* In Test2114 project, using the 10MHz VSMDD3 recording only half of the bytes are visible in the 2114s
		* Now the VSMDD3 clock is at 100MHz, now the 2114s do show both halves are written to.
			It shows there is some high-frequency interaction going on that needs study.
			Which is visible in the recordings:
				d$0000ff00
				d$0100ff00
				d$0100ff01
				and
				d$40007f00
				d$41007f00
				d$41007f01
			Note the very quick (<10ns) write address 0, then read address 0, then read address 1
		* 4C4DRecording output pixels.txt
			Been created to start with pixel output and clear
		Note however the high frequency variance in address lines:
			d$41007f01
			d$41007f03 <<<
			d$41007f02
		Probably due to 6C/6D 74163 counters displaying a non-stable ripple output
			Solved by adding U77/U78 74273 that use _VIDCLK for CLK to latch the address inputs a short time after the counters have finished
				See StableSpriteScanAddress.png
			Note the recording now shows a stable address lagging behind 21/22 lines (210/220 ns) plenty of time for the signals to settle
			Visually the output sprite pixels do seem to be a little bit better formed, more regular
			Unfortunately, this latch lag means even VIDCLK at 4MHz shows the "purple bars" corruption, due to the late arriving address compared to the data
			Without the "fix" at 4MHz the sprites display correctly.
		https://www.mouser.sg/Semiconductors/Logic-ICs/Logic-Comparators/_/N-cbost?P=1z0y33v&Keyword=74ls688&FS=True
		* Test2114
			* TODO: If _6MHz (writing) and IDA0 then use memory, memory _WE needs to be held low for longer than _6MHz, enable write latch signal, also latch data to write to memory, also U2 load address and U9 load data, and output enable U9 for cached output
			* Done: If 6MHz (reading) and IDA0 and IDA=C0A then bypass memory and output enable U9
			* TODO: If 6MHz (reading) and IDA0 and IDA!=C0A then use memory, bypass U2 and U9, select raw memory signal 74257, reset any write latch for memory and output enable select memory
		* Going back to testing the 2114 chip access timing profile:
			With the Proteus defaults then 6M is about the limit, however using 2114AL-1 values ( http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html )
				{TAA=100ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
			Then 8M is the limit (with a single pixel vertical line duplicating the background near the right hand edge)
			With 9MHz no sprite data is visible, then changing to use:
				{TAA=100ns}
				{TCE=10ns}
				{TOE=10ns}
				{TOD=10ns}
				{TWP=10ns}
				There are only some bad pixels, but hardly anything visible.
				Instead changing to use:
				{TAA=75ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are visible correctly again. It seems as though the TAA access time is what is important.
				The above takes the VIDCLK up to 10.5M. At 11M there is a purple vertical bar near the top left edge, but most sprites are still visible.
				At 11M using:
				{TAA=70ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are correct.
				At 12M some sprites display doubling or missing line corruption.
				Using this:
				{TAA=60ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are fine at 12M = 59.2 fps
				10.1M = 49.8 fps
			Back to 2MHz and all is well. Test2114 indicates that a write through caching version of a 2114 would work as a daughter board to the 2114 socket, if needed.
			The unstable addresses from the counters could be handled by more than two cached lines. In the real hardware they may cause spurious reads or writes in the RAMs.
			So for now continue to assume that modern real world 2114s are as fast as those used in the original hardware decades ago.
			The Proteus 2114 model could do with some checks to see how fast it really can write according to finely controlled timings.

			
			
* Use the DigitalData negative edge wait to add a horizontal scroll test




* Demo animation for sprite and scrolling
	TestData.txt updated to include display register updates for each frame
	cd /d C:\Work\BombJack\output
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug.gif && debug.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 384x264! debug.gif && debug.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug2.gif && debug2.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 384x264! debug2.gif && debug2.gif
		Using this option is good with 3072 x 264 in the VSMDD digital display
	For the hires schematic: c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 768x528! debug.gif
	This demonstrates horizontal and vertical pixel scrolling, using a variation on the original Bomb Jack hardware. Extra screen banks are updated into the new graphics RAM to update the tile positions. One sprite is updated too.

	
	
	
* Double check the exact input clock rate and logic with the original schematic for running at the required frame rate
	12.096MHz

	
	
* Replace the 2114s with a single 6116
	Here we have very fast memory: https://www.mouser.sg/Semiconductors/Memory-ICs/SRAM/_/N-4bzpt?P=1z0z63x&Keyword=6116&FS=True
	* Going back to testing the 2114 chip access timing profile
		With the Proteus defaults then 6M is about the limit.
	* With 6116 defaults then 8MHz is about the limit
		However 20ns access time can be found: https://www.mouser.sg/ProductDetail/IDT/6116SA20TPGI?qs=sGAEpiMZZMt9mBA6nIyysK6VW3GrAnba45Kc6Apw0Go%3D
			* https://www.mouser.sg/datasheet/2/464/IDT_6116_DST_2014115-882651.pdf
	* Using these speeds in Proteus:
		{TAA=19ns}
		{TCE=11ns}
		{TOE=10ns}
		{TOD=8ns}
		{TWP=12ns}
	* The old 2114 4A,4B,4C,4D have been disabled/excluded and replaced with two 6116 U77 U78 instead

* Auto place OK



* Using the logic analyser, measure the _VSYNC and _HSYNC timings and compare between the original at 12.096 MHz and the higher resolution version at 24.192 MHz
	A2	_HSYNC
	A3	_VSYNC
	A5	VBLANK
	Logic analyser capture on _VSYNC (A3) positive edge
	Using 2u capture resolution.
	From the original schematic:
	First A3 negative edge 16.25 mS
	Next A3 negative edge 33.02 mS
	First A5 negative edge 1.02 mS
	Next A5 positive edge 15.24 mS
	Next A5 negative edge 17.78 mS
	A5 positive edge to negative edge 2.54 mS
	A3 positive edge to A5 negative edge 1.02 mS
		A2 negative edges between 16
	A2 negative pulse length 16 us
	Negative edge A5 to negative edge A2 8 uS
	A2 positive edge to positive edge 64 uS

	
	
	
* With faster sprite RAMs being used, it might be possible to expand the horizontal resolution of the whole screen to be 512 pixels :D
	Extra bytes would be needed, $9900 or $9a00 and extra 2114 RAMs to load in parallel to the high-X pos value load per sprite
		Maybe use bit 4 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?
	Initial tests of adding an extra bit to the H values works quite well.
	At 24.192MHz then 3E and 3F need to be made faster, replace with 6116 instead?
	The timing for sprite register colours is quite tight though. Also there is going to be extra memory needed for the char screens.
	Reverted the change for now, needs more pondering.
	* First change all references to *256H* to be *512H*
	* Change *ZZZH* to *512H*
	* Then create the _512H to 512H circuit
	* And tackle the HBLANK timing test
	* Tweak background address lines to reduce the number of screen but increase the horizontal resolution using 256H/512H as appropriate
	* Add extra sprite scan address line
	* Add extra sprite registers address lines
	* Add extra byte for MSB for each sprite from $9900, to be loaded when the sprite X pos is loaded
	* 6LM6 6116 needs to be a 6264 for the AB11 and to use 256H' the lower address bits will need to be shifted up
	* Test project: Bomb Jack 512x256 test 48 sprites.pdsprj
	* Sprite and char screen logic done
	* Done: Tile screen logic, there will need to be some 256H handling to addresses as it is currently missing
	* TODO: Instead of VIDCLK = 24.192 MHz going into the 3T:A 7474, could instead use VIDCLK directly into 4T
	* Done: Sprite register 3E/3F loading address is different in hires compared to lores?
		Yes, they start at $9840 not $9820 according to the logic analyser
	* 6264
		https://www.mouser.sg/ProductDetail/Alliance-Memory/AS6C6264-55PCN?qs=sGAEpiMZZMt9mBA6nIyysDfDw0vDQxSwL3Jgh6owPVw%3D
		https://www.mouser.sg/datasheet/2/12/Alliance%20Memory_64K_AS6C6264v2.0July2017-1144693.pdf
		{TAA=55ns}
		{TCE=55ns}
		{TOE=30ns}
		{TOD=20ns}
		{TWP=45ns}
	Created 2114FAST, 6116FAST and 6264FAST to reflect timings in datasheets and empirical values for 2114
	* Done - 3E/3F could use one 6116 instead
	* TODO: There is a strange sprite colour corruption when running at VIDCLK = 24 MHz
		Output from 7E and input to 6E matches
		Output from 6M MV0-3 is sometimes out of sync
			Tried configuring very fast RAMs 7JR 7LR 7MR did not fix the issue
			TODO: Signals going into the above RAMs? Use VSMDD5
			VSMDD6 shows O0..7 is OK
			VSMDD5 shows C0..12 is sometimes wrong
				Which bits are mostly wrong?
				C0..4 are OK
				C5..8 are sometimes wrong, which?
					C5 always 0 when wrong at 24 MHz
						MD0 or 16MH? S?
							S seems to be late sometimes?
								5R or 5S late/wrong at high speed? Disable and test. Does not seem to fix the issue.
				C9..12 are sometimes late, but no wrong signals detected
	* TODO: At the moment it looks like the timing is too tight for 512x256 hires

	
	
* Update the standard resolution schematic to use 2114FAST, 6116FAST and 6264FAST
	Test with 12.096 MHz VIDCLK

	
	
* Standard resolution: 3E/3F could use one 6116 instead



* Disable 5F and the screen fills with sprite data, this obviously disables the Y pos range check.
	This could be easily configured with a sprite Y pos test register bit to allow full height sprites with repeating patterns.
	3E/3F are the sprite register RAMs, it's possible to read extra data from $9900- and an extra RAM to feed this daft idea cheaply
	Maybe use bit 5 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?

	
	
* Last plane, it's a latch for pixel colour from palette
	Can up dated during screen time by a copper
	Use similar for $01 $9e03 to store this?
	* Added U81 for BBCL0-7

	
	
* 4 bit adds for tile plane ($9e02)
	The demo has been updated to use this instead of duplicating the screen data in different banks with a shift

	
	
	
* There is also the possibility to allow the horizontal pixel clock and/or the vertical raster position to be read via a latch and suitable address chip enable logic of an 8 bit latch
	* Alternatively, have a "copper" mode on the interface logic board?
	* To test this, the digital data part can be expanded to accept more inputs for RH and RV, no need for _HSYNC with this remapping model
	* Done: Need wait for X/Y pos in DigitalData, added some test data patterns for copper bars and split sprites

	
	
* To get multiplexed sprites working, the sprite logic seems to need to be disabled to avoid spurious data bus reads
	Or the data bus writes need to be precisely timed, with a proper copper, to coincide with periods where the sprite registers are not being read
	See: TODO: While this works, it needs a proper copper



* Alternatively, have a "copper" mode on the interface logic board?
	* The mapping of the RH and RH values and CLK to a header could allow RAM to output defined signals to the ED, EA, EBS output.
		The RH values could be divided down to only trigger during _HSYNC for example
		Or it should be possible to program a "mapping" memory for RH and RV, that defines when/how the real "copper" memory can be accessed.
			This could translate into addresses that are logically ORed into a final lookup address into the copper.
		This could be selected by a particular EBS mode, perhaps even the idle 0x00 or maybe the 0x02 mode?
		Setup of this memory will have to be done during the _VBLANK to avoid visible artefacts, writing takes priority.
		* TODO: Idle EBS mode would be good, the user port interface can be tweaked to disable all outputs to DB/AB/EBS etc when EBS == 0
		* TODO: Digital data would need an output disable mode for certain pins, the copper could then be added as real extra logic from the main board
			* EBS would obvious need to be maintained as output with 0 to stop the whole board chip groups being selected at once
			* Or to emulate, the DigitalData could have an extended output value command that accepts override data setup and _MEWR timings
		Old DigitalData clock=500k
			TOLOW=0.00000025
			TOHI=0.0000005
		Now using clock=2M
			TOLOW=0.000000125
			TOHI=0.00000025
		* Note: At 2M the sprite multiplex split is very small and does not interfere much with the video output
			* This means it might still be possible to emulate and find safe spots for the sprite register writes, needs experimentation
			* There are no safe spots, the sprite RAM is constantly read during the scan frame
				$9a00 Upper nybble: $10 = Enable sprite output (6S SPREN), works by resetting the contents of the sprite shifts on low
			* Success! Examining the rendered output the tall stretched sprites not yet updated are visible without artefacts

			
			
* Investigate latched writes to the background colour. It's not entirely stable if the copper bars move up and down?!
	* A double write to "d$9e0301XX" seems to fix the issue? Is this because the address should be maintained, not incremented?
		Or is it the horizontal timing position that is just right?
	* Perhaps, a second sprite register RAM can be used, while one is being read the other can be written to?
		Perhaps not, it would need quite a bit of extra logic to isolate the DB and AB
	* Fixed a bug in DigitalData where waiting for an input value caused the first value to be skipped
	* Double writes removed from the data generator, the display still renders correctly


	
	
* Introduce extra colours bars.
	TODO: Some of the frames show some colour bar sparkles visible on the left of the screen in the blue area of the scrolling top screen?
		Why? How?
		Shifting the first colour change on the left over 32 pixels seems to have vastly reduced, but not entirely removed the problem.
		Might it be one of the colours from the last or first segment? It seems to move with the bars?
		* Test a full run without auto-increment addresses during the colour bars
			Sparkles still happen.
		* Try using this for the first colour bar position: file << "001000" << std::endl;
			With d$9e000120	; Disable the tile screen
			With the DigitalData clock input = 2MHz this shows how interaction with the 12.096MHz video clock introduces some timing variance on the left vertical bar
				Changed the clock to be the Q2 (divide by 8) output from a 74161 and VIDCLK clk input
				This fixes the timing variance on the left colour bar
				TestTileDisableRapidColours.txt indicates this equates to colour changes at precisely every 4 pixels, as expected.
					Useful data for a hardware copper...
		* Using the Q1 (divide by 4) output from the 74161 and the display demo is stable, and rapid colour writes are now at 2 pixels resolution
			Also very useful data for a hardware copper
		* Try running with this new clock input
			Up to frame 275 it all looks clear!
			All frames look clear.


			
			
* 7483 no longer made? Change to 74283 with different pinout.



* GenerateData2
	Add a simple (naive) multiplexor test using WaitForRaster() to then reset the sprite used back to the first if there is enough gap



* Board separation preparation work
	* Need to rationalise and reduce the memory decode logic single pin nets (Design Explorer root sheet 10)
		_WRAM0
		_WRAM1
		_ROM0-4
		_RAM0-1
		WAIT
		_8800CS
		_8C00CS
		Above all removed
	* Using Design Explorer->Net->Type: Single Pin Class: SIGNAL, these are all in need of checking
		BBCL7	Last colour of the "background" colour, U82, part of the tiles board, root sheet 7
				Since this feeds directly into the pixel combinatory logic, then removing the chip would allow the "background" to be set by a mode7 layer etc
		BGHSS	Root sheet 7, it comes from the updated SS related logic from root sheet 3 (for SL1, SL2, SW etc) that generates the background tiles signals with the X/Y scroll values
				SS is used by the character screen, not the tiles, so it is really unused. Removed.
		HBL		Unused, root sheet 3, removed. Not useful like the _HSYNC and _VSYNC, since the copper can read RH0-8 and RV0-7
		ISAB7	Root sheet 4, sprite logic, last unused pixel colour
		_BGHSL1	Unused by the tiles, same as BGHSS origins, from the tiles x/y pixel scroll update. Removed.
		_BGHSW	Unused, same origins as BGHSS and _BGHSL1. Removed.
		_SW		Root sheet 3, unused. Removed.
	* Created _EXTCS8000-B800 lines which can be moved to a header from the main "Video gen, pixel clock timing, final mixing output" board
		Created header INRAMSEL1
		Note: _9000CS renamed to _EXTCS9000
		* _EXTCS9800 logic that decodes the _9800CS, _9A00CS, _9C00CS, _9E00CS duplicated on each board that uses these
			_9800CS root sheet 40	(Sprites)			U86:A
			_9A00CS root sheet 30	(Sprite size logic)	U88:A
			_9C00CS root sheet 80	(Palette)			U87:A
			_9E00CS root sheet 70	(Tiles)				U88:A
	* Merge _CSEN and _MREQ and remove
	* Sprite size logic now moved to root sheet 40

	
	
* Part 7N Outputs... Moved to sheet 50 and and split to sheet 80 (U33)
		_256H*.		Sheet 50
		256H*.		Sheet 50
		1V*.		Sheet 50
		_1V*.		Sheet 50
		_CMPBLK*.	Sheet 80

* SS from sheet 3 1T output 11 was wrong, the 1T 13 input was only connected to 1S 2 input and not connected to 2T 4 output
	SS			Moved to Chars board sheet 60
	_SL1		Moved to Chars board sheet 60
	_SL2		Moved to Chars board sheet 60

	
	
* Board connectors
	https://sg.rs-online.com/web/c/connectors/pcb-connectors/idc-connectors/
	https://sg.rs-online.com/web/c/cables-wires/ribbon-flat-cable/flat-ribbon-cable/
	Perhaps it's going to be better to split the boards into video generation and combination logic, char screen, tiles, sprites and mode 7?
		Video gen, pixel clock timing, final mixing output
			This needs a header for each pixel for the mixer
		Chars
		Sprites
		Tiles
		Mode7
	* Use the following properties, which can also be set as "Group" in the Design Explorer
		{GROUP=Video}
		{GROUP=Chars}
		{GROUP=Sprites}
		{GROUP=Tiles}
		{GROUP=Mode7}
	* Figure out how these signals need to be exposed:
		Done
			SLOAD
			_SLOAD
			CMPBLK
			_CMPBLK
			_MDL
			_CDL
			_VPL
			_256H
			BGBORDERX
			BGBORDERY
			DISPLAYENABLE
			_DISPLAYENABLE
		TODO
		No need (internal to a single board, or all on headers already)
			_VBLANK
			_MEWR
			16HSPR



* Automatic detection of missing routing across board boundaries and filtering with a known list of header points
	It should be possible to parse the IPC file and the Pre-Production Check output
	IPC example lines:
		P  NNAME00002 D0.00002
		P  NNAME00035 D0.00035
		317NNAME00002       U1    -2   MD0762PA00X-090170Y+007620X1270          S0
		317NNAME00035       U2    -2   MD0762PA00X+012700Y-001270X1270          S0
	Pre-Production Check lines:
		Missing connection: U1:2, U2:2
	Steps:
		Parse the NNAME00002 and NNAME00035 from "U1:2", "U2:2" mapping to "U1    -2" and "U2    -2"
		Resolve the NNAME00002 and NNAME00035 to "D0.00002" and "D0.00035", note common prefix
	CheckConnectivity tool
	// "C:\temp\Proteus\test multi board.IPC" "C:\temp\Proteus\Pre-Production check.txt"
	// "C:\Work\BombJack\V3.0\Bomb Jack.IPC" "C:\work\BombJack\V3.0\Pre-Production Check.txt" "C:\Work\BombJack\HeaderNets.txt"
	Using the V3.0 files, deliberately creating an "EEK" net with components across two boards, I see:
		Final report
		EEK                  From: U99:1,U98:6
	So it works well, even the component pins are correct.


	
	
* Move the "background colour" logic and latch to the video generator layer?
	This might allow the mode 7 layer to be added as well?
	* An extra layer can use the LAYER 4 header, which is pixel 4 (background colour) from the tiles board.
	
	
* Check the layer memory select logic, mostly layers should not need a full header but instead have select lines for their video RAM etc.
	* For now, the full headers can be retained, they supply a good consistent connection point that can be stacked, or ribbon cable connected
	* If needed for extra flexibility the EBS[0..7] lines can be connected with individual wires to allow other layers to be added at different addresses.

	
	
	
	
* Connect the last palette line giving more colours?
	6A2, 6B2, 6C2 do have A9 free, so it can be used for an expanded palette
	5E2 has some interesting logic with pin 3 (D0) being _CMPBLK*. and then the D0 output going to MR, but why is this needed?
		It seems overly complex to me, perhaps it's related to edge of screen pixel clearing logic?
		But we already have 7A2 8B2 using ENABLEPIXELS as MR?
			This does however only kick in when the borders have been shrunk, for scrolling for example
		* The _CMPBLK*. logic is there to turn off pixels at the screen edges, otherwise we get horizontal overscan screen tiles being rendered.
			Note, the tiles are rendered using incorrect memory locations
			This is used when the border shrink X/Y bits are not enabled.
		* TODO: Investigate if the _CMPBLK*. logic can instead feed into ENABLEPIXELS, freeing 5E2 pin 3 (D0)
			_CMPBLK*. goes high at HV$8 and low at HV$188 indicating (again) the pixel output logic is shifted 8 pixels
			* U67:A now combines the VBLANK, border shrinks and _CMPBLK*. and frees the line on the 5E2
			* Extra colour logic all connected
			* Tools updated to handle 32 palettes of 8 colours each



* Mode 7 display from DigitalDisplay\TestJig\Design7.pdsprj
	For the memory address space decoding to latch load signals, it could use similar logic to that observed in U70, U66
	As long as the data is read on a positive edge
	* Perhaps the background colour logic can feed into the combination board?
	* Initial logic and test data with ROMs added, it seems to be working quite well
	* Done: Added some generated dx and dy delta values, it doesn't quite rotate all the way around, probably to do with the wrong dy being used. Check the animation...
		Note: "; Trying rotates" in BombJack\TestData.txt which demonstrates the four quadrants
			At least I've figured out what register values result in 0/90/180/270 rotations now
			Note working calculations for intValue in BombJack\GenerateData\GenerateData.cpp
	* Done: Need to test for empty pixel $00 and replace it with the background colour
		Use the same address as the tile? This will need slightly more logic, but will retain compatibility with existing data
		Or just use a new address? The generated data will need updating.
		* Used new address $a01401
	* Choose between 32 16x16 or 128 8x8 tiles?
		Depending on logic constraints, it might be possible to select the relevant RAMs simply
	* Add extra map select coordinates, extra 4 or perhaps 8 bits, make the map wider
	* Add offset l/h/hh loads for x/y origin values
		Added "LDXORGL/H" note "; Trying mode7 xorg writes" seems to work
		Added "LDYORGL/H" note "; Trying mode7 yorg writes" seems to work
		74HC138 used
			Addresses spaced out allowing HH value to be used later
			Now allows a 128x64 tile screen, uses 8192 bytes
		* Done: Sheet 10 needs three more interleaved graphics fetches
	* Done: Add extra logic to use RAMs not ROMs

	
	
* Mode7 pixel calculate and output was reduced from 4 to 2 stages. Significantly reducing the complexity.



* Mode7, root sheet 10: Need to add pixel output header and common pixels/signals/address/data bus inputs headers




* Make boards top silk text V3.0



* Connectivity check shows missing:
	_HSYNC               From: J1:1,U181:1
	_VSYNC               From: J1:2,U120:1
	* Add to video headers

	
	
* Using the same x/y flip inverter trick for the mode7 tile lookup, it might be possible to add support for these in the map
	Especially now since the output pixel complexity has been reduced and there are 32 tiles

	
	
* Where 6264FAST is used, the _OE = NOT _WE is not good. the _OE should be a NOT of the NAND EBD, EA instead
	Very strange timing contention issue when two 6264FAST are on the same output regarding _OE
	* Update 6264FAST _OE _WE logic to improve write stability timing

	
	
* Also check 6116FAST _WE _OE timing
	Simplified _MERD logic, by removing it entirely. We do not want to read any internal RAMs, only writing is needed.
	Far fewer logic contentions now

	
	
	
* Logic contentions remaining:
	Caused by the palette RAM read/write switch
	Contention state CSF on net ED0.
	$ILOGIC ANALYSER#0109(B20) =>  FF
	2F_U2(B7) =>  FF
	3L6_U2(A0) =>  FF
	7B2_U2(B0) =>  SH
	7C2_U2(B0) =>  FF
	VSMDD2(D0) =>  SL
	Contention state CSF on net ED1.
	$ILOGIC ANALYSER#0109(B21) =>  FF
	2F_U2(B6) =>  FF
	3L6_U2(A1) =>  FF
	7B2_U2(B1) =>  SH
	7C2_U2(B1) =>  FF
	VSMDD2(D1) =>  SL
	Contention state CSF on net ED2.
	$ILOGIC ANALYSER#0109(B22) =>  FF
	2F_U2(B5) =>  FF
	3L6_U2(A2) =>  FF
	7B2_U2(B2) =>  SH
	7C2_U2(B2) =>  FF
	VSMDD2(D2) =>  SL
	Contention state CSF on net ED3.
	$ILOGIC ANALYSER#0109(B23) =>  FF
	2F_U2(B4) =>  FF
	3L6_U2(A3) =>  FF
	7B2_U2(B3) =>  SH
	7C2_U2(B3) =>  FF
	VSMDD2(D3) =>  SL
	Contention state CSF on net ED4.
	$ILOGIC ANALYSER#0109(B24) =>  FF
	2F_U2(B3) =>  FF
	3L6_U2(A4) =>  FF
	7B2_U2(B4) =>  SH
	VSMDD2(D4) =>  SL
	Contention state CSF on net ED5.
	$ILOGIC ANALYSER#0109(B25) =>  FF
	2F_U2(B2) =>  FF
	3L6_U2(A5) =>  FF
	7B2_U2(B5) =>  SH
	VSMDD2(D5) =>  SL
	Contention state CSF on net ED6.
	$ILOGIC ANALYSER#0109(B26) =>  FF
	2F_U2(B1) =>  FF
	3L6_U2(A6) =>  FF
	7B2_U2(B6) =>  SH
	VSMDD2(D6) =>  SL
	Contention state CSF on net ED7.
	$ILOGIC ANALYSER#0109(B27) =>  FF
	2F_U2(B0) =>  FF
	3L6_U2(A7) =>  FF
	7B2_U2(B7) =>  SH
	VSMDD2(D7) =>  SL



* How about lo/hi registers for tile background char address offset to enable hardware scrolling?
	Added, but the left border needed to be brought in by 4 pixels

	
* Can the right border be pushed out by 4 pixels?
	Yes!

	
	
* Removed old redundant ROMs




* Mode7 tiles to 64 instead of 32? Would need more RAMs
	The write logic works, but the output logic has contentions. Going to need a 2 to 1 selector 74157... Tried 6MHz strobing the _OE, no better.
	* Is this causing the output pixel corruption visible when the line has >= 32 tile index present?
	* Hmm no, a selector 74157 on >=32 tile index, did not work either. So it doesn't look like an output from RAM data hold issue?
	So what could it be? Mathematical?
		Not mathematical, one of the tile RAMs on the second pixel phase was in contention with the other tile RAM, even though _CE is exclusive
		The contention value was being read by the output latch
		So separated the two input ED0..7 bus inputs with an extra 74373

		
		
* Align the 3 bus headers in the video cards with UserPortTo24BitAddress.pdsprj



* UserPort: On reset of the state clear all output values to zero instead of needing to send 0 bytes to clear them all. See reset24BitBus
	Use bus write pulse to zero output when not active

	
	
* Twiddle the mode7 HV flips to align them with tiles




* It springs to mind that I should perhaps hook this up to a 6502 emulator with a "realtime" emulated display to help prototype games/demos.
	* Display container
	* Write data method, calls write data events in layers
	* Calculate pixel method, at current H/V position, advances to each pixel
		* Takes VBLANK and border shrink into account
	* Maintains the image X/Y, which are different to H/V
	* Add layers
		* Write data event
			* Can set a bus contention timer (in pixels) to allow simulation of display artefacts
		* Get pixel index event includes H/V display registers
	* Mode7, tiles and chars tests work well: https://twitter.com/MartinPiper/status/1251190688173027328
		Code: https://github.com/martinpiper/BDD6502/commit/061eaa68c0dedacdcd5d0586308e5bffdee34ec8

		
		
* Spot common section in the output music events file and add a new command to "gosub" to a start/end offset section
	First test run: saving=41620
	This is based on byte stream data compression, it isn't taking into account the command lengths
		This means the buffer will need shuffling around when a match is found to enable the next searches to use real in memory data including the new compressed chunked
		The buffer will also need to be pre-scanned to find a suitable escape byte
		* With all the above: saving=37059
			The reduced saving is expected due to some of the duplicated existing data being detected has been removed
			There are 5 levels of recursion here
		* With escapeByte handling: saving=36898
	* Single pass savings: saving=24686
		Multiple pass decompression is going to be hard in 6502 with limited RAM
		With escapeByte detection: saving=24693

		
		
		
* Audio board - Audio.pdsprj
	* BDD6502\src\main\java\com\bdd6502\AudioExpansion.java
	* Target 4 voices, for one channel output, 
	The 8K sample RAM can be populated using the output from C64\VideoHardware\target\debugData.txt
		* Done - Needs expansion to the full 64K
	* Audio registers, latches, are needed
		Starting to connect voice 0, the latches so far read the correct values
		All voice 0 latches work, loop mask and active mask also work
	* voiceInternalCounter[voice] += voiceRate[voice];
		with V0ST_ADDCOUNTER phase
	* voiceInternalCounter clear on voice inactive
	* TODO - voiceInternalChooseLoop will need the result of length comparison
	* HW: Note selective reset of only some adders when length is reached
	* Can use data: ..\C64\VideoHardware\target\debugData.txt
	* Or TestAudio1.txt
	* For comparison: http://www.ti.com/lit/ds/symlink/sn54s85.pdf?ts=1591365901295
		Comparison output works
		Now needs to process the result comparison at the appropriate time, after the output has a chance to be stable
			V0INTCOMPARELOOP latch works
			Need a suitable input to the counter latches
				V0ST_COMPARELENGTH	| VOICEACTIVEMASK0	| V0COMPISGE	| output
				0					| 0					| 0				| 0
				0					| 0					| 1				| 0
				0					| 1					| 0				| 1
				0					| 1					| 1				| 1
				1					| 0					| 0				| 0
				1					| 0					| 1				| 0
				1					| 1					| 0				| 1
				1					| 1					| 1				| 0
			https://www.dcode.fr/boolean-expressions-calculator
				Using: (!a && b && !c) || (!a && b && c) || (a && b && !c)
				Gives: (NOT a AND b) OR (b AND NOT c)
			Using the result in: https://www.dcode.fr/boolean-truth-table
				Matches my intended truth table
			Using digital data recording mode, output\DebugAudio.txt, with read on RAM read state, shows the counter values correctly counting

		Done - Need voicesActiveMask reset logic based on not looping
				V0ST_COMPARELENGTH	| _V0RESETCOUNTER	| VOICELOOPMASK0	| output
				0					| 0					| 0					| 1
				0					| 0					| 1					| 1
				0					| 1					| 0					| 1
				0					| 1					| 1					| 1
				1					| 0					| 0					| 0
				1					| 0					| 1					| 1
				1					| 1					| 0					| 1
				1					| 1					| 1					| 1
			(!a && !b && !c) || (!a && !b && c) || (!a && b && !c) || (!a && b && c) || (a && !b && c) || (a && b && !c) || (a && b && c)
			NOT a OR b OR c

		Done - Need address or loop address add to counter and memory read states
			V0ST_OUTPUTADDR
			V0ST_READRAM
			Created common adders for:
				COMMONADDRESS0..15
				COMMONPOSITION0..15
				COMMONREADADDRESS0..15
			TODO: Read debug and logic analyser indicates an incorrect value read for AUDA=4
				Perhaps the setup address time is not long enough?
				But reducing AUDCLK results in the RAMs not being written?!!
				d$00230002
				d$01c00003
			>>>>	d$01080004	Should be 0xff but reading 0x08???
				d$01730005
				d$01004020
			Why? With SAMP8 enabled in the simulation the RAM fails to write and read properly
				74245 is needed to isolate each RAM, it fixes the incorrect read
				The _OE,_WE, _CE is connected, just like all other RAMs for their respective banks
				_OE period has been reduced to only the time for address setup and read result
				_CE period has been reduced to only the time for address setup and read result, or EBS2 request time
				* This has fixed SAMP8 write issues and SAMPD read issues
					d$01230002
					d$01c00003
					d$01ff0004
					d$01730005
					d$01014020
					d$01024021
					d$01034022
					d$01014020
					d$01024021
					d$01034022

		* Done - Need to remove all unique voice internal terminals and group all unique voice input/output terminals for easier update

		Done - Need volume calculation, could be part of the common sample read module with a large EPROM
			This can simply cascade into the final output
			COMMONVOLUME0..7 created
			
		
		Done - And if not voice active then just output 0x80
			This could use the common logic from _VO_ADDRCNTOUT, when there is no RAM chip enabled at U1 (connected to _VO_ADDRCNTOUT and U52:C)
				This enables uses a latch and selector for the value to load into the final output after the volume calculation
				This uses AUDOE to combine detection for the sample RAM being written to and mutes the output when this happens

		
		* Done - Need to create other voices

		Done - And latch output of sample once for all four voices?
			Added extra step V0ST_OUTPUTADDR2 to allow V0ST_READRAM to be used for +ve edge trigger
			Cascade adders for sample?
			Then final output latch or 0xff read on carry detection for values > 0xff
			* At the end of a sample, without loop, does the MOD file player output a 0x80 or the last sample read?
			
		
		* Done - VOICELOOPMASK0 all of them, need to be moved to the left and connected
		

		* Check output data by using VideoHardware demo file and decoding the result for left and right channels
			* Use ffplay with u8 raw sample input
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 0 4
			"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 31250 c:\temp\t.bin
				Initial check seems to be OK, the pitch might be off, need to adjust for the final frequency


		
		* Done - The final output frequency from the hardware needs to be calculated and adjusted in the MOD converter
			The input clock rate for the crystal/oscillator will play a part here
			As will the final position of LOADOUTPUT which also resets the counters
				https://www.unitjuggler.com/convert-frequency-from-%C2%B5s(p)-to-Hz.html?val=40
				25000 Hz
					C:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\ffmpeg.exe -i "C:\Users\Martin Piper\Downloads\Digital Leisure\Dragon's Lair\VIDEO_TS\VTS_06_1.VOB" -y -acodec pcm_u8 -ar 25000 -ac 1 c:\temp\sample.wav
					Then trim the WAV header and make it 65536 bytes long for testdata\sample.pcmu8
				IntelliJ run config "TestRunner --exportmod (2)" used and "target\" music data files copied to testdata
				C64\VideoHardware\BuiltIt.bat also works


* When listening to the audio simulation output
	Simulation to use: C:\Work\C64\VideoHardware\target\debugData.txt
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\temp\t.bin
	Compared to the emulation debug output:
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\work\C64\VideoHardware\target\debugchannel.pcmu8

	The pitch seems to be off, perhaps there is a fault with the looping?
		Try one voice in simulation first
		
	* Or perhaps test the output from run configuration: TestRunner TestVideoHardware.feature
		Simulation to use: C:\Work\BDD6502\target\debugData.txt
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 C:\Work\BDD6502\target\debugchannel.pcmu8
		After editing: C:\Work\BDD6502\target\debugData.txt
			To find d$802c0100 and remove previous video writes, leaving the data writes intact
		The simulation pitch seems to be OK, but the audio is not entirely clean as expected
		Listening to the debug data from the channel pre-combination stage:
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudio.txt c:\temp\t.bin 3 4
			The audio also seems to not be clean, but of the correct pitch
	Indeed the DebugAudio.txt indicates incorrect memory address reads that are not entirely in sequence:
		d$00ff7d7d
		d$01008080
		>>> d$08017474
		d$01028383
		>>> d$08037171
		d$01048282
	AUDA breakpoint on 0x100
		Found: U34->U41 are inverted, whoops
		DebugAudio.txt indicates correct sequence now
		Correct audio plays now, sounds clean
	VideoHardware demo smoke test feature was also missing: And enable video display bus debug output
		So the debug output was a month old, not using the new rate->frequency conversion
	Need to test with new data
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 0 4
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\temp\t.bin
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 C:\Work\C64\VideoHardware\target\debugchannel.pcmu8
	Sounds cleaner, but the pitch/address/loop still seems to be off still?
		Higher rates sound worse?
		* It looks like the "COMMONPOSITION" comparison lines are slightly wrong going into the comparators 7485s
			Sounds better now


			
			
			
* Master latch for mode7 regs?
	Plus independent x y counter reset? Which could actually be used to hold the counter low for interesting effects
	This would allow the copper to update in one pixel all the parameters and allow interesting effects where sections of the screen can be changed independently
	Try in emulation first
		Emulation looks good
	* Done - Extend to make all the MR lines independent, do not affect the clock lines
		reg	MR		tick
		x	_HSYNC	6MHz
		xy	_VSYNC	_HSYNC
		y	_VSYNC	_HSYNC
		yx	_HSYNC	6MHz
		Added handleRegisterFlags();
	* Done - Generate data (both of them) needs updating write: 0xa015=0x1f
	* Done - Hardware schematic needs to include extra logic for _HSYNC and _VSYNC based on flags
		Checked with test data
	* Done - Check extra AND gate IC usage and board group in Mode7
	* Check auto-place and route board size
	* Done - 6502 driver code needs write: 0xa015=0x07
	* Done - Feature files need updating too

	
* For audio playback of the audio simulation output:
	c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 1 2
	"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -channels 2 -ar 25000 c:\temp\t.bin
	