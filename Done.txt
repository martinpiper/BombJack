* Output video signal with resistor ladder. Exclude from simulation once analog behavior has been verified.



* Removed duplicate component references that were causing incorrect auto router errors.



* Sheet 8 - Palette read/write logic



* Need a VSM model for a display that takes digital RGB + HSYNC + VSYNC
	https://github.com/MockbaTheBorg/VSMModel
	https://www.edaboard.com/showthread.php?188054-Creating-A-New-Component-(DLL)-For-Proteus-VSM
	http://fractale.gecif.net/si/logiciels/proteus/ProteusVSMSDK.pdf
	https://github.com/Pugnator/openvsm
	http://pugnator.github.io/openvsm/vsm__api_8c.html

	
	
* Interesting logic with _9A00CS 7R 6R 6S 5R 5S as it is only taking DB0-3 which implies a value 0-15 only. Hmm.
	Resulted in discovering new 0x9a00/0x9a01 functionality for sprite size select, documented in README.md

	
	
* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS2:EXTWANTIRQ
	This is because memory writes to 0x98xx can only be made when the video HW is not accessing the sprite regs

	
	
	
* Examine bus SREAD for the timing of sprite reads corresponding to the BH pixel clock and pixel output timing during the scan
	Done - Examine when the scan RAMs get cleared before sprite rendering
	Find out the reason for the first few bytes of what looks like odd data being written even when sprites are not at that coordinate?

	
	
* Add page 6 character screen logic
	Original schematic bug?
	2R-6 should not connect to 8C-4



* Complete page 8 pixel combination logic
	page 8 - For the 153x4 ICs D3 seems to be left to float high. Which means, for those pixels it will be floating up to the last entry in the palette.
	Added a push button to cause the D3 input to be lo or high producing a nice debug purple rendering option.
	
	
* Page 7 background picture logic done



* Inspect original PCBs and look for 74 LS/HCT types to match with where possible
	https://www.jammarcade.net/tag/bomb-jack/
	https://www.jammarcade.net/images/2019/06/Arcade-DIY-46-Bomb-Jack-pcb-repair-14-19-screenshot-768x432.png
	Indicates that M74LS174P is 8B (174x2) should suffice

	
	
* _MEWR needs to be connected to the header, might need invert?
	No need an invert, active low

	
	
* To interface with the CPU, the _9800CS and _MEWR lines can be used without any more tri-state buffering, since they are not driven by the video circuitry



* 6MHz clock needs a full can oscillator part in the schematic (disabled for simulation) and layout
	12MHz Can oscillator
	https://www.mouser.sg/ProductDetail/CTS-Electronic-Components/MXO45HS-2C-12M0000?qs=sGAEpiMZZMt8zWNA7msRCvpTgpVI8f3UwUWPm0GFK9s%3D
	Needs the signal and not signal created
	DIP-8 https://www.mouser.sg/datasheet/2/96/008-0258-0-786357.pdf
	
	12.096MHz Short crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-4X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxj6PWo6GSXrZU%3D
	https://www.mouser.sg/datasheet/2/122/hc-49usx-791.pdf
	12.096MHz Tall crystal
	https://www.mouser.sg/ProductDetail/ECS/ECS-121-S-1X?qs=sGAEpiMZZMsBj6bBr9Q9aQVbz5FLOGxjBlVr3Wwx1PM%3D
	https://www.mouser.sg/datasheet/2/122/hc49ux-88.pdf
	
	Added JP1 to select between crystal output from 4T pin 5 when connected, or can oscillator VIDCLK when disconnected
	R1 and R2 from schematic top left page 3 are labelled R21 R22 in Proteus schematic
	
	Same as OSCCLK for CPU project, root sheet 2
	Check original schematic for inverse signal generation, it might have some offset skew
	* Schematic sheet 3, top left, shows a 12.096MHz crystal driving a 7474 dual edge-triggered flip-flop and generating _6MHz 6MHz and .6MHz
		But in the design I used .6MHz and 6MHz as the same thing, logically they are the same
		The inverted output comes from the 74368 hex buffer inverting tristate outputs
	* Added VIDCLK signal and 3T:A and hex inverted drivers 4T
	
	Breadboard https://www.mouser.sg/ProductDetail/Twin-Industries/TW-E41-1060?qs=sGAEpiMZZMvxYGX2LOb%252BCkpSd%2FF6Zib6rdOv%2FJq26CY%3D

	
	
* Regarding 6MHz from 4T, the trace is very long. Perhaps this is why .6MHz was created in the original schematic?
	6N2:B root sheet 6 (6N 456 page 6 bottom middle left)

	
	
* Change screen colours to exercise the 6N2:B flow



* Perhaps move the edge connectors up the board to improve component auto place?



* Instead of using ROMs, use RAMs and add extra logic to enable their write via the external header.
	* Will need 74245
	* To free up the cartridge port, think about perhaps a non-memory mapped interface, so something via the C64 user port?
		https://www.c64-wiki.com/wiki/User_Port
			* The edge connectors have 3.96mm pitch (distance between contacts) and accept cards (PCBs) 1.57mm thick.
		https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
		https://csdb.dk/forums/?roomid=11&topicid=19759
			/PC goes low for one cycle after port B access.
		http://www.devili.iki.fi/Computers/Commodore/C64/Programmers_Reference/Chapter_6/page_359.html#User
			Looks like I can have 8 bits output with PC2 signalling when it's written
				FLAG2 as input for VSYNC (NMI trigger or poll DD0D bit 4)
				PA2 as an output bit flag
			So on PA2 this can reset the state to reading a lo/hi address, then any number of bytes to store without needing the number of bytes
				C64Docs\C64PRG10_TXT.txt
					DD00
					2      RS-232 Data Output (User Port)
					DD02       56578                 Data Direction Register - Port A
					PA2 is bit 2 of PORT A of the CIA
	* Need to find out how much RAM will be needed and decide a memory map
		All the used *.bin files (mapped into ROMs) total 64K of data.
		This means a linear 16 bit address bus model won't work as there isn't space for the RAM to be mapped.
		Instead, the ten!! ROMs can be selected with an explicit chip select register combined with an address, so 24 bits instead.
		byte:
			0		Chip select using a 74154 to map up to 16 chip groups
			1/2		Lo/hi address setup
			3		Bytes to store, address++
		Done: UserPortTo24BitAddress
			Done: U6-U9 needs to load the lo/hi address as needed, when they are selected and on the negative edge of _PC
					RCO goes to ENP&ENT
					CLK needs to cause the address to count up on the positive edge of _PC and only when U10 is being populated with CS3 low.
			* U3, U10, U18 and U19 contain the chip select, data, addr lo/hi with auto increment
			Done: EMEMWRITE will need to be low for a short tick while after the data/address are stable
				Perhaps add logic to toggle this based on a delayed flip-flop chain?
				* Actually just used the after byte tick instead
				* Added a quick debug selector and RAM, to visually display the memory can be selected and written
			Done: EXTWANTIRQ, from the _VBLANK negative edge when it starts the VBLANK will need to be sent to FLAG2 (which is negative edge triggered on the C64)
		* 74154 Obsolete!?
			74139 used instead
			74138 is also available
	* 4T on sheet 3 which creates the 6MHz/.6MHz/_6MHz signals from the input VIDCLK has OE
		This output enable could be tied to a register line to enable or disable the whole display, which would massively help with writing to any RAMs for the video data.
		This could be the higher bits of 9e00?
			Root sheet 7, 4S7 could store the extra bits if it was rewired a bit. Default is low, so no video output?
			3S+3R could also be reset on low
			* Added DB5 line for 0 = disable display and 1 = enable (DISPLAYENABLE and _DISPLAYENABLE)
				This allows large amounts of data to be written to RAM while the display is disabled without fear of contention with the display HW
	* ROMs will need RAMs, the memory setup timings will need to be honoured.
		The original RAMs can be selected as per normal and can be the first line, suitable _CSEN+_MREQ can be faked for those.
			Inverted EBS0 perhaps?
		The other lines can enable or disable the ROM->RAM segments as needed with perhaps 2-3 8K chunks memory mapped on each line
			74LS245 plus 74157
	* Done: User port (write memory) timings, need to honour the expected timings for address and data setup
		Check with the logic analyser
			EMEMWRITE might not have the correct setup timing constraints
			There should be the memory and data setup, then a delayed write pulse (low) where the data and memory is still setup afterwards
				Might be because _PC is timed wrong on the input simulated data?
					* Done: Yes, the signals need expanding a bit more to include the leadin and leadout states
					* Done: Check leadin and leadout states on CIA timing diagram with _PC and data levels
						* BombJack loads 4S7 (root sheet 7) on the positive edge (trailing edge) of _MEWR with a low _9E00CS and 7432 (OR) output
							This makes sense since it might be trying to accommodate timing issues where the data might be settling during RAM cycle timing
						* Done: So update userport design to also accommodate this
							Memory and data are primed, _MEWR is held low for a short pulse, memory and data still held
							Verified by logic analyser
	* Done: Attempt RAM replacement for Root sheet 7. Read only background picture logic
		4P7 2764 can be replaced with a 6264
			_CE will need a low to select
			CS can be high all the time
			_WE low on _MEWR
			_OE low on memory read
			To select address perhaps a 74157 with _A/B based on _ADDRCS? With _ADDRCS OR (7432) _MEWR going to _WE
			74245 needed for bus tristate?
				Or maybe a simple 74373 for tri-state outputs since we don't need read logic
				The 6116 RAM on root sheet 6 has interesting _OE/_WE based on a simple NOT 7404
		* 4P7R (RAM) replaces 4P7, BusEBS.ptn added to simulate "Root sheet 7 EBS7 EA13 RAM select"
			There are some logic contentions on BIDxx at the start, but similar CID contentions are also seen on 6LM6 RAM writes from the original schematic
			* 4P7 has been schematic and placement disabled
			* 4P7R is obviously enabled
			* Only memory from 02_p04t.bin $400 to $5ff is included in the pattern file, to reduce the data specific to the sphinx graphics
				It is $100 bytes of char data, followed by $100 bytes of colour data
	* Done: Will need a replacement for the Proteus data generators because they have a 1024 byte limit
		VSMDD2 on root sheet 1 now uses TestData.txt to set all the data needed
	* Done: Root sheet 7 8R7 using 08_r08t.bin to RAM	EBS6 EA14 RAM select	$2000
	* Done: Root sheet 7 8N7 using 07_n08t.bin to RAM	EBS6 EA15 RAM select	$4000
	* Done: Root sheet 7 8L7 using 06_l08t.bin to RAM	EBS6 EA13 RAM select	$8000
	Note all new logic for the RAMs on root sheet 7. The original ROMs are still present, just disabled from the simulation and layout.
	
	* Character data
	* Done: Root sheet 6 8K6 using 05_k08t.bin to RAM	EBS5 EA14 ram select	$2000
	* Done: Root sheet 6 8H6 using 04_h08t.bin to RAM	EBS5 EA15 ram select	$4000
	* Done: Root sheet 6 8E6 using 03_e08t.bin to RAM	EBS5 EA13 ram select	$8000
	
	* Sprite data
	* Done: Root sheet 4 7J using 14_j07b.bin to RAM	EBS4 EA13 ram select	$2000
	* Done: Root sheet 4 7L using 15_l07b.bin to RAM	EBS4 EA14 ram select	$4000
	* Done: Root sheet 4 7M using 16_m07b.bin to RAM	EBS4 EA15 ram select	$8000



* Group EBS usage for the tile/char/sprite data to EBS6/EBS5/EBS4 so that all three available 8K banks are in the same EBS



* Remove the vertical flip button and associated logic? Since it's not really needed as I'm not strictly emulating an arcade board any more.
	The layout complexity can instead be used for pixel level scrolling and the extra timing generation

	
	
* Background layer (root sheet 7) pixel fine scrolling enable?
	Could have an extra register $9e01 (l/h nybbles for x/y) that add values 0-15 to the X/Y pixel clock before addressing the background data?
		This could in effect generate a pixel scrolled background image?
	* For 6S7 and 5S7 timing
				cba9876543210 = Address at 4P7R/4P7
		_SL2	0010010100111
		4x6MHz clocks
		_SLOAD	0010110100111
		4x6MHz clocks
		_SL2	0010010101000	*
		4x6MHz clocks			*
		_SLOAD	0010110101000	*=
		4x6MHz clocks			*==	One 16x16 tile being loaded, character/tile index then colour
		_SL2	0010010101000	*=
		4x6MHz clocks			*
		_SLOAD	0010110101000	*
		4x6MHz clocks			*
		_SL2	0010010101001
	* Signals that need handling: XXH' and XXV' plus 4H, SLOAD and _SLOAD (which trace back from BIS0)
		Added new signal prefix BGH for these by copying the logic from root sheet 3
		Initial tests of the X nybble write seem to indicate success!
	* TODO: At this point, could do with a DigitalData wait for edge (for _VBLANK) and output new data code
	* X and Y pixel scroll logic added

	
	
* Need some extra logic (and control bit) to hide the gaps behind slightly contracted borders (just like the C64)
	U65 has spare two bits 6/7, if 1 then contract the Fair right and bottom borders respectively
	X & Y Border shrink works





* When running at VIDCLK 6MHz, the target speed, the sprites fail to render correctly.
	This is because Root sheet 5 4A/4B/4C/4D/ have by default 200ns address access time.
	They are 4 bit RAMs, obviously the original hardware was slightly exceeding the 166.6 ns timing from the 6MHz clock
	Verified that if the default 200ns is changed to be 100ns then the sprites start displaying again
		* It is interesting to note 8K replacement 6264 RAMs are all 100ns address access time
	They only use A0-A7 internally
	Consider using 8 bit RAMs with lower access times instead
	The next viable RAM would be: https://www.jameco.com/z/6116P-70-Major-Brands-IC-6116P-70-CMOS-SRAM-16-384-Bit-2Kx8-70-ns_242675.html
		This can be simulated and it is still able to be ordered.
	Running a 12 MHz VIDCLK with 70ns address access time results in some corrupt sprites at their correct positions
		Running with 10 MHz VIDCLK (49.2 FPS) means the sprites render correctly.
		With 50ns address access time the sprites render correctly.
		(See Root sheet 5 with 6116 RAM for sprite spans for an example)
	* TODO: Split the 2114 RAMs into two or more, based on their low address, to interleave the bit accesses
		Might have to latch the address and data to hold the address and data for longer, have 2 or 4 latches?
		This latches will need to use the low address lines to decide which chip to enable for read/write
	http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html
		Note: No address setup time
	http://www.ukvac.com/forum/bomb-jack-pcb_topic368665.html
	* TODO: Study the memory, data and WE access patterns to plan for the best strategy
		From about 1.33 seconds into the simulation will be the middle of the frame
		Note: VSMDD3 on root sheet 5 setup to record the:
			Address
			Byte
			D24 _write
			D30 0 = Output pixel data to the screen and clear to ff, 1 = reading/writing sprites
			D31 _CE
			Clock start time 1.33
		Note: 4C4DRecording.txt
		Note: The first few thousand lines were trimmed to align with the start of the d$4 phase
		d$0 indicates _CE and outputting pixels to the screen
			So the following:
				d$0100ff08
				d$01006f08
				d$00006f08
				d$0000ff08
				d$0100ff09
				d$01006f09
				d$00006f09
				d$0000ff09
			Note the address counts up, reads, then quickly writes ff, note the data is not stable during the _WE
		d$4 indicates writing sprite data
			Using TestData.txt "Top left all the same" it's possible to see the same address range 0-f repeatedly being used
			4D (ID4-7) starts to get 77...
			4C (ID0-3) still shows ff...
			So the following:
				d$4100ff00
				d$4000ff00
				d$40007f00
				d$41007f01
				d$4100ff01
				d$4000ff01
				d$40007f01
			Indicates that the RAM will consume the written data even after the 6MHz negative edge, basically when it's low
				However note that the address is stable
		Perhaps on _WE, the relevant latching address hold and write hold can hold the WE low for the relevant RAM whilst the new address switches to its read mode
		Once the address switches to read mode the WE is not held low
		* In Test2114 project, using the 10MHz VSMDD3 recording only half of the bytes are visible in the 2114s
		* Now the VSMDD3 clock is at 100MHz, now the 2114s do show both halves are written to.
			It shows there is some high-frequency interaction going on that needs study.
			Which is visible in the recordings:
				d$0000ff00
				d$0100ff00
				d$0100ff01
				and
				d$40007f00
				d$41007f00
				d$41007f01
			Note the very quick (<10ns) write address 0, then read address 0, then read address 1
		* 4C4DRecording output pixels.txt
			Been created to start with pixel output and clear
		Note however the high frequency variance in address lines:
			d$41007f01
			d$41007f03 <<<
			d$41007f02
		Probably due to 6C/6D 74163 counters displaying a non-stable ripple output
			Solved by adding U77/U78 74273 that use _VIDCLK for CLK to latch the address inputs a short time after the counters have finished
				See StableSpriteScanAddress.png
			Note the recording now shows a stable address lagging behind 21/22 lines (210/220 ns) plenty of time for the signals to settle
			Visually the output sprite pixels do seem to be a little bit better formed, more regular
			Unfortunately, this latch lag means even VIDCLK at 4MHz shows the "purple bars" corruption, due to the late arriving address compared to the data
			Without the "fix" at 4MHz the sprites display correctly.
		https://www.mouser.sg/Semiconductors/Logic-ICs/Logic-Comparators/_/N-cbost?P=1z0y33v&Keyword=74ls688&FS=True
		* Test2114
			* TODO: If _6MHz (writing) and IDA0 then use memory, memory _WE needs to be held low for longer than _6MHz, enable write latch signal, also latch data to write to memory, also U2 load address and U9 load data, and output enable U9 for cached output
			* Done: If 6MHz (reading) and IDA0 and IDA=C0A then bypass memory and output enable U9
			* TODO: If 6MHz (reading) and IDA0 and IDA!=C0A then use memory, bypass U2 and U9, select raw memory signal 74257, reset any write latch for memory and output enable select memory
		* Going back to testing the 2114 chip access timing profile:
			With the Proteus defaults then 6M is about the limit, however using 2114AL-1 values ( http://www.cs.smith.edu/~jfrankli/270s02/datasheets/2114.html )
				{TAA=100ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
			Then 8M is the limit (with a single pixel vertical line duplicating the background near the right hand edge)
			With 9MHz no sprite data is visible, then changing to use:
				{TAA=100ns}
				{TCE=10ns}
				{TOE=10ns}
				{TOD=10ns}
				{TWP=10ns}
				There are only some bad pixels, but hardly anything visible.
				Instead changing to use:
				{TAA=75ns}
				{TCE=70ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are visible correctly again. It seems as though the TAA access time is what is important.
				The above takes the VIDCLK up to 10.5M. At 11M there is a purple vertical bar near the top left edge, but most sprites are still visible.
				At 11M using:
				{TAA=70ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are correct.
				At 12M some sprites display doubling or missing line corruption.
				Using this:
				{TAA=60ns}
				{TCE=50ns}
				{TOE=10ns}
				{TOD=30ns}
				{TWP=75ns}
				All sprites are fine at 12M = 59.2 fps
				10.1M = 49.8 fps
			Back to 2MHz and all is well. Test2114 indicates that a write through caching version of a 2114 would work as a daughter board to the 2114 socket, if needed.
			The unstable addresses from the counters could be handled by more than two cached lines. In the real hardware they may cause spurious reads or writes in the RAMs.
			So for now continue to assume that modern real world 2114s are as fast as those used in the original hardware decades ago.
			The Proteus 2114 model could do with some checks to see how fast it really can write according to finely controlled timings.

			
			
* Use the DigitalData negative edge wait to add a horizontal scroll test




* Demo animation for sprite and scrolling
	TestData.txt updated to include display register updates for each frame
	cd /d C:\Work\BombJack\output
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug.gif && debug.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 384x264! debug.gif && debug.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp debug2.gif && debug2.gif
	c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 384x264! debug2.gif && debug2.gif
		Using this option is good with 3072 x 264 in the VSMDD digital display
	For the hires schematic: c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -loop 0 -delay 5 debug*.bmp -resize 768x528! debug.gif
	This demonstrates horizontal and vertical pixel scrolling, using a variation on the original Bomb Jack hardware. Extra screen banks are updated into the new graphics RAM to update the tile positions. One sprite is updated too.

	
	
	
* Double check the exact input clock rate and logic with the original schematic for running at the required frame rate
	12.096MHz

	
	
* Replace the 2114s with a single 6116
	Here we have very fast memory: https://www.mouser.sg/Semiconductors/Memory-ICs/SRAM/_/N-4bzpt?P=1z0z63x&Keyword=6116&FS=True
	* Going back to testing the 2114 chip access timing profile
		With the Proteus defaults then 6M is about the limit.
	* With 6116 defaults then 8MHz is about the limit
		However 20ns access time can be found: https://www.mouser.sg/ProductDetail/IDT/6116SA20TPGI?qs=sGAEpiMZZMt9mBA6nIyysK6VW3GrAnba45Kc6Apw0Go%3D
			* https://www.mouser.sg/datasheet/2/464/IDT_6116_DST_2014115-882651.pdf
	* Using these speeds in Proteus:
		{TAA=19ns}
		{TCE=11ns}
		{TOE=10ns}
		{TOD=8ns}
		{TWP=12ns}
	* The old 2114 4A,4B,4C,4D have been disabled/excluded and replaced with two 6116 U77 U78 instead

* Auto place OK



* Using the logic analyser, measure the _VSYNC and _HSYNC timings and compare between the original at 12.096 MHz and the higher resolution version at 24.192 MHz
	A2	_HSYNC
	A3	_VSYNC
	A5	VBLANK
	Logic analyser capture on _VSYNC (A3) positive edge
	Using 2u capture resolution.
	From the original schematic:
	First A3 negative edge 16.25 mS
	Next A3 negative edge 33.02 mS
	First A5 negative edge 1.02 mS
	Next A5 positive edge 15.24 mS
	Next A5 negative edge 17.78 mS
	A5 positive edge to negative edge 2.54 mS
	A3 positive edge to A5 negative edge 1.02 mS
		A2 negative edges between 16
	A2 negative pulse length 16 us
	Negative edge A5 to negative edge A2 8 uS
	A2 positive edge to positive edge 64 uS

	
	
	
* With faster sprite RAMs being used, it might be possible to expand the horizontal resolution of the whole screen to be 512 pixels :D
	Extra bytes would be needed, $9900 or $9a00 and extra 2114 RAMs to load in parallel to the high-X pos value load per sprite
		Maybe use bit 4 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?
	Initial tests of adding an extra bit to the H values works quite well.
	At 24.192MHz then 3E and 3F need to be made faster, replace with 6116 instead?
	The timing for sprite register colours is quite tight though. Also there is going to be extra memory needed for the char screens.
	Reverted the change for now, needs more pondering.
	* First change all references to *256H* to be *512H*
	* Change *ZZZH* to *512H*
	* Then create the _512H to 512H circuit
	* And tackle the HBLANK timing test
	* Tweak background address lines to reduce the number of screen but increase the horizontal resolution using 256H/512H as appropriate
	* Add extra sprite scan address line
	* Add extra sprite registers address lines
	* Add extra byte for MSB for each sprite from $9900, to be loaded when the sprite X pos is loaded
	* 6LM6 6116 needs to be a 6264 for the AB11 and to use 256H' the lower address bits will need to be shifted up
	* Test project: Bomb Jack 512x256 test 48 sprites.pdsprj
	* Sprite and char screen logic done
	* Done: Tile screen logic, there will need to be some 256H handling to addresses as it is currently missing
	* TODO: Instead of VIDCLK = 24.192 MHz going into the 3T:A 7474, could instead use VIDCLK directly into 4T
	* Done: Sprite register 3E/3F loading address is different in hires compared to lores?
		Yes, they start at $9840 not $9820 according to the logic analyser
	* 6264
		https://www.mouser.sg/ProductDetail/Alliance-Memory/AS6C6264-55PCN?qs=sGAEpiMZZMt9mBA6nIyysDfDw0vDQxSwL3Jgh6owPVw%3D
		https://www.mouser.sg/datasheet/2/12/Alliance%20Memory_64K_AS6C6264v2.0July2017-1144693.pdf
		{TAA=55ns}
		{TCE=55ns}
		{TOE=30ns}
		{TOD=20ns}
		{TWP=45ns}
	Created 2114FAST, 6116FAST and 6264FAST to reflect timings in datasheets and empirical values for 2114
	* Done - 3E/3F could use one 6116 instead
	* TODO: There is a strange sprite colour corruption when running at VIDCLK = 24 MHz
		Output from 7E and input to 6E matches
		Output from 6M MV0-3 is sometimes out of sync
			Tried configuring very fast RAMs 7JR 7LR 7MR did not fix the issue
			TODO: Signals going into the above RAMs? Use VSMDD5
			VSMDD6 shows O0..7 is OK
			VSMDD5 shows C0..12 is sometimes wrong
				Which bits are mostly wrong?
				C0..4 are OK
				C5..8 are sometimes wrong, which?
					C5 always 0 when wrong at 24 MHz
						MD0 or 16MH? S?
							S seems to be late sometimes?
								5R or 5S late/wrong at high speed? Disable and test. Does not seem to fix the issue.
				C9..12 are sometimes late, but no wrong signals detected
	* TODO: At the moment it looks like the timing is too tight for 512x256 hires

	
	
* Update the standard resolution schematic to use 2114FAST, 6116FAST and 6264FAST
	Test with 12.096 MHz VIDCLK

	
	
* Standard resolution: 3E/3F could use one 6116 instead



* Disable 5F and the screen fills with sprite data, this obviously disables the Y pos range check.
	This could be easily configured with a sprite Y pos test register bit to allow full height sprites with repeating patterns.
	3E/3F are the sprite register RAMs, it's possible to read extra data from $9900- and an extra RAM to feed this daft idea cheaply
	Maybe use bit 5 from "Byte 1: HV..CCCC" for this? 6E or 7E could latch it?

	
	
* Last plane, it's a latch for pixel colour from palette
	Can up dated during screen time by a copper
	Use similar for $01 $9e03 to store this?
	* Added U81 for BBCL0-7

	
	
* 4 bit adds for tile plane ($9e02)
	The demo has been updated to use this instead of duplicating the screen data in different banks with a shift

	
	
	
* There is also the possibility to allow the horizontal pixel clock and/or the vertical raster position to be read via a latch and suitable address chip enable logic of an 8 bit latch
	* Alternatively, have a "copper" mode on the interface logic board?
	* To test this, the digital data part can be expanded to accept more inputs for RH and RV, no need for _HSYNC with this remapping model
	* Done: Need wait for X/Y pos in DigitalData, added some test data patterns for copper bars and split sprites

	
	
* To get multiplexed sprites working, the sprite logic seems to need to be disabled to avoid spurious data bus reads
	Or the data bus writes need to be precisely timed, with a proper copper, to coincide with periods where the sprite registers are not being read
	See: TODO: While this works, it needs a proper copper



* Alternatively, have a "copper" mode on the interface logic board?
	* The mapping of the RH and RH values and CLK to a header could allow RAM to output defined signals to the ED, EA, EBS output.
		The RH values could be divided down to only trigger during _HSYNC for example
		Or it should be possible to program a "mapping" memory for RH and RV, that defines when/how the real "copper" memory can be accessed.
			This could translate into addresses that are logically ORed into a final lookup address into the copper.
		This could be selected by a particular EBS mode, perhaps even the idle 0x00 or maybe the 0x02 mode?
		Setup of this memory will have to be done during the _VBLANK to avoid visible artefacts, writing takes priority.
		* TODO: Idle EBS mode would be good, the user port interface can be tweaked to disable all outputs to DB/AB/EBS etc when EBS == 0
		* TODO: Digital data would need an output disable mode for certain pins, the copper could then be added as real extra logic from the main board
			* EBS would obvious need to be maintained as output with 0 to stop the whole board chip groups being selected at once
			* Or to emulate, the DigitalData could have an extended output value command that accepts override data setup and _MEWR timings
		Old DigitalData clock=500k
			TOLOW=0.00000025
			TOHI=0.0000005
		Now using clock=2M
			TOLOW=0.000000125
			TOHI=0.00000025
		* Note: At 2M the sprite multiplex split is very small and does not interfere much with the video output
			* This means it might still be possible to emulate and find safe spots for the sprite register writes, needs experimentation
			* There are no safe spots, the sprite RAM is constantly read during the scan frame
				$9a00 Upper nybble: $10 = Enable sprite output (6S SPREN), works by resetting the contents of the sprite shifts on low
			* Success! Examining the rendered output the tall stretched sprites not yet updated are visible without artefacts

			
			
* Investigate latched writes to the background colour. It's not entirely stable if the copper bars move up and down?!
	* A double write to "d$9e0301XX" seems to fix the issue? Is this because the address should be maintained, not incremented?
		Or is it the horizontal timing position that is just right?
	* Perhaps, a second sprite register RAM can be used, while one is being read the other can be written to?
		Perhaps not, it would need quite a bit of extra logic to isolate the DB and AB
	* Fixed a bug in DigitalData where waiting for an input value caused the first value to be skipped
	* Double writes removed from the data generator, the display still renders correctly


	
	
* Introduce extra colours bars.
	TODO: Some of the frames show some colour bar sparkles visible on the left of the screen in the blue area of the scrolling top screen?
		Why? How?
		Shifting the first colour change on the left over 32 pixels seems to have vastly reduced, but not entirely removed the problem.
		Might it be one of the colours from the last or first segment? It seems to move with the bars?
		* Test a full run without auto-increment addresses during the colour bars
			Sparkles still happen.
		* Try using this for the first colour bar position: file << "001000" << std::endl;
			With d$9e000120	; Disable the tile screen
			With the DigitalData clock input = 2MHz this shows how interaction with the 12.096MHz video clock introduces some timing variance on the left vertical bar
				Changed the clock to be the Q2 (divide by 8) output from a 74161 and VIDCLK clk input
				This fixes the timing variance on the left colour bar
				TestTileDisableRapidColours.txt indicates this equates to colour changes at precisely every 4 pixels, as expected.
					Useful data for a hardware copper...
		* Using the Q1 (divide by 4) output from the 74161 and the display demo is stable, and rapid colour writes are now at 2 pixels resolution
			Also very useful data for a hardware copper
		* Try running with this new clock input
			Up to frame 275 it all looks clear!
			All frames look clear.


			
			
* 7483 no longer made? Change to 74283 with different pinout.



* GenerateData2
	Add a simple (naive) multiplexor test using WaitForRaster() to then reset the sprite used back to the first if there is enough gap



* Board separation preparation work
	* Need to rationalise and reduce the memory decode logic single pin nets (Design Explorer root sheet 10)
		_WRAM0
		_WRAM1
		_ROM0-4
		_RAM0-1
		WAIT
		_8800CS
		_8C00CS
		Above all removed
	* Using Design Explorer->Net->Type: Single Pin Class: SIGNAL, these are all in need of checking
		BBCL7	Last colour of the "background" colour, U82, part of the tiles board, root sheet 7
				Since this feeds directly into the pixel combinatory logic, then removing the chip would allow the "background" to be set by a mode7 layer etc
		BGHSS	Root sheet 7, it comes from the updated SS related logic from root sheet 3 (for SL1, SL2, SW etc) that generates the background tiles signals with the X/Y scroll values
				SS is used by the character screen, not the tiles, so it is really unused. Removed.
		HBL		Unused, root sheet 3, removed. Not useful like the _HSYNC and _VSYNC, since the copper can read RH0-8 and RV0-7
		ISAB7	Root sheet 4, sprite logic, last unused pixel colour
		_BGHSL1	Unused by the tiles, same as BGHSS origins, from the tiles x/y pixel scroll update. Removed.
		_BGHSW	Unused, same origins as BGHSS and _BGHSL1. Removed.
		_SW		Root sheet 3, unused. Removed.
	* Created _EXTCS8000-B800 lines which can be moved to a header from the main "Video gen, pixel clock timing, final mixing output" board
		Created header INRAMSEL1
		Note: _9000CS renamed to _EXTCS9000
		* _EXTCS9800 logic that decodes the _9800CS, _9A00CS, _9C00CS, _9E00CS duplicated on each board that uses these
			_9800CS root sheet 40	(Sprites)			U86:A
			_9A00CS root sheet 30	(Sprite size logic)	U88:A
			_9C00CS root sheet 80	(Palette)			U87:A
			_9E00CS root sheet 70	(Tiles)				U88:A
	* Merge _CSEN and _MREQ and remove
	* Sprite size logic now moved to root sheet 40

	
	
* Part 7N Outputs... Moved to sheet 50 and and split to sheet 80 (U33)
		_256H*.		Sheet 50
		256H*.		Sheet 50
		1V*.		Sheet 50
		_1V*.		Sheet 50
		_CMPBLK*.	Sheet 80

* SS from sheet 3 1T output 11 was wrong, the 1T 13 input was only connected to 1S 2 input and not connected to 2T 4 output
	SS			Moved to Chars board sheet 60
	_SL1		Moved to Chars board sheet 60
	_SL2		Moved to Chars board sheet 60

	
	
* Board connectors
	https://sg.rs-online.com/web/c/connectors/pcb-connectors/idc-connectors/
	https://sg.rs-online.com/web/c/cables-wires/ribbon-flat-cable/flat-ribbon-cable/
	Perhaps it's going to be better to split the boards into video generation and combination logic, char screen, tiles, sprites and mode 7?
		Video gen, pixel clock timing, final mixing output
			This needs a header for each pixel for the mixer
		Chars
		Sprites
		Tiles
		Mode7
	* Use the following properties, which can also be set as "Group" in the Design Explorer
		{GROUP=Video}
		{GROUP=Chars}
		{GROUP=Sprites}
		{GROUP=Tiles}
		{GROUP=Mode7}
	* Figure out how these signals need to be exposed:
		Done
			SLOAD
			_SLOAD
			CMPBLK
			_CMPBLK
			_MDL
			_CDL
			_VPL
			_256H
			BGBORDERX
			BGBORDERY
			DISPLAYENABLE
			_DISPLAYENABLE
		TODO
		No need (internal to a single board, or all on headers already)
			_VBLANK
			_MEWR
			16HSPR



* Automatic detection of missing routing across board boundaries and filtering with a known list of header points
	It should be possible to parse the IPC file and the Pre-Production Check output
	IPC example lines:
		P  NNAME00002 D0.00002
		P  NNAME00035 D0.00035
		317NNAME00002       U1    -2   MD0762PA00X-090170Y+007620X1270          S0
		317NNAME00035       U2    -2   MD0762PA00X+012700Y-001270X1270          S0
	Pre-Production Check lines:
		Missing connection: U1:2, U2:2
	Steps:
		Parse the NNAME00002 and NNAME00035 from "U1:2", "U2:2" mapping to "U1    -2" and "U2    -2"
		Resolve the NNAME00002 and NNAME00035 to "D0.00002" and "D0.00035", note common prefix
	CheckConnectivity tool
	// "C:\temp\Proteus\test multi board.IPC" "C:\temp\Proteus\Pre-Production check.txt"
	// "C:\Work\BombJack\V3.0\Bomb Jack.IPC" "C:\work\BombJack\V3.0\Pre-Production Check.txt" "C:\Work\BombJack\HeaderNets.txt"
	Using the V3.0 files, deliberately creating an "EEK" net with components across two boards, I see:
		Final report
		EEK                  From: U99:1,U98:6
	So it works well, even the component pins are correct.


	
	
* Move the "background colour" logic and latch to the video generator layer?
	This might allow the mode 7 layer to be added as well?
	* An extra layer can use the LAYER 4 header, which is pixel 4 (background colour) from the tiles board.
	
	
* Check the layer memory select logic, mostly layers should not need a full header but instead have select lines for their video RAM etc.
	* For now, the full headers can be retained, they supply a good consistent connection point that can be stacked, or ribbon cable connected
	* If needed for extra flexibility the EBS[0..7] lines can be connected with individual wires to allow other layers to be added at different addresses.

	
	
	
	
* Connect the last palette line giving more colours?
	6A2, 6B2, 6C2 do have A9 free, so it can be used for an expanded palette
	5E2 has some interesting logic with pin 3 (D0) being _CMPBLK*. and then the D0 output going to MR, but why is this needed?
		It seems overly complex to me, perhaps it's related to edge of screen pixel clearing logic?
		But we already have 7A2 8B2 using ENABLEPIXELS as MR?
			This does however only kick in when the borders have been shrunk, for scrolling for example
		* The _CMPBLK*. logic is there to turn off pixels at the screen edges, otherwise we get horizontal overscan screen tiles being rendered.
			Note, the tiles are rendered using incorrect memory locations
			This is used when the border shrink X/Y bits are not enabled.
		* TODO: Investigate if the _CMPBLK*. logic can instead feed into ENABLEPIXELS, freeing 5E2 pin 3 (D0)
			_CMPBLK*. goes high at HV$8 and low at HV$188 indicating (again) the pixel output logic is shifted 8 pixels
			* U67:A now combines the VBLANK, border shrinks and _CMPBLK*. and frees the line on the 5E2
			* Extra colour logic all connected
			* Tools updated to handle 32 palettes of 8 colours each



* Mode 7 display from DigitalDisplay\TestJig\Design7.pdsprj
	For the memory address space decoding to latch load signals, it could use similar logic to that observed in U70, U66
	As long as the data is read on a positive edge
	* Perhaps the background colour logic can feed into the combination board?
	* Initial logic and test data with ROMs added, it seems to be working quite well
	* Done: Added some generated dx and dy delta values, it doesn't quite rotate all the way around, probably to do with the wrong dy being used. Check the animation...
		Note: "; Trying rotates" in BombJack\TestData.txt which demonstrates the four quadrants
			At least I've figured out what register values result in 0/90/180/270 rotations now
			Note working calculations for intValue in BombJack\GenerateData\GenerateData.cpp
	* Done: Need to test for empty pixel $00 and replace it with the background colour
		Use the same address as the tile? This will need slightly more logic, but will retain compatibility with existing data
		Or just use a new address? The generated data will need updating.
		* Used new address $a01401
	* Choose between 32 16x16 or 128 8x8 tiles?
		Depending on logic constraints, it might be possible to select the relevant RAMs simply
	* Add extra map select coordinates, extra 4 or perhaps 8 bits, make the map wider
	* Add offset l/h/hh loads for x/y origin values
		Added "LDXORGL/H" note "; Trying mode7 xorg writes" seems to work
		Added "LDYORGL/H" note "; Trying mode7 yorg writes" seems to work
		74HC138 used
			Addresses spaced out allowing HH value to be used later
			Now allows a 128x64 tile screen, uses 8192 bytes
		* Done: Sheet 10 needs three more interleaved graphics fetches
	* Done: Add extra logic to use RAMs not ROMs

	
	
* Mode7 pixel calculate and output was reduced from 4 to 2 stages. Significantly reducing the complexity.



* Mode7, root sheet 10: Need to add pixel output header and common pixels/signals/address/data bus inputs headers




* Make boards top silk text V3.0



* Connectivity check shows missing:
	_HSYNC               From: J1:1,U181:1
	_VSYNC               From: J1:2,U120:1
	* Add to video headers

	
	
* Using the same x/y flip inverter trick for the mode7 tile lookup, it might be possible to add support for these in the map
	Especially now since the output pixel complexity has been reduced and there are 32 tiles

	
	
* Where 6264FAST is used, the _OE = NOT _WE is not good. the _OE should be a NOT of the NAND EBD, EA instead
	Very strange timing contention issue when two 6264FAST are on the same output regarding _OE
	* Update 6264FAST _OE _WE logic to improve write stability timing

	
	
* Also check 6116FAST _WE _OE timing
	Simplified _MERD logic, by removing it entirely. We do not want to read any internal RAMs, only writing is needed.
	Far fewer logic contentions now

	
	
	
* Logic contentions remaining:
	Caused by the palette RAM read/write switch
	Contention state CSF on net ED0.
	$ILOGIC ANALYSER#0109(B20) =>  FF
	2F_U2(B7) =>  FF
	3L6_U2(A0) =>  FF
	7B2_U2(B0) =>  SH
	7C2_U2(B0) =>  FF
	VSMDD2(D0) =>  SL
	Contention state CSF on net ED1.
	$ILOGIC ANALYSER#0109(B21) =>  FF
	2F_U2(B6) =>  FF
	3L6_U2(A1) =>  FF
	7B2_U2(B1) =>  SH
	7C2_U2(B1) =>  FF
	VSMDD2(D1) =>  SL
	Contention state CSF on net ED2.
	$ILOGIC ANALYSER#0109(B22) =>  FF
	2F_U2(B5) =>  FF
	3L6_U2(A2) =>  FF
	7B2_U2(B2) =>  SH
	7C2_U2(B2) =>  FF
	VSMDD2(D2) =>  SL
	Contention state CSF on net ED3.
	$ILOGIC ANALYSER#0109(B23) =>  FF
	2F_U2(B4) =>  FF
	3L6_U2(A3) =>  FF
	7B2_U2(B3) =>  SH
	7C2_U2(B3) =>  FF
	VSMDD2(D3) =>  SL
	Contention state CSF on net ED4.
	$ILOGIC ANALYSER#0109(B24) =>  FF
	2F_U2(B3) =>  FF
	3L6_U2(A4) =>  FF
	7B2_U2(B4) =>  SH
	VSMDD2(D4) =>  SL
	Contention state CSF on net ED5.
	$ILOGIC ANALYSER#0109(B25) =>  FF
	2F_U2(B2) =>  FF
	3L6_U2(A5) =>  FF
	7B2_U2(B5) =>  SH
	VSMDD2(D5) =>  SL
	Contention state CSF on net ED6.
	$ILOGIC ANALYSER#0109(B26) =>  FF
	2F_U2(B1) =>  FF
	3L6_U2(A6) =>  FF
	7B2_U2(B6) =>  SH
	VSMDD2(D6) =>  SL
	Contention state CSF on net ED7.
	$ILOGIC ANALYSER#0109(B27) =>  FF
	2F_U2(B0) =>  FF
	3L6_U2(A7) =>  FF
	7B2_U2(B7) =>  SH
	VSMDD2(D7) =>  SL



* How about lo/hi registers for tile background char address offset to enable hardware scrolling?
	Added, but the left border needed to be brought in by 4 pixels

	
* Can the right border be pushed out by 4 pixels?
	Yes!

	
	
* Removed old redundant ROMs




* Mode7 tiles to 64 instead of 32? Would need more RAMs
	The write logic works, but the output logic has contentions. Going to need a 2 to 1 selector 74157... Tried 6MHz strobing the _OE, no better.
	* Is this causing the output pixel corruption visible when the line has >= 32 tile index present?
	* Hmm no, a selector 74157 on >=32 tile index, did not work either. So it doesn't look like an output from RAM data hold issue?
	So what could it be? Mathematical?
		Not mathematical, one of the tile RAMs on the second pixel phase was in contention with the other tile RAM, even though _CE is exclusive
		The contention value was being read by the output latch
		So separated the two input ED0..7 bus inputs with an extra 74373

		
		
* Align the 3 bus headers in the video cards with UserPortTo24BitAddress.pdsprj



* UserPort: On reset of the state clear all output values to zero instead of needing to send 0 bytes to clear them all. See reset24BitBus
	Use bus write pulse to zero output when not active

	
	
* Twiddle the mode7 HV flips to align them with tiles




* It springs to mind that I should perhaps hook this up to a 6502 emulator with a "realtime" emulated display to help prototype games/demos.
	* Display container
	* Write data method, calls write data events in layers
	* Calculate pixel method, at current H/V position, advances to each pixel
		* Takes VBLANK and border shrink into account
	* Maintains the image X/Y, which are different to H/V
	* Add layers
		* Write data event
			* Can set a bus contention timer (in pixels) to allow simulation of display artefacts
		* Get pixel index event includes H/V display registers
	* Mode7, tiles and chars tests work well: https://twitter.com/MartinPiper/status/1251190688173027328
		Code: https://github.com/martinpiper/BDD6502/commit/061eaa68c0dedacdcd5d0586308e5bffdee34ec8

		
		
* Spot common section in the output music events file and add a new command to "gosub" to a start/end offset section
	First test run: saving=41620
	This is based on byte stream data compression, it isn't taking into account the command lengths
		This means the buffer will need shuffling around when a match is found to enable the next searches to use real in memory data including the new compressed chunked
		The buffer will also need to be pre-scanned to find a suitable escape byte
		* With all the above: saving=37059
			The reduced saving is expected due to some of the duplicated existing data being detected has been removed
			There are 5 levels of recursion here
		* With escapeByte handling: saving=36898
	* Single pass savings: saving=24686
		Multiple pass decompression is going to be hard in 6502 with limited RAM
		With escapeByte detection: saving=24693

		
		
		
* Audio board - Audio.pdsprj
	* BDD6502\src\main\java\com\bdd6502\AudioExpansion.java
	* Target 4 voices, for one channel output, 
	The 8K sample RAM can be populated using the output from C64\VideoHardware\target\debugData.txt
		* Done - Needs expansion to the full 64K
	* Audio registers, latches, are needed
		Starting to connect voice 0, the latches so far read the correct values
		All voice 0 latches work, loop mask and active mask also work
	* voiceInternalCounter[voice] += voiceRate[voice];
		with V0ST_ADDCOUNTER phase
	* voiceInternalCounter clear on voice inactive
	* TODO - voiceInternalChooseLoop will need the result of length comparison
	* HW: Note selective reset of only some adders when length is reached
	* Can use data: ..\C64\VideoHardware\target\debugData.txt
	* Or TestAudio1.txt
	* For comparison: http://www.ti.com/lit/ds/symlink/sn54s85.pdf?ts=1591365901295
		Comparison output works
		Now needs to process the result comparison at the appropriate time, after the output has a chance to be stable
			V0INTCOMPARELOOP latch works
			Need a suitable input to the counter latches
				V0ST_COMPARELENGTH	| VOICEACTIVEMASK0	| V0COMPISGE	| output
				0					| 0					| 0				| 0
				0					| 0					| 1				| 0
				0					| 1					| 0				| 1
				0					| 1					| 1				| 1
				1					| 0					| 0				| 0
				1					| 0					| 1				| 0
				1					| 1					| 0				| 1
				1					| 1					| 1				| 0
			https://www.dcode.fr/boolean-expressions-calculator
				Using: (!a && b && !c) || (!a && b && c) || (a && b && !c)
				Gives: (NOT a AND b) OR (b AND NOT c)
			Using the result in: https://www.dcode.fr/boolean-truth-table
				Matches my intended truth table
			Using digital data recording mode, output\DebugAudio.txt, with read on RAM read state, shows the counter values correctly counting

		Done - Need voicesActiveMask reset logic based on not looping
				V0ST_COMPARELENGTH	| _V0RESETCOUNTER	| VOICELOOPMASK0	| output
				0					| 0					| 0					| 1
				0					| 0					| 1					| 1
				0					| 1					| 0					| 1
				0					| 1					| 1					| 1
				1					| 0					| 0					| 0
				1					| 0					| 1					| 1
				1					| 1					| 0					| 1
				1					| 1					| 1					| 1
			(!a && !b && !c) || (!a && !b && c) || (!a && b && !c) || (!a && b && c) || (a && !b && c) || (a && b && !c) || (a && b && c)
			NOT a OR b OR c

		Done - Need address or loop address add to counter and memory read states
			V0ST_OUTPUTADDR
			V0ST_READRAM
			Created common adders for:
				COMMONADDRESS0..15
				COMMONPOSITION0..15
				COMMONREADADDRESS0..15
			TODO: Read debug and logic analyser indicates an incorrect value read for AUDA=4
				Perhaps the setup address time is not long enough?
				But reducing AUDCLK results in the RAMs not being written?!!
				d$00230002
				d$01c00003
			>>>>	d$01080004	Should be 0xff but reading 0x08???
				d$01730005
				d$01004020
			Why? With SAMP8 enabled in the simulation the RAM fails to write and read properly
				74245 is needed to isolate each RAM, it fixes the incorrect read
				The _OE,_WE, _CE is connected, just like all other RAMs for their respective banks
				_OE period has been reduced to only the time for address setup and read result
				_CE period has been reduced to only the time for address setup and read result, or EBS2 request time
				* This has fixed SAMP8 write issues and SAMPD read issues
					d$01230002
					d$01c00003
					d$01ff0004
					d$01730005
					d$01014020
					d$01024021
					d$01034022
					d$01014020
					d$01024021
					d$01034022

		* Done - Need to remove all unique voice internal terminals and group all unique voice input/output terminals for easier update

		Done - Need volume calculation, could be part of the common sample read module with a large EPROM
			This can simply cascade into the final output
			COMMONVOLUME0..7 created
			
		
		Done - And if not voice active then just output 0x80
			This could use the common logic from _VO_ADDRCNTOUT, when there is no RAM chip enabled at U1 (connected to _VO_ADDRCNTOUT and U52:C)
				This enables uses a latch and selector for the value to load into the final output after the volume calculation
				This uses AUDOE to combine detection for the sample RAM being written to and mutes the output when this happens

		
		* Done - Need to create other voices

		Done - And latch output of sample once for all four voices?
			Added extra step V0ST_OUTPUTADDR2 to allow V0ST_READRAM to be used for +ve edge trigger
			Cascade adders for sample?
			Then final output latch or 0xff read on carry detection for values > 0xff
			* At the end of a sample, without loop, does the MOD file player output a 0x80 or the last sample read?
			
		
		* Done - VOICELOOPMASK0 all of them, need to be moved to the left and connected
		

		* Check output data by using VideoHardware demo file and decoding the result for left and right channels
			* Use ffplay with u8 raw sample input
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 0 4
			"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 31250 c:\temp\t.bin
				Initial check seems to be OK, the pitch might be off, need to adjust for the final frequency


		
		* Done - The final output frequency from the hardware needs to be calculated and adjusted in the MOD converter
			The input clock rate for the crystal/oscillator will play a part here
			As will the final position of LOADOUTPUT which also resets the counters
				https://www.unitjuggler.com/convert-frequency-from-%C2%B5s(p)-to-Hz.html?val=40
				25000 Hz
					C:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\ffmpeg.exe -i "C:\Users\Martin Piper\Downloads\Digital Leisure\Dragon's Lair\VIDEO_TS\VTS_06_1.VOB" -y -acodec pcm_u8 -ar 25000 -ac 1 c:\temp\sample.wav
					Then trim the WAV header and make it 65536 bytes long for testdata\sample.pcmu8
				IntelliJ run config "TestRunner --exportmod (2)" used and "target\" music data files copied to testdata
				C64\VideoHardware\BuiltIt.bat also works


* When listening to the audio simulation output
	Simulation to use: C:\Work\C64\VideoHardware\target\debugData.txt
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\temp\t.bin
	Compared to the emulation debug output:
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\work\C64\VideoHardware\target\debugchannel.pcmu8

	The pitch seems to be off, perhaps there is a fault with the looping?
		Try one voice in simulation first
		
	* Or perhaps test the output from run configuration: TestRunner TestVideoHardware.feature
		Simulation to use: C:\Work\BDD6502\target\debugData.txt
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 C:\Work\BDD6502\target\debugchannel.pcmu8
		After editing: C:\Work\BDD6502\target\debugData.txt
			To find d$802c0100 and remove previous video writes, leaving the data writes intact
		The simulation pitch seems to be OK, but the audio is not entirely clean as expected
		Listening to the debug data from the channel pre-combination stage:
			c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudio.txt c:\temp\t.bin 3 4
			The audio also seems to not be clean, but of the correct pitch
	Indeed the DebugAudio.txt indicates incorrect memory address reads that are not entirely in sequence:
		d$00ff7d7d
		d$01008080
		>>> d$08017474
		d$01028383
		>>> d$08037171
		d$01048282
	AUDA breakpoint on 0x100
		Found: U34->U41 are inverted, whoops
		DebugAudio.txt indicates correct sequence now
		Correct audio plays now, sounds clean
	VideoHardware demo smoke test feature was also missing: And enable video display bus debug output
		So the debug output was a month old, not using the new rate->frequency conversion
	Need to test with new data
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 0 4
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 3 4
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 c:\temp\t.bin
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -ar 25000 C:\Work\C64\VideoHardware\target\debugchannel.pcmu8
	Sounds cleaner, but the pitch/address/loop still seems to be off still?
		Higher rates sound worse?
		* It looks like the "COMMONPOSITION" comparison lines are slightly wrong going into the comparators 7485s
			Sounds better now


			
			
			
* Master latch for mode7 regs?
	Plus independent x y counter reset? Which could actually be used to hold the counter low for interesting effects
	This would allow the copper to update in one pixel all the parameters and allow interesting effects where sections of the screen can be changed independently
	Try in emulation first
		Emulation looks good
	* Done - Extend to make all the MR lines independent, do not affect the clock lines
		reg	MR		tick
		x	_HSYNC	6MHz
		xy	_VSYNC	_HSYNC
		y	_VSYNC	_HSYNC
		yx	_HSYNC	6MHz
		Added handleRegisterFlags();
	* Done - Generate data (both of them) needs updating write: 0xa015=0x1f
	* Done - Hardware schematic needs to include extra logic for _HSYNC and _VSYNC based on flags
		Checked with test data
	* Done - Check extra AND gate IC usage and board group in Mode7
	* Check auto-place and route board size
	* Done - 6502 driver code needs write: 0xa015=0x1f
	* Done - Feature files need updating too

	
* Test: For audio playback of the audio simulation output:
	Run C:\Work\C64\VideoHardware\BuildIt.bat
		The digital data input uses the output debug bus data from the above demo
	Then use:
		c:\work\c64\bin\LZMPi.exe -hex C:\Work\BombJack\output\DebugAudioOutput.txt c:\temp\t.bin 1 2
		"C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffplay.exe" -f u8 -channels 2 -ar 25000 c:\temp\t.bin
	
	
	
* Audio - Consider sub-circuit mode for all other voices
	voice 0 starts, then at 7.7+ seconds voice 2 is active
	Root sheet 4 (voice0) schematic note:
		Copy this entire schematic to the first sub-circuit sheet.
		The sub-circuits are located on the next sheet.
	The sub-circuits are connected using voice 0 labels, the four channel output has been checked.
		Auto place and auto route checked
		
		
		
		
* At the moment the video and audio output uses a 2N-net resistor arrangement, but this can be inaccurate.
	https://hackaday.com/2015/11/05/logic-noise-digital-to-analog-with-an-r-2r-dac/
	Consider using a 2N-net arrangement: https://elinux.org/images/e/eb/Howtocolor.pdf
		Page 16 gives a good example
		Page 20 advises a pot for the audio volume
		Page 21 discusses SCART, but a composite signal, we want RGB
	https://www.retrorgb.com/csync.html discusses TTL sync and 330-450 ohm resistor
	https://en.wikipedia.org/wiki/SCART SCART lines are 75 ohms
	https://www.epanorama.net/faq/vga2rgb/scart.html also useful reference
	* Note example: TTL to SCART resistor ladder.pdsprj
	* Audio layout done
	* Video layout done, added proper output connectors
	* Analogue components are disabled in the simulations
	



* Building V3.0 video and char screen boards
	3 October 2020




* Are sheet 4 sprites 4E/4F really needed?
	They do bolster signals going to the internals of the sprite board: 5E 5F 6E 6F
	As well as somewhat isolating flow of sprite RAM read/write logic side of the board
	* Temporarily disabled 4E 4F and removed from placement. Wires connecting input to output added.
		TestData.txt and TestData2.txt seems to generate correct sprite animations




* For the sprite scan RAMs, while leaving the 2114s disabled in the simulation, add them back into the PCB layout
	This gives the option of using the single 6116 RAM, or two 2114s instead simply by populating the relevant sockets
	Also verify the value of the pull-up resistors
	Added 4A 4B 4C 4D with {GROUP=Sprites} to the sprites board
	** Done - Auto place and route needs testing
		Sprite board generated in V3.0 folder



* Rotated the memory bus and video headers in the schematic to match the PCB orientation



* Some of the 7432 components were using the wrong size package, don't know how that happened.
	Checked all other components for inconsistent sized packages
	U91 on the chars board was wrong, for example.
	Also the 6116FAST (chosen in the mouser.sg link) uses a narrow IC package, not a wide package. *Sigh*



* C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus.osp
	Is the OpenShot Video Editor project file for: C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus final.mp4
		https://www.openshot.org/download/
	the file looks like json format.
	To be honest, it's a little slow while using the editor. But it eventually let me assemble the various input files and produce a single video.
		However I noticed that during video export, around the 8 minute mark, it would produce corrupt video files *sigh*
	This can be used to increase the volume of a whole video file: "C:\Users\Martin Piper\Downloads\ffmpeg-20200422-2e38c63-win64-static\ffmpeg-20200422-2e38c63-win64-static\bin\ffmpeg.exe" -i "C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus final.mp4" -filter:a "volume=2.0" "C:\Users\Martin Piper\Videos\BombJack\BombJack with Proteus final louder.mp4"
	
	Links:
		The main project page with dev logs and downloads: https://martin-piper.itch.io/bomb-jack-display-hardware
		Proteus simulation and PCB design: https://www.labcenter.com/
		Xinweike PCB manufacture: http://www.xinweikedz.com/




* Done - Check "user port" orientation for UserPortBreakout.pdsprj and UserPortTo24BitAddress.pdsprj
	Avoid cable twists, remember component side is facing away from the computer *towards* the expansion board
	Added power planes, both GND




* Check vsync logic
	TODO - On the C64 it may signal the NMI only once on the edge *and* reset the CPU read signal once after it has been read (the read acknowledges it).
		Simulation checked: EXTWANTIRQ = _VBLANK which triggers on the negative edge at raster $f0
		Checked, it is a one off event that gets reset when the memory location is read - Check the C64 strobe behaviour
		Done, improved logic to reflect hardware - Check emulated logic around device.extEXTWANTIRQ() that it reflects a one shot strobe
		Done - Bus24Bit_WaitVBlank might need to be simplified to do an initial read, then wait for the single strobe, to align with the hardware
		Checked, setting EBBS = 0, waiting for VBLANK, setting EBBS=1, using some time, then setting EBBS = 0, does display expected raster line in hardware - Also Check the timing of the negative transition from the hardware with respect to the raster position




* Videos\BombJack\20201030_223915.mp4 shows the simple C64 memory bus interface working
	* BASIC test code needs a simple 8x8 character conversion routine, perhaps converting a string into bit planes sequentially line by line:
		a$="  123  4":gosub xxx
		a$="  1 3  3":gosub xxx
		... etc ...
	Where space (or 0) is transparent, and the numbers correspond to pixel colours 1-7
	* Try an assembly language wait for NMI to be read test. Should be possible to read the memory address and simply write the value to the border in a tight loop to test.
		Oh I so love not having even a simple assembler on the real C64. Since the 1541 drive is very ill and won't read my disks.
	Better demo: https://youtu.be/PXDLMjCwmgw
	* Daft idea, get the BASIC to write machine code for all of the memory writes it does, basically "compile" the output of the BASIC code. This will let me test how fast the simple memory bus is.
	* Created "BDD6502\features\TestVideoHardware Chars.a" and "BDD6502\features\TestVideoHardware Chars.feature" which uses a simple address bus and displays a static char screen using real 6502 code




* User port board is missing U2 and U24 because they are not part of the placement. These must have been unmistakably block copied with the option disabled.
	For now the following ICs will need to be moved to breadboard and their signals connected back. *Sigh*
		U13
		U12
		from pin 5 _MEWR of U24 will need to go to the top of the bus header
	* The hacky breadboard fix worked (see videos).



* Need user port board power LED





* Observed from the C64 user port, the byte output change and _PC goes low at the "same time".
	For the user port interface, U3 (the first EBBS latch) loads the byte value on the negative edge of _PC
	The positive edge of _PC is used is used to increment the state counter U1 and U22:A demux output
	But the U3 latch needs a data setup time of 20ns, which would indicate it does not fit the "at the same time" byte and _PC behaviour, so the U4:A NOR which has a 10-18 ns propagation time seems to be luckily giving just enough data setup time
	* Note: This is tested working on the C64, but it is slightly dodgy.
	* Alter the simulation data to reflect the "same time" change of the byte and the _PC signal.
		Then re-design the board such that the data setup time is definitely maintained
		* TODO: Perhaps OSCCLK could be used with a single flip-flop to buffer, and delay by one clock, the _PC signal
			Since the _PC -ve to +ve edge is 1us (1MHz) then a OSCCLK of 10MHz would be adequate. Currently the board uses 4MHz.
		These measurements explain that perhaps the introduced logic gate latency between data signal and latch is just long enough to reliably work...
			Measured from the C64 data arriving at the user port board (at 500 MHz): C:\temp\User port breakout capture 2.LPF
			The data signal is set 8ns before the -ve edge on _PC
			Measured propagation delay of the NOR _PC2 (-ve _PC to +ve CLK of U10) is 12ns
			Measured time from data signal to +ve CLK edge is 18ns
		The simulation also has 10ns propagation delay for the NOR
		* Done: The new 7474 U27 uses the user port _PC2 line (which in the renamed _PC) and outputs the real _PC. This gives a measured 130ns delay on the _PC2 to _PC transition.
			Board name now: C64 userport to 24 bit addr auto++ V1.2



* Hardware tests https://youtu.be/23YtiLoUx7U?t=850 indicated left hand pixel edge flickering issues for full screen height sprites: https://positronic-processing.slack.com/archives/C8GP4S84Q/p1608180015000600
	The SPRFULL signal makes U80 tri-state, ignoring the high nybble of the screen Y position, forcing the sprite to always be in range for output, thus making it full screen height
	The tri-state nature of the logic means it was not floating high quickly enough.
	Weak pull-up resistors (5.6k) we added to the outputs of U80, this fixed this left hand edge flickering issue. This is the same logic as the pull-up to $ff for the sprite scan RAMs




All layouts now use V3.1

* The pixel header rotations need to be consistent across the boards
	LAYER4 especially does not have the pixel and palette lines arriving in the same order as the other layers



* Char screen uses two extra lines for more chars. So only the bottom 16 palette entries can be used.
	However this SC4 allows the upper or lower palette to be used by the char screen instead.
	Current design has 0x9000 - 0x901f latching into U250, of which the lower bit is used for the lower or upper char palette bank select
		However this can be $9000 only in the future, if other character screen registers are needed





* C64 userport references
	Nice looking breakout board with reset button: https://www.tindie.com/products/syzygy_systems/c64-user-port-breakout-board-v11-syzygy-phobos/
	Just the connector: https://www.thefuturewas8bit.com/userport-connector.html
	Simple flashing LEDs example with code: https://coronax.wordpress.com/2012/08/11/the-commodore-64-user-port/
	Many edge connectors, need to verify board thickness and pitch: https://www.mouser.sg/Connectors/Card-Edge-Connectors/Standard-Card-Edge-Connectors/_/N-axj7dZ1yzvvqx?P=1ytcyi4Z1z0wxnn

	* Using logic analyser
	** C64UserPort.lpf shows 8_PC2 going low one cycle before data is output, then high one cycle after the data is output.
		** Checked : Check memory bus schematic expects this
	Also shows M_PA2 is able to be strobed by poke 56576,0 : poke 56576,4
		10 poke 56578,4
		20 poke 56579,255
		30 for i = 0 to 255
		40 poke 56577,i
		50 poke 56576,0 : poke 56576,4
		60 next i
		70 goto 30
	* Bus24Bit_WaitVBlank hardware signals tested
	
* UserPortTo24BitAddressSimple.pdsprj is a simple user port interface, not optimal at all as it uses a 4 bit data and 4 bit control protocol just using the bottom row of the user port
	* UserPortDataSimple.ptn and UserPortSignalsSimple.ptn demonstrate the input protocol and eventual memory writes
	It does however use very few ICs and allows the C64 to precisely control (slow) write timings rather than relying on a clock and other more complex logic
		Only 8x 74LS273 and 1x 74LS138
		
		
		
* UserPortBreakout.pdsprj
	Simple breakout board for user port
	Cables and connectors:
	https://www.mouser.sg/Wire-Cable/Cable-Assemblies/Ribbon-Cables-IDC-Cables/_/N-bkree?P=1yny8w4Z1yny8w3Z1yyu1hy&Keyword=idc&FS=True
	Reduced lengths search: https://www.mouser.sg/Wire-Cable/Cable-Assemblies/Ribbon-Cables-IDC-Cables/_/N-bkreeZ1yzvvqx?P=1yyu1hyZ1yny8w4Z1yny8w3Z1z0wxp6&Keyword=idc&FS=True
	https://www.mouser.sg/Connectors/Headers-Wire-Housings/_/N-ay0lo?P=1ytkn1nZ1z0wxp6Z1z0z63x&Keyword=idc&FS=True
	Same plug manufacturer as for the the cable: https://www.mouser.sg/Samtec/Connectors/Headers-Wire-Housings/_/N-ay0lo?P=1ytkn1nZ1z0z63xZ1z0wxp6Z1z0sq61&Keyword=idc&FS=True




* Move the layer output pixel headers up (or the bus interface downwards) to avoid the upper video generation board top edge. This will make it easier to access the lower board pixel and select headers.
	Version 4.0 PCBs



* Chars layer can have an enable / disable output flag using the new latch (U250), which goes to Enable on 6F6. This logic is roughly what the tiles layer does with 5N7
	EBBS $80 and Address $4000 is now used for char screen display data, writing memory now has priority, so no need to exactly time with the vblank to get guaranteed writes
		Older hardware prioritised video reads from the RAM, instead of prioritising video writes
	EBBS $01 Address $9000 bits:
		0		Palette bank
		1		Display output: 0 = Enable  / 1 = Disable
		7-8		Screen bank 0 - 3
	TestData*.txt updated, emulation code will need to be updated with new syntax
		Version 4.0 PCB
		
		

* Chars layer extra banks, can use the U250 latch of the high address bits? Use a 6264 like the tiles layer



* Components should be placed in imperial mode
	Tidied the layout of all the boards, including some passives




* V4.0 Real hardware When Tiles X scroll & 7 = 7 then the tile fetch timing goes from and corrupt data is fetch for the tile index
	Why? Colour timing clash fetch?
	Not seen in simulation
	** Prime suspect is the tiles X pos adder delay for U63/U64/U234
		* Probably best to latch the X and Y added output for safety
		A latched value will probably mean 1 pixel delay, the border shrink will need to take this into account
	** Or maybe 6S7 with _BGHSL2 CLK load, needs to have similar logic to that seen in 5S7 with 6MHz and OR added? This should time the read pulse better?
		This is also a simpler change than latching the entire adder value
	* Use TestTileScrolls.txt to test the pixel scroll values from 0 - 63 and verify output video before and after changes
	** Chars layers also updated to add 6N2:C 6N2:D to time the _SL1 _SL2 pulses using 6MHz, which times the +ve pulse to happen about 5ns - 20ns before to 2H or BGH4 changing state
		VIDCLK could be used to bring this sooner, but it should be fine
	* Running a test, disable the new signals on chars and tiles with a bypass. Generate lots of output frames with "debugold"
		Then add the new signals back again, generate more debug frames with "debug"
		** Then use the picture comparison to check, the pixels should be the same or better
			c:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\convert.exe -quiet -metric AE debugold00000000.bmp debug00000000.bmp -compare -format "%[distortion]" info:
			Or use this to compare the first 78 images: compareimages 78
				Which shows all zeros (followed by the file number compared)
	*** Need to test on the real hardware, remove 6S7, move to bread board, add a 7432 using 6MHz (pin 20 bottom left of Video header)
		It worked, with the code xpos&7==7 check removed. But the problem is that is same code works with the 74ls273 placed back into the socket but the boards are connected with ribbon cables. The 74273 is the same batch.
		The length of the ribbon cables might be causing the timings to "fix" themselves. The tiles video quality is noticeably reduced with vertical banding in scroll positions, with the socketed 74273, and the "fix breadboard" installed.
		It's also possible that the tiles board was not connected properly, but not that likely since the problem scroll position was 7 which is %111 (all three bits)
		** Fixed!
	*** Will need version increment for chars and tiles
		V4.1 for both now
	*** Check component layers
		Checked




* Tiles board, is there some weird timing issue when X flipped different tile indexes are adjacent? I'm seeing some wobbly pixels
	Perhaps the video board output needs to be properly latched to present a consistent stable source of RH and RV
	* Added, tested, validated sprite positions etc with emulation
	** V4.1 Video



* Why when using the 2MHz clock input to the digital data device, does ..\C64\VideoHardware\target\debugData.txt with RPG demo output fail to draw sprites on frame 33?
	compareimages.bat 34
		... all OK ...
		0         00000031
		0         00000032
		706         00000033
		744         00000034
	At 1MHz, errors fewer, but still:
		0         00000011
		91         00000012
		0         00000013
	Solved. The to low pulse was too soon after the start of the EBS asertion. This meant there wasn't enough OE cool down time before switching to WE and a logic contention was generated
	Now an external 2MHz clock and TOLOW=0.00000030 TOHI=0.00000039 can be used
	This means the APU could be setup to use a variable external clock, completely separate to the VIDCLK if needed
	* Sigh. Longer test with TestData.txt shows it's not solved, still getting sprite glitches and logic contentions
		Old VIDCLK derived values were: TOLOW=0.000000125 TOHI=0.00000025 for Q1
			But these now result in an "early trigger ignored" message from the improved data generator
			So trying slightly reduced values TOLOW=0.000000125 TOHI=0.000000225
	* Expanded the digital data model to include force hi/lo timings, as well as guard timings
		Setup to be the same as the old model, it validates exactly the same for 100 frames with TestData.txt
		Also RPG debug data up to 220 frames




* Programmable layer order selection
	Can use a few latches on the video board and selector 4-1 demuxes
	Added U263 latch and the rest of the memory address select logic
	Need to wire in the demux
	** 9900 is not a good choice, since it causes the sprite RAMs to be asserted
		Perhaps $9e08+ would be better, like the U230 in the Tiles layer, perhaps starting with _TEN9E08. Add a note to the tiles to say it has been taken by the video board.
		This has the benefit of not impacting any RAMs
	* Video layer now controls DISPLAYENABLE,_DISPLAYENABLE,BGBORDERX,BGBORDERY instead of the tiles layer. The signals are still passed through to all boards.
	* Due to the much longer path for output pixels, for the priority output select, all layers now need an extra output pixel latch on 6MHz. This means _EHSYNC, _EVSYNC, _ETVSYNC and ENABLEPIXELS are also latch delayed to compensate
	** The RPG demo can utilise this register to flip the cloud layer priority without changing the schematic
		Then in simulation - Tested
	** The bat ball demo can use this to shift the sprites behind the scrolling ship tile layer for some twinkling stars
	** BDD6502 needs updating to use this extra register in its layer combination logic
		The border and display enable flag detection can be moved out of the tiles layer
	* Need group check and version bumps on all layers




* Bit plane decoding logic, could remove the need for duplicate decoders/demultiplexers by moving the specific RAM _MEWR test and having a common test for the bit plane external RAM write test
	This would remove 6 quite large dexmux ICs for each board
	* Sprite logic works well
	* Chars logic also works
	* Tiles logic works
	* Update emulation memory address selection logic




* Add extra bit plane for each layer, change to using 16 colours for each CLUT
	The RPG demo will particularly benefit from more colours
	* The freed signal for the chars layer can then be used to address all 256 colours, not just the lower 128
	The 0 bank can be detected with a triple NAND from EA15/EA14/EA13
	* Done: BDD6502 will need to be updated to support extra colours (Turrican data test)
	* Extra pixel bitplane lines will need shifters
	* Video layer will need to to a 4 bit transparency check, not 3 bit check
	* Sprite transparency check will also need 4 input NOT and AND



* Instead of having 4 pixel headers in the video board, have one pixel input header. Then every board can have an input pixel and output pixel header instead.
	Each board can then do its own transparent pixel test and choose to pass-through the pixel or replace the pixel to its output pixel header
		The mode7 board can do an 8-bit pixel is transparent test, the other layers can use their 3-bit pixel test logic
	This would allow many more combinations of boards to be created and reduce the video board size.
	* Bad idea, the delays would kill the ability to process pixels fast enough.




* APU Bug. If a memory write to the instruction or data occurs, this causes the whole execution to pause until the next WaitForEqualsHV
	The APU, should resume instructions as soon as the writes finish (as long as it's not waiting of course)
	This is reproducible with "; Test memory access APU delay", note the RH and RV values for the first write if the memory writes are enabled
	* Actually, the U29 instruction latch is latching $ff for some reason?!
		Reason: While on LATCHINSTR state, the _INSTRSEL is hit, which resets the instructions
		Add an extra instruction latch, that only progresses the instruction if the first read was entirely OK
		Added extra latch for instruction bits 8-15




* APU Test that "kAPU_InterceptBus" is not needed before "kAPU_InterceptBus | kAPU_ExternalMEWR" due to the kAPU_ExternalMEWR being shifted later in the PCINCR cycle
	From: First rewrite 01 to MEWR breakpoint: 2.3148us	(RH 0x199 0x1a7 = 14 pixels)
	Also using "kAPU_Incr_ADDRB1 | kAPU_Incr_EADDR" instead of two instructions
	To: 1.1574us and still rewrites the correct data (RH 0x196 0x19d = 7 pixels)




* Programmable Macro Logic Device PMLD
	The end result would be to accelerate 3D polygon drawing, for example.
	A generic board with several external and internal RAMs, counters, and 8 bit registers.
	Some internal RAMs could be used as programmable ALU lookup tables etc
	Runs microcode than can trigger various latches and RAMs
	This could be an extension of the planned copper processor as it could in theory wait for horizontal and vertical pixel positions
		Then assert various values on the external memory bus, or its pixel output header
		The user port interface would need a "disable output" feature, make it tri-state
			Or this board could act as a memory/data pass-through board, where the user port memory interface is input and there is an output for the memory bus data.
				If the microcode had a default of memory pass-through mode, then during the visible portion of the screen it could take over the memory bus
				This would allow the C64 to control writes to the memory bus during the VBLANK and then the board can optionally takeover the memory bus when it needs
			Asserting the PMLD board EBS (to write its RAMs) will halt (not reset) the microcode PC clocking and processing
			It would need to pass back the VBLANK signal
	* APU.pdsprj
		On sheet 2 - EXPANSIONBUSA2, EXPANSIONBUSB2, EXPANSIONBUSC2 are all from the user port board
		All signals to be intercepted from the user port board are renamed to be prefixed with I
		Some signals can just pass straight through, so they are not renamed
		IED0..7	from the user port board eventually goes to ED0..7
		IEA0..15	from the user port board eventually goes to EA0..15
		IEBS0..7 from the user port board eventually goes to EBS0..7
		IEMEMWRITE from the user port board eventually goes to _MEWR
	* Need optional clock dividing and sync with either VIDCLK, 6MHz
	* Sheet 3
		Data bus selection logic, either pass through or intercept values
		Instruction and data memory logic
		APUPC0..12 = APU PC instruction counter
		APUDA0..12 = Current data address, also a counter but independent of the PC
	** Done: Need a recording of _VBLANK, RH0..8, RV0..7 for the signal generator that will emulate the video hardware signals
		Using VIDCLK timing
		Also perhaps the signals from VIDEO1 since they will be useful
	APU registers need to sit in EBS2 to allow an effective reset of internal state to be executed.
		If the APU is in pass through state, then all is good.
		If the APU is not in pass through state, then this will still allow the registers to be updated.
	** Perhaps instead of 8KB of 8 bit values, convert it into 1024 x (up to) 64 bit instructions from a bunch of parallel 2114s?
		This would allow the parallel microcode model instead of trying to decode quite a large instruction set
		Going to need assembler macros for this work I think
		Added 2114 RAM instead, to give INSTR0..15
		** Use the narrow 6116 instead, gives more memory for less board space. Also it's working in the sprites board scan RAMs
	* Very simple program with small loop is working: TestAPU1.a
	* Intercept bus logic
	Next need a simple wait instruction, this could reset a latch (that is usually set) pausing the the PC clock until the matching condition triggers a set latch condition
		On reset the latch needs to be set, allowing the PC clock to progress
		WaitForEqualsHV logic seems to be working
	* For the RAMs need to use the external bus, so the APU can write its own memory? Probably not needed, too much complexity
	* Read from ADDRB1 RAM and store write to external bus seems to be working
	** Done - Need wait to include X position, not just Y
	*** TestAPU1.a works so far!!! ***
	* Done - Need to check the bus sharing for RAM writes coming from an external source
		Seems to work, the initial write on $00000000 is being delayed until H$6d after the digital data debugger writes






* Video - Changing from 12.096MHz to 15MHz to enable a 320 pixel (480 scan) wide display
	output\12.096M compared to output\15M shows sprite colour issues with 15M.
		Similar was seen when attempting hires mode Done.txt: "There is a strange sprite colour corruption when running at VIDCLK = 24 MHz"
	* Perhaps this is due to ripple from the pixel counters?
		* Try adding a latch for the counter outputs
			No improvement
	* Perhaps it's the whole long pathway from U79?
		Note: Even at 15Mhz the data generator needs to use the next slower clock pulse, which kills the picture comparison test
		The sprites don't start drawing until 8 pixels delay from the first register read...
		So... Try latching the outputs from the RAMs to the internal values only when 8H is low
		However frame 1 is showing no change, since it is full frame without raster effects
			115         00000000
			0 	        00000001	<<<<<<****!!
			127         00000002
		* Fix at 15MHz! : For 7R which outputs _MDL _CDL _ VPL which latches the results of the frame, colour, vertical position
			The enable input uses 8H OR (Q output of 4S:B below)
			Visual verification of the sprites and other layers looks OK
		* TODO: Now to decide if I want the horizontal resolution to be increased...
		* TODO: Using a OR gate with both inputs tied together, check the timing on this, also test with a large number of frames at the same clock speed to decide if the improvement can be in the next revision regardless of the screen resolution
		* With original design, using TestData_DebugSprites2.txt, at 12.096M compared to 15.1M, the 15.1M clock using video with 768 as the horizontal resolution, the sprites have a gap at the right screen edge.
			The OR gate modification does not fix this issue.
			However the OR gate does not change the output at 12.096 rate when comparing 17 frames from TestData_DebugSprites2.txt
		* Using TestData.txt with 768 screen width at 12.096MHz original and with the OR gate improvement
			Frame 1 shows a small improvement in the "tall" sprite where in the original frame there is a corruption on a couple of lines where the sprite registers are updated.
				In the OR gate improved frame the corruption is removed, indicating the sprite register values are better latched in this scenario.
				Most of the frames are entirely the same however.
		* Added U54:C 7432 extra OR gate to help the sprite register load signals
		* A big change would be: Try adding 3 extra RAMs that consistently read the values and latch them with more time than trying to select all the values from the same RAM





* With the video circuitry tweaks, try a higher clock speed, note sprites
	Sprites still get that weird black drop shadow effect to the right hand edge
	Using TestData.txt with "Top left of non-rotated screen, all the same"
	The sprite scan line RAM indicates the calculated output pixels are the same, (f8 ff ... seen) which indicates the problem may be in the read or eventual output of those pixels
	Use: TestData_DebugSprites.txt
	Even the 32x32 sprites show the drop shadow effect, so the problem exists for all sprites regardless of their size
	It's not really a "drop shadow" it is actually the last trailing output pixel, when viewed from left to right in the scan line, that is black (or the wrong colour)
		The pixels are not displaced, or shifted
	At 12.096MHz execution: Breakpoint at RV=0x18 and then timed breakpoint execution for 21.5u
	Single Step Time was: 50n
		Now: 25n
	At faster MHz, use 14u timed breakpoint
	1V*. is low when RH=0x0008 and RV=0x18
	Tried a shorter scan line write pulse and longer read pulse, but this did not fix the issue The output pixel latch from the scan line RAM is still reading garbage.




* Split design into layers, use common bus for internal communications
	* Renumber component refs depending on their layer, 1xx main, 2xx screen... etc.
	* Main: Clocking, video timing, pixel combination and palette lookups
	* Screen + colour RAM
	* Sprites
	* Background picture



* TestSpriteTimings.txt
	Some sprite register timing tests, to help check multiplexor ideas with respect to writing certain registers outside of their update slots in the raster line






* APU try merging the APU with the main schematic to real bus signals?
	The headers and output signals might need some renaming
	Done - APU in schematic and test data needs EBBS changed from 0x04 to 0x02 (since the audio layer already uses 0x04 for sample data)
		Changed in readme already
	Done - Created C64\VideoHardware\asm\main3MultiplexAPU.a which exercises the expected sprite timing behaviour
	TODO - Emulation - For the clock edge related state signals, there needs to be a test for a previous inactive condition to allow for the edge to be activated
		Perhaps a debug warning when the condition is not met
	TODO - Consider another two bytes for the instruction and adding a few extra internal and external address latches, with a demux selector, and increment flags
		This would make sprites effects easier to code by having contiguous blocks of sprite registers in RAM
		However at the moment there is no "load" mechanism for the ADDRB1, it only has reset and increment
			To fully use this, there would need to be some generic read/write temporary registers as well the RAM for loads of the address
		It would also reduce the amount of reloading for the external EBS/EADDR
			kAPU_SelectEBS2EADDR2 - 1 bit for 74157 2 to 1 de-mux selecting the output of EBS/EADDR or another EBS2/EADDR2
			kAPU_Load_EBS2, kAPU_Load_EADDR2Lo, kAPU_Load_EADDR2Hi - 3 bits for load EBS2, EADDR2lo/EADDR2hi
			kAPU_Incr_EADDR2 - 1 bit for increment EADDR2lo/hi
		IDATA could have a 4 to 1 de-mux, giving RAM and 3 output 8 bit latches
			The 2 latches could also be wired for simultaneous 16 bit ADDRB1 lo/hi and perhaps PC load
				PC Load would allow for some kind of comparison and jump instruction
			kAPU_IDataSelectRAM, kAPU_IDataSelectReg0/1/2 - 2 bits for output de-mux select of RAM or DATAREG0/1/2
			kAPU_IDataRegLoad0/1/2 - 3 bits for latch loads of DATAREG0/1/2
		Extra ADDRB1 as ADDRB2
			kAPU_ADDRB2Select - 1 bit for 74157 2 to 1 de-mux selecting the output of ADDRB1 or another ADDRB2
			kAPU_Incr_ADDRB2 - 1 bit for increment ADDRB2
			kAPU_ADDRB1/2Load16 - 2 bits for ADDRB1 or ADDRB2 16 bit load from DATAREG0/1
	* Emulation works, now need to test the new instructions with the APU multiplexor test
		Done
	* Then schematic updates
		32 bit instruction read works, with latch
		Output still validates OK output\DebugAPUOutput.txt
	* Solved - Why am I seeing spurious zero memory writes at the recording digital data?
		d$00010000
		d$00010000
		d$00010000
		* The DigitalData model was interrupting with a spurious write to the last state very often. Oops!




* Need ADDRB1 lo/hi logic read, at the moment it's just reset
	Internal RAM read address





* For improved electrical performance
	Menu->Technology->Set Layer Stackup
		Inner 1 + 2 = Plane
		Other copper layers = Signal
		Create appropriate power planes on inner 1 , 2 , 4 using "Create Power Plane"
	Menu->Technology->Design Rule Manager
		Net Classes
			Power : Trace Style : POWER1
				Top/bottom + inner 4 at priority 3
			Signal : Trace Style : DEFAULT
				Top/bottom + inner4 + inner 3 + 4 at priority 1
	However, this does cause complex layers, like Mode7, to not route





* Consider reinstating 4E/4F?




* The "Sprite scan RAM logic" reads scan RAM, tests for transparency, writes sprite pixels in transparent or writes back existing value
	Perhaps change the logic so that the input sprite pixel is tested for transparency and only written if opaque?
		This would reduce the constant read, test, write back cycle to only test and optional write
		* This would mean the last sprite has priority instead of the first sprite however, i.e. the priority of sprites is reversed







* Consider higher current output than a normal 7805 regulator.
	https://www.mouser.sg/Semiconductors/Power-Management-ICs/Voltage-Regulators-Voltage-Controllers/Linear-Voltage-Regulators/_/N-5cg9g?P=1z0z63xZ1z0wadv&Keyword=7805&FS=True
	https://www.mouser.sg/ProductDetail/Texas-Instruments/UA7805CKCS?qs=IEl3ej0IqwDTl9fhEpiFdQ%3D%3D
	https://www.mouser.sg/ProductDetail/STMicroelectronics/LD1085V50?qs=%2Fha2pyFadugp3TsIEWjKyT083J8Jn3o2iWNBXzYOghY%3D
	Or buck regulator?
		https://fr.aliexpress.com/item/32726124435.html?ws_ab_test=searchweb0_0,searchweb201602_4_10065_10068_433_10000509_10000656_10136_10060_10062_10056_10055_10054_302_10059_10000636_10099_10103_10102_10096_10052_10053_10107_10050_10106_10051_10000090_10000729_10084_10083_10080_10082_10081_10110_10000375_10111_10112_10000377_10113_10114_10000349_10078_10079_10073_10000519_10070_10122_10123_10126_10000511_10124_10000514,searchweb201603_2,afswitch_1,ppcSwitch_5,single_sort_0_default&btsid=ba1207db-29e6-4f78-a993-ea479fd99bc0&algo_expid=179a1c71-1922-45a6-97fc-93dabe2447d3-0&algo_pvid=179a1c71-1922-45a6-97fc-93dabe2447d3
		https://fr.aliexpress.com/item/32689938167.html?ws_ab_test=searchweb0_0,searchweb201602_4_10065_10068_433_10000509_10000656_10136_10060_10062_10056_10055_10054_302_10059_10000636_10099_10103_10102_10096_10052_10053_10107_10050_10106_10051_10000090_10000729_10084_10083_10080_10082_10081_10110_10000375_10111_10112_10000377_10113_10114_10000349_10078_10079_10073_10000519_10070_10122_10123_10126_10000511_10124_10000514-10050,searchweb201603_2,afswitch_1,ppcSwitch_5,single_sort_0_default&btsid=466a6ab4-ecc2-442d-8954-e0821251912f&algo_expid=aa25a339-5e7a-4652-bdd2-e70b3f6ef4f2-2&algo_pvid=aa25a339-5e7a-4652-bdd2-e70b3f6ef4f2
		
	* It would help to estimate the total current used by by each board





* IC Sockets should ideally have flat pin spring connections, not round sockets.





** V3.0 needs to be regenerated
	Connectivity check passes
	These ICs were auto-placed, then horizontally and vertically gaps were added and added to the board. This promoted better auto-placement for other ICs and helped auto-routing.
		U136
		U71
		U207
		U215
		U229
		U224
	Added feature request: https://support.labcenter.com/forums/viewtopic.php?f=10&t=7821
	Note: Auto-route seems much easier when one board/group is auto-placed and routed instead of placing all the boards, then routing separately.
		Why? could be that when auto-placing all boards the layout is not as optimal.
			Comparing the force vectors between the "all board" and "single board" place shows major differences.
				Some components are pointing off board, when they should all be self contained to the group. This affects the placement.
	Note: Each board needs to be saved individually, with the other boards removed. Then place ICs by group: In PCB, components mode, use the drop-down filter, right click first component in list -> menu, "Place Group By Room"
		Then route each separate board




* Perhaps a layer combination board, which does the zero 3-bit or 8 bit pixel test and allows multiple expansion planes to be used?




* Investigate the "display enable" being used to still output video timings, just disable the pixel output
	This would allow memory updates to be enabled, without seeing bad video output and while maintaining video sync




* Auto-routing tests
	With default options, it takes ~15 minutes: https://support.labcenter.com/forums/viewtopic.php?f=5&t=7693
	Are there quicker options?
		Yes, changing the grid does help but sometimes the boards are not populated fully as they run out of space.




* VSMDD2 why is "w$ff01ff00,$3f018000" triggering near raster 2f?
	* The copper (VSMDD2) RV[0..7] input needed an extra latching 74273 (U84 excluded from PCB) to smooth the signal from the counters
		This kind of buffering logic is going to be needed on the real hardware, and might need to be added to the VSMDD2 inputs from the CLK
* Below might be related...
* Colour bars: With the sin/cos wave pattern, it seems to clamp to a bad value? Investigate the data driving this pattern...
	The horizontal and vertical pixel counters might need to be latched




* GenerateData2
	* Is the slight pixel ripple effect observed when moving right (output\debug2.gif) is the hardware or the virtual display adaptor...
	* Much higher X resolutions (like 1024 pixels) on the virtual display need to be tested...
		* Higher resolutions do show the grass an other tiles with some very thin vertical colour edge bleeding on perhaps the tile boundary
			This might be due to the colour RAM fetch not being completely synced with the tile pixel shifting and output mix?
			Or this might be caused by the horizontal and vertical pixel clocks not being latched from the counters, so the counter ripple is not quite exactly settling all at the same time?




* Copper plans
	If the hires xpos is used, then consider starting a _MEWR pulse at that point in time and any further writes would be based on that time too.
	This would allow hires writes to the background colour for example.
	Any subsequent writes could then be lower resolution to fit with RAM timing constraints.
	Could the copper board be built in-between the 24 bit parallel board and the main display board?
		Input = EBS + EAB + EDB + ROWCOL, output = EBS + EAB + EDB
			Internally EBS = 2 is used to trigger the copper and ROWCOL checks
			It could use VIDCLK and 6MHz lines from ROWCOL
	Note: The selector and RAM are used to show working memory writes in the main display board
	* It would be possible to store a 16 bit addition value, to facilitate storage of screen data that is stored in values +16 bytes at a time




* Note C5 200P capacitor, check it is a ceramic disc on the board




* Reorganise the memory map detection logic, remove 3M:A for ROMs, 3M:B 4M 5M 2S:B 1C:A
	Add new memory block detection for _9800CS, _9A00CS, _9C00CS, _9E00CS
	Use a memory block that is not used by the expansion RAM, perhaps the BASIC ROM area
	Check the CPU memory expansion, BUSDDR or CPUHASBUS can also be used to improve the memory block chip detection




* For integration with the TTL 8 bit CPU the VSYNC signal could be exposed to EXPANSIONBUS:EXTWANTIRQ
	Remove extra unused logic E7P:A E7P:B E6P:C 5P:A
	This will need a latch arrangement similar to the CPU latch, no use holding EXTWANTIRQ low for so long without being acked
	CPU->Root sheet 8->U250:A
		CIA1 read ACK U201:A




* Allow the _HSYNC and _VSYNC to be read via the external header, as memory mapped IO. Probably reuse the number of sprite register see _9A00CS
	This would need _MERD to be added to the external header. Also the BUSDDR would need to be used to enable the correct tri-state output
* Allow RH AND RV to be accessed via memory mapped IO




* The expansion bus and the memory write signals will need to be translated to the internal memory write signals




	
* 4C/4D when run at 6MHz will generate "sub optimal write pulses" errors with default values. Running at 1MHz fixes these issues.
	* The output pixel data seems to be better when the timing is reduced.
	* Investigate the output for read/write timings of these memory ICs for 6MHz operation.




* How many layers? Six?
	https://www.allpcb.com/6_layer_pcb.html
		Created template: All PCB Six Layer 1.58532mm.LTF
	http://referencedesigner.com/books/si/6-layer-stackup-ch6.php
	
	
* Singapore PCB fabrication:
	https://www.wizlogix.com/
	http://www.evonix.com.sg/PCBFabrication.php
	http://www.kentronicsengineering.com/
	



* All the very similar block, for the new RAMs and also the pixel shift outputs, could use a sub-circuit now
	Since they are RAM addressed and the ROM with its associated data file in the schematic is not important
	If the RAM/ROM names are still important, then have them outside of the sub-circuit



* Split this layout so that different output planes can be added or removed via internal headers, daisy-chained probably.
	The final combination logic can then take the output pixels and combine the final result via the pallet lookups





* When using TestData_DebugSprites2.txt and display width 1536, debug00000000.bmp will show at xpos 1536 for the column
	* A very slightly different incorrect red colour 240,48,48 instead of 240,0,0
		Interesting to note that the bad colour is on the leading left hand edge of the top right sprite vertical red column.
		But on the trailing right hand edge on the sprite underneath the top right sprite.
	* Larger widths show the pixel line is increasingly thin, so it is a very short signal
	* Use: TestData_DebugSignalSkew.txt
		Interesting, with "Setup grey background colour in the palette" the incorrect colour pixel is at x=1330 y=17, fire first correct red pixel is at x=1331
		Using the first correct red pixel is at x=1331 and the x=1330 pixel is 240,128,128, so the colour has changed
		* Added logic analyser to the FPR/G/B0-3 pixel outputs, it looks like the simulation software is emulating a "random" signal variation in the two output pixel hex latches 74LS174
			Changing to three separate latches and the pattern is the same
			Maybe it is simulating the time taken to transition from lo to hi or hi to lo
			* Since the time to really show the complete transition is ~4ns, this means for some pixel positions the incorrect and correct values can be in two adjacent pixels from the display
				Add a new display "filter signals shorter than" option to the digital display: 5ns should be good enough, or 0.000000005 seconds.



* Added backplane, memory, and video right-angled connectors and headers. Removed the old vertical headers.
	Added VGA female D-sub connector VID2 which uses TVSYNCout for the HSYNC, which gives RGBS or RGBHV option in the conversion box
	Pixel headers as RA enclosed



* Remove the extra headers on the video layer
	Moved to backplane as they form the remaining compatibility header



* Back plane headers are 1,000 mil, ~23mm apart, wide enough to accommodate the ICs with decoupling sockets.
	Added to the backplane headers: UNUSEDEXPANSION*, UNUSEDVIDEO*
		This is so the same backplane can be used if the video layers need unexpected signals
		
		
		
		
* APU. Consider a game with double buffered screens, as is fairly common.
	Need a way for the APU to jump back to a PC and render the screen again using the current screen, or progress onto the second screen.
	* Perhaps have a new instruction kAPU_PCLoad16 which loads from reg0+1
		Done - Schematic kAPU_PCLoad16
		Also have a kAPU_SkipIfEQ which skips the instruction, by zeroing the instruction latches, if the current IDATA0 (IDATA bit 0) is zero
			It will be a good idea to have a stabilise instruction to make the chosen IDATA stable before using IfEQ
		This would allow the game code to have a memory location as a flag.
			Data registers could also be used if they are selected into IDATA, however since they are mostly used by non-trivial code then the extra complexity of allowing the user to independently reset them has little return.
		Done - Schematic kAPU_SkipIfEQ
		** Done - Emulation kAPU_PCLoad16
		** Done - Emulation kAPU_SkipIfEQ
		Schematic behaviour matches emulation





* Mode7 7483 is hard to find, needs to use 74283 instead
	Need to check using compareimages.bat





* APU: If I do add an extra register and some adders, I can use that as a free comparison function
	* Done: Emulation and schematic: kAPU_SkipIfEQ: In combination with a full 8 bit EQ check
	* Done: Remove kAPU_InterceptBus it's always and only used with the external memory write. It could be used for internal memory write instead.
	* 74LS251 could be used to select various results and the extra register
		https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS251NE4?qs=SL3LIuy2dWxH4pHshllfNQ%3D%3D
		* Done: kAPU_Reset_EBSEADDR / _Reset_EBSEADDR and _Reset_EBSEADDR2 (undefined input to U37:B) seems to be little use, reclaim it for extra internal register?
		* Now 4 signals free
		** Done: Add load DataReg3/4
		** TODO: IDataSelect extra results
			Memory
			DataReg0
			DataReg1
			DataReg2
			DataReg3
			Memory + DataReg3
			DataReg3 + DataReg4
			DataReg3 - DataReg4
			* Schematic and code changes done for extra data select logic
				*Needs unit tests - Unit tests done - Schematic validated




* Use new APU add/sub instruction to move sprites in SotB demo




* For board EA/EBS/EXTSEL config - Need to use jumpers (in the schematic it is closed to use the defaults) to connect the external bus to the internally used signals
	The routing will then not automatically connect the gap
	Jumpers should be placed on the edge of the board away from the interconnects
	* Added jumpers for EBS on main video boards




* Consider again char screen scrolling with large virtual screen, like the tiles
	Use case is the SotB demo title screen for the scrolling logos
		Some of the logic for the timing signals already exists on the layer.
		Perhaps the X and Y pos can use 8 bit latches, since the virtual screen will be 2x2 screens of 32x32 chars each
	* Using Bomb Jack - Chars scroll.pdsprj
		When BGXP = 2 or 3 then the char read into 5L6 seems to be wrong on the left and right edges?
			Tested by setting the palette read to be constant 0 colour (disable the colour load clock)
			The problem still happens, therefore the char seems to be wrong during that load
	* Moving the SL1 timing to after the SL2 time seems to fix the issue. Evidently the address is not quite right at the start of the character
		Need to check with more data
	* Done: Might need a MSB for the X and Y scroll registers!
	Simulation checks out with more generated data for X/Y char screen scrolls with wraparound checks
	* Done: Emulation needed
	* Done: Test with simulation from emulation output
	* Done: Update SotB demo to use the hardware chars scroll with a screen split, not APU updated char screen data
		Check with simulation



* Adjusted the left hand board edges to match the edge locating lip for the plugs
	Also adjusted the VGA output header position to sit further inside the edge
	
	
	
	
* Rename IC names like "5E2" because they are being interpreted as as a numeric value "500" (i.e. 5x10^2) and not the text value when reading the CSV
	Now prefixed with "L"



* Moved the labels on the board edge plugs



* The edge jumpers are marked with the default choice to close


* Board _EXTCS default connections now have labels



* Audio and APU boards, with EBS selection jumpers and plane layers, are aligned with the main boards




* Audio: 4082 to be replaced by 74LS21 https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS21NE4?qs=sGAEpiMZZMtMa9lbYwD6ZGuuqVaqkGmOS8GB5LKZP7E%3D
* Audio: 4075 to be replaced by 74 series logic. 7427 + 7404
* Audio: 7413 to be replaced by 7420 https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS20NE4?qs=SL3LIuy2dWy4R7Pu4ZGI8g%3D%3D
* Audio: 7483 to be replaced by 74283
* Audio: 74154 to be replaced by 74 series logic... A few more 74HC138 for example, which really uses this LS variant... https://www.mouser.sg/ProductDetail/Texas-Instruments/SN74LS138NE4?qs=sGAEpiMZZMtxONTBFIcRfk9GpaUoLd0ck0Ao35GjMhY%3D
	Tested



* Audio: Stock code and Supplier updated



* Hires original PCB: https://live.staticflickr.com/6079/6106060384_34ad2ad34d_k.jpg
	Shows MN2114-2 at row 6 (check the right hand edge numbering)
		http://www.science.smith.edu/~jfrankli/270s02/datasheets/2114.html
		Which means similar to: 2114AL-2 - 120ns Max (40ma Max) ???



* V6.0

* 2114 SRAM might be unreliable to find. Consider using the same workaround from the sprite layer scan lines
	Two 6116 SRAM have been added, the original 2114 SRAMs have been disabled from the simulation, but left in the layout to allow for both chip types to be used.
