; Simple CPU Fibonacci test
; https://docs.google.com/document/d/1scCYfTEw1mQYNbtYTEA1E8sRUwHvc7d2FfL6wf29QfI/edit?usp=sharing
; cls && ..\C64\acme.exe -f plain -o target/i0.bin --setpc 0 SimpleCPU_Fibonacci.a && ..\C64\acme.exe -f plain -o target/i1.bin --setpc 1 SimpleCPU_Fibonacci.a && ..\C64\acme.exe -v4 -f plain -o target/i2.bin --setpc 2 SimpleCPU_Fibonacci.a

; This automatically splits the instruction output bytes for each ROM depending on the input PC offset
!set InstructionOffset = *

!macro MI .i , .imm {
!if InstructionOffset = 0 {
	!by <(.i)
}
!if InstructionOffset = 1 {
	!by <(.i >> 8)
}
!if InstructionOffset = 2 {
	!by <.imm
}
}

!macro MI .i {
	+MI .i , 0
}

IWrite_RegA			= %0000000000000001
IWrite_RegB			= %0000000000000010
IWrite_RegC			= %0000000000000100
IWrite_RegAddr		= %0000000000001000
IWrite_RegPC		= %0000000000010000
IWrite_RAM			= %0000000000100000
;Only choose one of ISel_*
ISel_Imm			= %0000000000000000
ISel_RAM			= %0000000001000000
ISel_RegA			= %0000000010000000
ISel_RegB			= %0000000011000000
ISel_RegC			= %0000000100000000
ISel_RegAddr		= %0000000101000000
ISel_RegPC			= %0000000110000000
ISel_ALU			= %0000000111000000
; Tweak the ALU calculation between A+B and A+immediate
IALU_AB				= %0000000000000000
IALU_Imm			= %0000001000000000
IIfNotZero			= %0000010000000000
IWrite_ALUResult	= %0000100000000000

;Write Addr , #13
	+MI IWrite_RegAddr | ISel_Imm , 13
;Write A , #0
	+MI IWrite_RegA | ISel_Imm , 0
;Write B , #1
	+MI IWrite_RegB | ISel_Imm , 1
;
.loop
;	Write RAM, Write C , Add A , B
	+MI IWrite_RAM | IWrite_RegC | ISel_ALU | IALU_AB
;	Write A , B
	+MI IWrite_RegA | ISel_RegB
;	Write B , C
	+MI IWrite_RegB | ISel_RegC
;	Write Addr , Add A , #2
	+MI IWrite_RegAddr | ISel_ALU | IALU_Imm , 2
;	; This Add is used as a comparison for, the result is not stored, it behaves like a conditional branch or jump
;	Add C , #-89 If not zero Write PC , #.loop
	; Note: Cannot have two immediate values. Need to write into ALU result and then test
	+MI IWrite_ALUResult | ISel_ALU | IALU_Imm , -89
	+MI IIfNotZero | IWrite_RegPC | ISel_Imm , .loop - InstructionOffset
;
;	; An infinite loop that effectively terminates the code
.end
;Write PC , #.end
	+MI IWrite_RegPC | ISel_Imm , .end - InstructionOffset
